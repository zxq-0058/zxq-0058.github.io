<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PA4.1</title>
      <link href="/2021/12/15/PA4-1/"/>
      <url>/2021/12/15/PA4-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-kcontext-的实现"><a href="#1-kcontext-的实现" class="headerlink" title="$(1)kcontext$的实现"></a>$(1)kcontext$的实现</h3><p>实现相对简单<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kcontext</span></span><br><span class="line">Context * ctx = (Context*)(kstack.end - <span class="keyword">sizeof</span>(Context)); <span class="comment">// 创建context</span></span><br><span class="line">ctx-&gt;mepc = (<span class="keyword">uintptr_t</span>)entry; <span class="comment">// 设置返回地址</span></span><br><span class="line"><span class="keyword">return</span> ctx;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>在$loader.c$创建函数<code>context_kload</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_kload</span><span class="params">(PCB *pcb, <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// creat a kernel stack</span></span><br><span class="line">    Area kstack;</span><br><span class="line">    kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">    kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set pcb context pointer as the return value of kcontext</span></span><br><span class="line">    pcb-&gt;cp = kcontext(kstack, entry, arg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-am-asm-trap"><a href="#2-am-asm-trap" class="headerlink" title="$(2)am_{-}asm_{-}trap$"></a>$(2)am_{-}asm_{-}trap$</h3><div class="note primary"><p>在$pa3.1$的实现$mret$指令时，我们已经对汇编代码进行解读，里面涉及的关键点就是寄存器$a_0$, 从$am_{-}asm_{-}trap$跳转到$handle$函数之前，<code>mv a0 ,sp</code>将参数地址写到$a_0$. 我们当时并没有讲到返回值的处理问题。实际上，$a_0$也是函数调用返回值的存放位置，因此从$handle$回到$am_{-}asm_{-}trap$之后，添加<code>mv sp a0</code>就可以了。</p></div><h3 id="3-hello-fun-添加-arg"><a href="#3-hello-fun-添加-arg" class="headerlink" title="$(3)hello_{-}fun$添加$arg$"></a>$(3)hello_{-}fun$添加$arg$</h3><div class="note info"><p>$context$的若干$GPR$的作用在$pa3$里面已经很清楚了，此处做一个总结：</p><ul><li>$GPR1\ gpr[17]\ a7$  $type$</li><li>$GPR2\ gpr[10]\ a0$  第一个参数</li><li>$GPR[3|4]\ gpr[11|12]\ a[11|12]$  第二、三个参数</li><li>$GPRX\ gpr[10]\ a0$  返回值</li></ul></div><p>作如下的代码修改：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kcontext</span></span><br><span class="line">  <span class="keyword">if</span>(arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ctx-&gt;GPR2 = (<span class="keyword">uintptr_t</span>)arg;</span><br><span class="line">  &#125;<span class="comment">//传参,记得判断！NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init_proc</span></span><br><span class="line">context_kload(&amp;pcb[<span class="number">0</span>], hello_fun, <span class="string">&quot;THe 1st&quot;</span>);</span><br><span class="line">context_kload(&amp;pcb[<span class="number">1</span>], hello_fun, <span class="string">&quot;THe 2st&quot;</span>);</span><br></pre></td></tr></table></figure><br>实现效果：<br><img src="/2021/12/15/PA4-1/1.png" alt></p><div class="note warning"><p>尝试将$nanos-lite/src/main.c$的$yield$注释掉，看看会出现什么现象。<br>上述代码只是将$hello_{-}fun$的入口地址和参数放在内核区域，并没有马上跳转到$hello_fun$流程如下：<br><img src="/2021/12/15/PA4-1/12.png" alt></p></div><h3 id="4-用户进程"><a href="#4-用户进程" class="headerlink" title="$(4)$用户进程"></a>$(4)$用户进程</h3><h4 id="4-1-ucontext-和-context-uload-的实现的实现"><a href="#4-1-ucontext-和-context-uload-的实现的实现" class="headerlink" title="$(4.1)ucontext$和$context_{-}uload$的实现的实现"></a>$(4.1)ucontext$和$context_{-}uload$的实现的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Context *<span class="title">ucontext</span><span class="params">(AddrSpace *as, Area kstack, <span class="keyword">void</span> *entry)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// almost the same as kcontext</span></span><br><span class="line">  Context * ctx = (Context*)(kstack.end - <span class="keyword">sizeof</span>(Context));</span><br><span class="line">  ctx-&gt;mepc = (<span class="keyword">uintptr_t</span>)entry;</span><br><span class="line">  assert(ctx != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_uload</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the app entry</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> entry = loader(pcb, filename);</span><br><span class="line">  <span class="comment">// 用内核区保存上下文结构体，入口保存在内核区</span></span><br><span class="line">  Area kstack;</span><br><span class="line">  kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE; </span><br><span class="line"></span><br><span class="line">  pcb-&gt;cp = ucontext(<span class="literal">NULL</span>, kstack, (<span class="keyword">void</span>*)entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把栈顶位置设置到GPRx中</span></span><br><span class="line">  <span class="keyword">void</span>* Ustack_Top = heap.end;</span><br><span class="line">  pcb-&gt;cp-&gt;GPRx = (<span class="keyword">uintptr_t</span>)(Ustack_Top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary"><p><code>_start</code>修改?!<br>Nanos-lite把栈顶位置设置到GPRx中, 上述代码已经实现了.但是这个返回值要怎么处理呢?<br>查看$crt0/start$的$riscv32.S$, 在跳转到<code>call_main</code>之前添加<code>mv sp, a0</code>就可以将返回值设置到栈指针寄存器<code>sp</code>了.<br>让我们再来梳理一下流程:<br><img src="/2021/12/15/PA4-1/13.png" alt><br>这样一来,我们就可以看到二者”同时运行”的状态了.</p></div><h4 id="4-2-用户进程的参数"><a href="#4-2-用户进程的参数" class="headerlink" title="$(4.2)$用户进程的参数"></a>$(4.2)$用户进程的参数</h4><h5 id="1-参数解析"><a href="#1-参数解析" class="headerlink" title="$(@1)$参数解析"></a>$(@1)$参数解析</h5><div class="note info"><p><code>char ** argc | char * argv[]</code><br>参考:<a href="https://stackoverflow.com/questions/29338321/how-initialize-char-const-argv-in-c">https://stackoverflow.com/questions/29338321/how-initialize-char-const-argv-in-c</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_proc()</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">&quot;--skip&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span>&#125;;</span><br><span class="line">  context_uload(&amp;pcb[<span class="number">1</span>], <span class="string">&quot;/bin/pal&quot;</span>, argv, envp);</span><br></pre></td></tr></table></figure></p></div><p>需要认真理解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">|               |</span><br><span class="line">+---------------+ &lt;---- ustack.end</span><br><span class="line">|  Unspecified  |</span><br><span class="line">+---------------+</span><br><span class="line">|               | &lt;----------+</span><br><span class="line">|    string     | &lt;--------+ |</span><br><span class="line">|     area      | &lt;------+ | |</span><br><span class="line">|               | &lt;----+ | | |</span><br><span class="line">|               | &lt;--+ | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|  Unspecified  |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|     NULL      |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|    ......     |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|    envp[1]    | ---+ | | | |</span><br><span class="line">+---------------+      | | | |</span><br><span class="line">|    envp[0]    | -----+ | | |</span><br><span class="line">+---------------+        | | |</span><br><span class="line">|     NULL      |        | | |</span><br><span class="line">+---------------+        | | |</span><br><span class="line">| argv[argc-1]  | -------+ | |</span><br><span class="line">+---------------+          | |</span><br><span class="line">|    ......     |          | |</span><br><span class="line">+---------------+          | |</span><br><span class="line">|    argv[1]    | ---------+ |</span><br><span class="line">+---------------+            |</span><br><span class="line">|    argv[0]    | -----------+</span><br><span class="line">+---------------+</span><br><span class="line">|      argc     |</span><br><span class="line">+---------------+ &lt;---- cp-&gt;GPRx</span><br><span class="line">|               |</span><br></pre></td></tr></table></figure><br>解析参数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_uload</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the app entry</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> entry = loader(pcb, filename);</span><br><span class="line">  <span class="comment">// 用内核区保存上下文结构体，入口保存在内核区</span></span><br><span class="line">  Area kstack;</span><br><span class="line">  kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE; </span><br><span class="line"></span><br><span class="line">  pcb-&gt;cp = ucontext(<span class="literal">NULL</span>, kstack, (<span class="keyword">void</span>*)entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize stack end by new_page</span></span><br><span class="line">  <span class="keyword">void</span>* Ustack_end = new_page(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串区域的开始地址, 可以自己决定String_Area_Size,比如512,1024</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> String_Area_Start = (<span class="keyword">uintptr_t</span>)(Ustack_end - String_Area_Size);</span><br><span class="line">  <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the value of argc and store it directly at Addr : heap.end - Usr_Stack_Size</span></span><br><span class="line">  <span class="keyword">int</span> * argc = (Ustack_end - Usr_Stack_Size);</span><br><span class="line">  *argc = <span class="number">0</span>; <span class="comment">//initialization</span></span><br><span class="line">  <span class="keyword">while</span>(argv[*argc] != <span class="literal">NULL</span>)(*argc)++;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// to load the arg vector, recall that argv_0, argv_1 ... are char *</span></span><br><span class="line">  <span class="comment">// argv_0 在argc的上面一个单元位置</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> * argv_0 = Ustack_end - Usr_Stack_Size + <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> One_String_Size = <span class="number">16</span>; <span class="comment">// decide by you own</span></span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)*argv_0 = (<span class="keyword">uintptr_t</span>)<span class="literal">NULL</span>; <span class="comment">// empty string </span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *argc; i++) &#123;</span><br><span class="line">      *(argv_0 + i) = String_Area_Start + offset; <span class="comment">// 让argv_i指向对应的字符串的开始位置</span></span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(String_Area_Start + offset), argv[i]); <span class="comment">// 将argc[i]复制到指定区域</span></span><br><span class="line">      offset += One_String_Size;   </span><br><span class="line">    &#125;</span><br><span class="line">    *(argv_0 + *argc) = (<span class="keyword">uintptr_t</span>)<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO : envp is just the same</span></span><br><span class="line">  Log(<span class="string">&quot;Successfully load the arguments!&quot;</span>);</span><br><span class="line">  pcb-&gt;cp-&gt;GPRx = (<span class="keyword">uintptr_t</span>)(Ustack_end - Usr_Stack_Size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note info"><p>修改Navy中_start的代码, 把argc的地址作为参数传递给call_main()?!<br>我们已经不止一次提到参数传递了,对于$riscv32$, $a_0$一方面作为context的返回值$GPRx$, 另一方面又可以直接作为参数(当只有一个参数时),因此<code>riscv32.S</code>的<code>_start</code>并不需要修改,或者你可以认为<code>mv a0 a0</code>.<br>至于在<code>call_main</code>解析参数,这并没有什么难的.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> argc = *args;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to get the arg vector</span></span><br><span class="line"><span class="keyword">char</span> *argv[argc];</span><br><span class="line"><span class="keyword">uintptr_t</span> * argv_0 = args;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= argc; i++) &#123;</span><br><span class="line">    argv[i - <span class="number">1</span>] = (<span class="keyword">char</span>*)(* (argv_0 + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simply ignore the envp since it is useless</span></span><br><span class="line"><span class="keyword">char</span> *empty[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">environ = empty;</span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv, empty));</span><br><span class="line">assert(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p></div><h5 id="2-execve"><a href="#2-execve" class="headerlink" title="$(@2)execve$"></a>$(@2)execve$</h5><p>$nanos-lite$的<code>Sys_execve</code>,实现比较简单.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果它执行成功, 就不会返回到当前程序中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sys_execve</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv [], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过fs_open()来进行检查.</span></span><br><span class="line">  <span class="comment">// 如果需要打开的文件不存在, 就返回一个错误的值, 此时SYS_execve返回-2</span></span><br><span class="line">  <span class="keyword">int</span> fd = fs_open(filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    Log(<span class="string">&quot;No such file or directory: %s&quot;</span>, filename);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将current的context信息修改</span></span><br><span class="line">  context_uload(current, filename, argv, envp);</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line">  yield();<span class="comment">// 进程调度</span></span><br><span class="line">  panic(<span class="string">&quot;Should not reach here!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note success"><p>请仔细阅读<code>exec-test</code>的测试代码,解释为什么<code>init_proc</code>的调用如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">&quot;/bin/exec-test&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span>&#125;;</span><br><span class="line">context_uload(&amp;pcb[<span class="number">1</span>], <span class="string">&quot;/bin/exec-test&quot;</span>, argv, envp);</span><br></pre></td></tr></table></figure><br>最后,测试成功的图片如下:<br><img src="/2021/12/15/PA4-1/14.png" alt></p></div></p><h5 id="2-pal-—skip"><a href="#2-pal-—skip" class="headerlink" title="$(@2)pal —skip$"></a>$(@2)pal —skip$</h5><p>在<code>builtin-sh.cpp</code>的cmd处理函数添加处理代码:<br>这里简化处理了,只是考虑了只有一个参数的情况.即使是多个参数,也是类似的处理.<br>至于在pal的main函数怎么处理<code>--skip</code>参数,这个就很简单了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sh_handle_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> pathname[<span class="number">16</span>], argv_0[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the pathname | filename</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(; i &lt; <span class="built_in">strlen</span>(cmd); i++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(cmd[i] != <span class="string">&#x27; &#x27;</span>)pathname[i] = cmd[i];</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">        pathname[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(cmd[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(cmd))i++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// to get the argv[0]</span></span><br><span class="line">  <span class="keyword">int</span> break_i = i;</span><br><span class="line">  <span class="keyword">for</span>(; i &lt; <span class="built_in">strlen</span>(cmd) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    argv_0[i - break_i]= cmd[i];</span><br><span class="line">  &#125;</span><br><span class="line">  argv_0[i - break_i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * argv[Max_Arg_Nr] = &#123;argv_0, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  execvp(pathname, argv);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning"><p>使用了<code>execvp</code>的前提是正确设置env参数,请在<code>builtin-sh.cpp</code>的<code>builtin_sh_run</code>函数的<code>while</code>循环之前添加:<br><code>setenv(&quot;PATH&quot;, &quot;/usr/bin:/bin&quot;, 0);</code></p></div><br><div class="note primary"><p>尽管能够满足最低要求了,但还是感觉上面的实现不太满意?!<br>这里给出一份实现更加优美的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> split[<span class="number">2</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sh_handle_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// since cmd is end with &#x27;\n&#x27;, we have a pretreatment</span></span><br><span class="line">  <span class="keyword">char</span> cmd_cpy[<span class="number">32</span>],pathname[<span class="number">16</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(cmd_cpy, cmd);</span><br><span class="line">  cmd_cpy[<span class="built_in">strlen</span>(cmd) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> argc = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">char</span>* argv[Max_Arg_Nr] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *token;</span><br><span class="line">  token = strtok(cmd_cpy, split);</span><br><span class="line">  <span class="keyword">while</span>(token != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(pathname, token);</span><br><span class="line">      argc = <span class="number">0</span>;</span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      argv[argc++] = token;</span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, split);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  execvp(pathname, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第十次OJ</title>
      <link href="/2021/12/07/%E7%AC%AC%E5%8D%81%E6%AC%A1OJ/"/>
      <url>/2021/12/07/%E7%AC%AC%E5%8D%81%E6%AC%A1OJ/</url>
      
        <content type="html"><![CDATA[<h2 id="A-加密"><a href="#A-加密" class="headerlink" title="A. 加密"></a>A. 加密</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>题目描述<br>现在有一个这样的加密算法，将原文数字$w$加密为密文$c$：</p><p>Step 1：在$[10^5,10^9]$随机的选择一个正整数$x$。</p><p>Step 2：找到最大质数$p$，满足$p\leq x$。</p><p>Step 3：找到最小质数$q$，满足$q &gt; x$。</p><p>Step 4：令$n=p\cdot q$。</p><p>Step 5：计算$w^{2^{30} + 3}\ mod \ n$得到$c$。</p><p>现在给你密文$c$，以及上述算法过程中的$n$，你需要还原原文$w$的值。保证$0\leq w &lt; n$。<br><span id="more"></span><br>输入格式<br>第一行一个正整数$T$，表示测试组数。</p><p>接下来$T$行，每行两个正整数$n,c$，保证$10^{10} \leq n \leq 10^{18}, 1\leq c &lt; n$</p><p>输出格式<br>共$T$行，第$i$行一个正整数，表示第$i$组测试的答案。</p><p>样例<br>Input<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">181857896263</span> <span class="number">167005790444</span></span><br><span class="line"><span class="number">218128229323</span> <span class="number">156323229335</span></span><br><span class="line"><span class="number">352308724847</span> <span class="number">218566715941</span></span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175267324024</span></span><br><span class="line"><span class="number">209603568635</span></span><br><span class="line"><span class="number">282077284785</span></span><br></pre></td></tr></table></figure><br>数据范围与提示<br>对于$50\%$的数据， $1\leq T \leq 10$。</p><p>对于$100\%$的数据，$1 \leq T \leq 10^5$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>以下$e, d$分别代表$RSA$加密和解密的钥值。<br>本题相当于$RSA$加密机制中告诉了公钥对$(n, e = 2^{30} +3)$, 假设已经求出$p, q$, 那么$d = e^{-1}\ mod\ (\phi(n))$。<br>因此$w = c^d\ mod n$<br><div class="note info"><p>题目的前3步使得$n$的分解代价不会太大：$q-p$的值不会太大，并且二者距离$\sqrt n$不会太大。</p></div><br>$code_1$:这里求$w = c^d\ mod n$用了题目$C$的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line">ll n, c, w;</span><br><span class="line"><span class="keyword">const</span> ll e = (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) + <span class="number">3</span>;</span><br><span class="line">ll p, q, d, phi;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速乘法</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_mul_mod</span><span class="params">(ll x, ll y, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = (ret + x)%mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = (x + x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用的快速乘的快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_power_mod</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = <span class="built_in">qucik_mul_mod</span>(ans, a, mod);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        a = <span class="built_in">qucik_mul_mod</span>(a, a, mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;y = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line">y -= (a/b) * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算a关于mod的乘法逆元</span></span><br><span class="line"><span class="function">ll <span class="title">mod_reverse</span><span class="params">(ll a, ll mod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际上就是调用拓展的欧拉函数</span></span><br><span class="line">    <span class="comment">//记b = mod</span></span><br><span class="line">    <span class="comment">//等价于求出ax + by = 1的x</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, mod, x, y);</span><br><span class="line">    <span class="comment">// To make sure x is positive</span></span><br><span class="line">    <span class="keyword">return</span> (x%mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出p, q</span></span><br><span class="line">        p = (ll)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">double</span>)n);</span><br><span class="line">        <span class="keyword">while</span>(n%p != <span class="number">0</span>)p++;</span><br><span class="line">        q = n/p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出phi</span></span><br><span class="line">        phi = (p - <span class="number">1</span>)*(q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求逆元</span></span><br><span class="line">        d = <span class="built_in">mod_reverse</span>(e, phi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//w = c^d mod n</span></span><br><span class="line">        w = <span class="built_in">qucik_power_mod</span>(c, d, n);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码会超时$50\%$的测试点。下面利用中国剩余定理优化。<br>$w\equiv c^d\ mod \ n$等价于方程组：<br>$\begin{cases} w \equiv c^d\ mod p\\w \equiv c^d\ mod q\end{cases}$<br>根据费马小定理：$c^d\ mod\ p = c^{d\ mod(p-1)}\ mod\ p =c_1$,<br>$c^d\ mod\ q = c^{d\ mod(q-1)}\ mod\ q=c_2$<br>记$t_1 = q^{-1}mod\ p, t_2 = p^{-1}mod\ q$，那么<br>$w = [ q(t_1  c_1\mod p)\mod n +p(t_2 c_2\mod q)\mod n]\mod n$<br><div class="note info"><p>证明：记$w = Ap + Bq$, 因为$w&lt; n$, 所以$A &lt; q, B &lt; p$.<br>$\because w\equiv Bq\mod p$, 所以$B\equiv wp^{-1}\mod q$,所以$B=wp^{-1}\mod q$, 同理，$A=wq^{-1}\mod p$<br>$\therefore w = [(wq^{-1}\mod p)\times p + (wp^{-1}\mod q)\times q ]\mod n$</p></div><br>$code_2$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">LL n, c, w, p, q, d;</span><br><span class="line"><span class="keyword">const</span> LL e = <span class="number">1073741827</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">LL <span class="title">Fast_MUl</span><span class="params">(LL a, LL b, LL mod)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    LL base = a%mod;</span><br><span class="line">    <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1LL</span> != <span class="number">0</span>) </span><br><span class="line">            res = (res*base)%mod;</span><br><span class="line">        base = (base*base)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;y = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line">y -= (a/b) * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mod_reverse</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,n,x,y);</span><br><span class="line">    x = ((x%n) + n)%n;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">        q = (LL)<span class="built_in">sqrtl</span>((<span class="keyword">long</span> <span class="keyword">double</span>)n);</span><br><span class="line">        <span class="keyword">while</span> (n%q != <span class="number">0</span>) q++;</span><br><span class="line">        p = n/q; <span class="comment">//找到p, q</span></span><br><span class="line"></span><br><span class="line">        LL phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>);</span><br><span class="line">        d = <span class="built_in">mod_reverse</span>(e, phi);<span class="comment">//获得逆元</span></span><br><span class="line">        </span><br><span class="line">        LL c1 = <span class="built_in">Fast_MUl</span>(c, d%(p<span class="number">-1</span>), p);</span><br><span class="line">        LL c2 = <span class="built_in">Fast_MUl</span>(c, d%(q<span class="number">-1</span>), q);</span><br><span class="line"></span><br><span class="line">        LL t1 = <span class="built_in">Fast_MUl</span>(q, p<span class="number">-2</span>, p);</span><br><span class="line">        LL t2 = <span class="built_in">Fast_MUl</span>(p, q<span class="number">-2</span>, q);</span><br><span class="line"></span><br><span class="line">        w = ((c1*t1)%p*q%n + (c2*t2)%q*p%n)%n;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-可以看见的点"><a href="#B-可以看见的点" class="headerlink" title="B. 可以看见的点"></a>B. 可以看见的点</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>题目描述:<br>给你一个$n \times n$的网格，任意一点和$(0,0)$连线，可以组成一条直线，前面的点可以挡住后面的点，问你能看到的点到底有多少个？</p><p>输入格式:<br>读入一行一个数，表示$n$</p><p>输出格式:<br>输出一行一个数，表示答案</p><p>样例:<br>样例1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure></p><p>样例2<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><br>数据范围与提示:<br>$n\leq 100000$<br>题目实际上就是问在这个网格上有多少种不同的斜率</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>显然有如下事实:<br>点$(a, b)$不与其他任一点共线的充分必要条件是$gcd(a, b)$.所以这道题实际上就是求方格互质点对$(a, b)$的数目.</p><p>最暴力的做法是枚举点对,即$ans = \sum_{(a,b)}gcd(a, b)==1$,但显然会超时.</p><p>考虑方格的右半边$a &lt; b$, $ans’ = \sum_{i}\sum_{j &lt; i}gcd(j, i)==1, (1)$.<br>对于某一个固定的$i$, $\sum_{j &lt; i}gcd(j, i)==1$的含义实际上就是$\phi(i)$, 因此$(1)$可以写作$ans’ = \sum_{i}\phi(i)$。其中$\phi(i)$为欧拉函数.<br>$ans$和$ans’$的关系是$ans  =2ans’+3$.加3的原因是特殊考虑斜率为1, 斜率为0(方格的下边界), 斜率为无穷(方格的左边界)的三条直线.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> is_prime[N];</span><br><span class="line">ll phi[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">phi[i] = i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">phi[i] -= <span class="number">1</span>; <span class="comment">//对于质数：phi(n) = n - 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) &#123;</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//对于非质数，根据欧拉函数的公式求算欧拉函数的值</span></span><br><span class="line">phi[j] = phi[j] * (i - <span class="number">1</span>) / i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)ans += phi[i];</span><br><span class="line">ans = ans*<span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note info"><p>以上的做法的埃式筛求$\phi(i)$。实际上我们还可以利用线性筛求$\phi(i)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, prime[N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[N];</span><br><span class="line">ll phi[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">phi[i] = i - <span class="number">1</span>; <span class="comment">//对于质数：phi(n) = n - 1</span></span><br><span class="line">prime[++cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">is_prime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] != <span class="number">0</span>) phi[i * prime[j]] = phi[i] * phi[prime[j]]; <span class="comment">//欧拉函数的积性性质</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j]; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)ans += phi[i];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="number">2</span> * ans + <span class="number">3</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><h2 id="C-POWERMOD"><a href="#C-POWERMOD" class="headerlink" title="C. POWERMOD"></a>C. POWERMOD</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>题目描述<br>在Miller-Rabin算法中需要计算$powermod(a, b, m) = a^b\ mod\ m$，请你实现这个函数</p><p>输入格式<br>输入一行三个数 $a,b,m$</p><p>输出格式<br>输出一行一个数，即$a^b\ mod\ m$</p><p>样例<br>样例输入1<br><code>2 10 1000</code><br>样例输出1<br><code>24</code><br>数据范围与提示<br>对100%的数据，$1 \le a \le 10^{18}, 0 \le b \le 10^{18}, 1 \le m \le 10^{18}$<br>注意$m$的范围，考虑从快速幂变成快速乘</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll a, b, mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求算(x * y)%mod</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_mul_mod</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = (ret + x)%mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = (x + x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿造快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_power_mod</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = <span class="built_in">qucik_mul_mod</span>(ans, a); <span class="comment">//ans = (ans * a)%mod;</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        a = <span class="built_in">qucik_mul_mod</span>(a, a); <span class="comment">//a = (a * a)%mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">qucik_power_mod</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第10次OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.3(1)</title>
      <link href="/2021/11/06/PA3-3/"/>
      <url>/2021/11/06/PA3-3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="$(1)$文件系统"></a>$(1)$文件系统</h2><div class="note primary"><p>需要阅读的重要文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.h <span class="comment">//自行添加fs_XXX函数声明</span></span><br><span class="line">fs.c <span class="comment">//特别是结构体Finfo和file_table，在这个文件我们需要添加各种fs_XXX函数实体</span></span><br><span class="line">files.h</span><br></pre></td></tr></table></figure></p></div><span id="more"></span><h3 id="1-1-loader-c"><a href="#1-1-loader-c" class="headerlink" title="$(1.1)loader.c$"></a>$(1.1)loader.c$</h3><p>在<code>loader.c</code>将<code>fs.h</code>包含进来，将<code>fs_XXX</code>函数声明放在<code>fs.h</code>里面。<br>$Pa3.3$的$ramdisk.img$不再向之前一样只是包含一个可执行文件，因此<code>loader.c</code>需要跟<code>fs_XXX</code>协作完成在$Pa3.2$里面做的事情——将指定文件的segment加载到内存空间。<br>流程图：<br><img src="/2021/11/06/PA3-3/5.png" alt><br>有关载入$segment$和系统调用的问题这里<font color="red">暂时搁置</font>。<br><div class="note info"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">2</span> <span class="function">open</span></span><br><span class="line"><span class="function">The <span class="title">open</span><span class="params">()</span> system call opens the file specified by pathname.The file descriptor is used in</span></span><br><span class="line"><span class="function">subsequent system <span class="title">calls</span> <span class="params">(read(<span class="number">2</span>), write(<span class="number">2</span>), lseek(<span class="number">2</span>), fcntl(<span class="number">2</span>),etc.)</span> to refer to the open file.</span></span><br></pre></td></tr></table></figure><p>由此可见open()函数就是为后续文件的读写操作做铺垫。<br>返回值：成功则返回文件描述符，失败则返回-1,在$Pa$里，你可以用<code>assert</code>处理失败的情况。<br>总而言之，<code>fs_open()</code>做的事情就是在<code>file_table</code>里面进行检索。</p></div></p><h3 id="1-2-open-offset"><a href="#1-2-open-offset" class="headerlink" title="$(1.2)open_{-}offset$"></a>$(1.2)open_{-}offset$</h3><p>将<code>open_offset</code>添加到<code>Finfo</code>结构体里。在$Pa$里，<code>open_offset</code>是每一个文件的属性，用来指示当前的读取开始位置相对于文件起始位置的偏移量。<code>fs_open</code>函数调用的时候，该值被初始化为 0。</p><h3 id="1-3-lseek"><a href="#1-3-lseek" class="headerlink" title="$(1.3)lseek$:"></a>$(1.3)lseek$:</h3><div class="note warning"><p><code>size_t lseek(int fd, size_t offset, int whence);</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">man lseek</span></span><br><span class="line"><span class="function"><span class="title">lseek</span><span class="params">()</span> repositions the file offset of the open file description</span></span><br><span class="line"><span class="function">       associated with the file descriptor fd to the argument offset</span></span><br><span class="line"><span class="function">       according to the directive whence as follows:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_SET</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to offset bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_CUR</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to its current location plus offset </span></span><br><span class="line"><span class="function">              bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_END</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to the size of the file plus offset</span></span><br><span class="line"><span class="function">              bytes.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><br><code>fs_lseek</code>所需要做的就是根据<code>whence</code>的值分分以上三种情况对<code>file_table[fd].open_offset</code> 进行修改。后面会对<code>loader.c</code>如何使用<code>fs_lseek</code>进行说明</p></div><h3 id="1-4-read"><a href="#1-4-read" class="headerlink" title="$(1.4)read$:"></a>$(1.4)read$:</h3><p><code>size_t read(int fd, void *buf, size_t len);</code><br><div class="note warning"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">man read</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> attempts to read up to count bytes from file descriptor fd</span></span><br><span class="line"><span class="function">       into the buffer starting at buf.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       On files that support seeking, the read operation commences at</span></span><br><span class="line"><span class="function">       the file offset, <span class="keyword">and</span> the file offset is incremented by the number</span></span><br><span class="line"><span class="function">       of bytes read.  If the file offset is at <span class="keyword">or</span> past the end of file,</span></span><br><span class="line"><span class="function">       no bytes are read, <span class="keyword">and</span> <span class="title">read</span><span class="params">()</span> returns zero.</span></span><br></pre></td></tr></table></figure><p>根据这个描述，<code>fs_read</code>在完成读取任务之后(即调用<code>ramdisk_read</code>)还需要修改<code>open_offset</code>，并且还需要进行一定的错误判断。请仔细阅读<code>read</code>的返回值说明。<code>fs_write</code>和<code>fs_read</code>类似，只是<code>fs_write</code>不需要修改<code>open_offset</code>。</p></div><br>回到<code>loader.c</code>的<code>segment</code>的加载问题，<code>fs_lseek</code>和<code>fs_read</code>在<code>loader.c</code>的具体工作如下：</p><ul><li><code>fs_lseek()</code>将<code>open_offset</code>设置为<code>ph[i]</code>的开始位置：<br><code>fs_lseek(fd, ph[i].p_offset, SEEK_SET);</code></li><li><code>fs_read()</code>将第$i$个$segment$加载：<br><code>fs_read(fd,(void *)ph[i].p_vaddr, ph[i].p_memsz);</code></li><li>最后不要忘记将必要的内存空间清 0。(未初始化的全局变量为 0 )</li></ul><div class="note success"><p>前面将了这么多，所做的事情跟$Pa3.2$并无本质区别，甚至连加载方式都如出一辙。<br>修改<code>pro.c</code>的<code>init_proc()</code>，调用<code>naive_uload(NULL, &quot;/bin/hello&quot;);</code>， 如果运行效果跟$Pa3.2$的一样，那么说明你加载成功了。你也可以试试加载<code>dummy</code>.</p></div><h2 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="$(2)$系统调用"></a>$(2)$系统调用</h2><p>待更新</p><h2 id="3-IOE"><a href="#3-IOE" class="headerlink" title="$(3)IOE$"></a>$(3)IOE$</h2><h3 id="3-1-serial"><a href="#3-1-serial" class="headerlink" title="$(3.1)serial$"></a>$(3.1)serial$</h3><p>在将串口抽象为文件之前，<code>SYS_write</code>将<code>stdout</code>和<code>stderr</code>和其他文件区别对待。<br>之前：<br><img src="/2021/11/06/PA3-3/h6.png" alt><br>现在：<br><img src="/2021/11/06/PA3-3/h7.png" alt></p><p>这样的话，$fs_{-}write$需要添加如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fd == FD_STDIN || fd == FD_STDOUT || fd == FD_STDERR)&#123;</span><br><span class="line">      <span class="keyword">return</span> file_table[fd].write(buf, <span class="number">0</span>, len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>在<code>file_table</code>里面将<code>FD_STDOUT ，FD_STDERR</code>的<code>invalid_write</code>改为<code>serial_write</code>。至于<code>serial_write</code>的实现，直接使用<code>putch</code>就可以。</p><h3 id="3-2-gettimeofday"><a href="#3-2-gettimeofday" class="headerlink" title="$(3.2)gettimeofday$"></a>$(3.2)gettimeofday$</h3><p>还记得在$Pa2.3$应用程序是怎么获取时间的吗？$am_{-}test$里的$rtc.c$作为基于$AM$运行的应用程序，它获得$update-time$的方式自然是通过$AM$提供的接口$io_{-}read$, $OS$是基于$AM$的特殊的程序，它获取$update-time$的方式跟$rtc.c$是一样的。</p><div class="note primary"><p><code>man gettimeofday</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *<span class="keyword">restrict</span> tv, struct timezone *<span class="keyword">restrict</span> tz)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">               <span class="keyword">time_t</span>      tv_sec;     <span class="comment">/* seconds*/</span></span><br><span class="line">               <span class="keyword">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">           &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">               <span class="keyword">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>返回值：成功为0, 失败为-1。<br>在<code>nanos-lite/../syscall.c</code>定义上述两个结构体，其中的<code>time_t,suseconds_t</code>直接用<code>long</code>代替。<br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SYS_gettimeofday</span><span class="params">(timeval *tv, timezone* tz)</span> </span>&#123;</span><br><span class="line">       tv-&gt;tv_usec = io_read(AM_TIMER_UPTIME).us; <span class="comment">//这样看来跟rtc.c是一样的嘛！！</span></span><br><span class="line">       tv-&gt;tv_sec = tv-&gt;tv_usec / <span class="number">1000000</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><p>增加测试<code>time-test</code>?, 如何写测试代码，这里就不再赘述了，值得一提的是，类似于<code>file-test</code>,我们也需要在<code>Makefile</code>里添加<code>time-test</code>，这样子<code>make update</code>之后<code>files.h</code>就会多出<code>time-test</code>， 接着<code>naive_uload(NULL, &quot;/bin/time-test&quot;);</code>就可以了。<br><div class="note info"><p><code>uint32_t NDL_GetTicks();</code><br>在<code>NDL.c</code>添加<code>gettimeofday</code>的头文件<code>sys/time.h</code>，至于<code>NDL_GetTicks()</code>，这是很简单的事情。<br>使用<code>time-test</code>测试<code>NDL_GetTicks</code>的时候，除了<code>main.c</code>添加<code>NDL.h</code>,还要记得在<code>Makefile</code>里面添加<code>LIBS = libndl</code>。(请参考<code>event-test</code>的文件组织结构)</p></div></p><h3 id="3-3-key-event"><a href="#3-3-key-event" class="headerlink" title="$(3.3)key_{-}event$"></a>$(3.3)key_{-}event$</h3><p>请仔细阅读$am_{-}test$里面的<code>keyboard.c</code>。<br>在具体编写代码之前，让我们先来梳理一下<code>event-test</code>里的<code>NDL_PollEvent(char *buf, int len);</code>的大概调用过程:<br><img src="/2021/11/06/PA3-3/7.png" alt><br><div class="note primary"><p>又是$io_{-}read$?<br>是的，还是之前那句话，$OS$作为基于$AM$的特殊的应用程序，跟设备打交道还是要通过<br>$io_{-}read|write$。<br>上面的调用过程不完全准确，在<code>read</code>之前，我们需要通过<code>open(&quot;/dev/events&quot;)</code>获得<code>file descriptor</code>。</p></div><br><div class="note info"><ul><li>实现层级1：<br>首先在<code>NDL.c</code>的<code>NDL_PollEvent</code>调用<code>open</code>函数，获得<code>file descriptor</code>, 接着调用<code>read(fd, buf, len)</code>, 根据<code>read</code>的返回值是否为0确定<code>NDL_PollEvent</code>的返回值为0或者1.<br>$remark:NDL.c$需要添加<code>open</code>的头文件<code>fcntl.h</code>。(这一点是通过<code>man 2 open</code>获知的)</li><li>实现层级2：<br>在<code>file_table</code>添加<code>{&quot;/dev/events&quot;, 0, 0, events_read, invalid_write}</code>，注意到读取函数句柄为<code>events_read</code>;<br>区别于普通文件没有读写指针，在<code>fs_read</code>需要判断当文件的的读指针不为空时，直接调用该函数的读指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file_table[fd].read != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> file_table[fd].read(buf, <span class="number">0</span>, len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>这样的话，上述流程图就差<code>events_read</code>的实现了。请参考$am_{-}test$里面的<code>keyboard.c</code>，自行实现<code>events_read</code>。</li><li>实现效果：<br><img src="/2021/11/06/PA3-3/8.png" alt="图一" style="zoom:100%;"></li></ul></div></p><h3 id="3-4-vga"><a href="#3-4-vga" class="headerlink" title="$(3.4)vga$"></a>$(3.4)vga$</h3><div class="note info"><p>不要一上来就敲代码？！<br>首先让我们先来梳理一下大概的测试流程：<br><code>void *bmp = BMP_Load(&quot;/share/pictures/projectn.bmp&quot;, &amp;w, &amp;h);</code>将图片的长度和宽度存入<code>w, h</code>, 并且将图片相关的像素信息按照行优先的顺序存储在bmp所指向的连续的内存空间。<br>之后<code>NDL_OpenCanvas(&amp;w, &amp;h);</code>打开画布，在该函数我们获得了系统屏幕的长宽.<br>再接下来<code>NDL_DrawRect(bmp, 0, 0, w, h);</code>， 这里0,0代表的是图片的左上角是系统屏幕的原点， 该函数需要将<code>bmp</code>的像素信息写入指定位置。</p></div><h4 id="3-4-1-NDL-OpenCanvas"><a href="#3-4-1-NDL-OpenCanvas" class="headerlink" title="$(3.4.1)NDL_{-}OpenCanvas$"></a>$(3.4.1)NDL_{-}OpenCanvas$</h4><p>暂时忽略<code>if (getenv(&quot;NWM_APP&quot;))</code>分支，我们需要填充的内容写在<code>else</code>分支里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/dispinfo&quot;</span>,<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 获得文件描述符</span></span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span> (buf)); <span class="comment">//读取屏幕信息</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH:%d\nHEIGHT:%d&quot;</span>, &amp;screen_w, &amp;screen_h);  <span class="comment">// 获取系统屏幕大小</span></span><br></pre></td></tr></table></figure><br><div class="note primary"><p><code>open</code>的流程：<br><img src="/2021/11/06/PA3-3/10.png" alt><br><code>read</code>的流程：<br><img src="/2021/11/06/PA3-3/11.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispinfo_read</span></span><br><span class="line"><span class="keyword">int</span> wid = io_read(AM_GPU_CONFIG).width;</span><br><span class="line"><span class="keyword">int</span> height = io_read(AM_GPU_CONFIG).height;  </span><br><span class="line"><span class="built_in">sprintf</span>((<span class="keyword">char</span>*)buf, <span class="string">&quot;WIDTH:%d\nHEIGHT:%d&quot;</span>, wid, height); <span class="comment">// 按照格式转化为字符串</span></span><br></pre></td></tr></table></figure></div></p><h4 id="3-4-2-NDL-DrawRect"><a href="#3-4-2-NDL-DrawRect" class="headerlink" title="$(3.4.2)NDL_{-}DrawRect$"></a>$(3.4.2)NDL_{-}DrawRect$</h4><p>像素信息按行优先排列：<br><img src="/2021/11/06/PA3-3/12.png" alt></p><p><font color="read">$Hope:$每次写入一行像素信息</font><br>这里先贴出$code$,再逐一解释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NDL_DrawRect</span></span><br><span class="line">fbdev = open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// to get the file descriptor</span></span><br><span class="line"><span class="comment">// part(1)</span></span><br><span class="line"><span class="keyword">uint32_t</span> fb[screen_h][screen_w];</span><br><span class="line">  <span class="comment">// 注意是行优先</span></span><br><span class="line"><span class="comment">// to rearrage the storing structure</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j ++)</span><br><span class="line">            fb[i][j] = pixels[i * h + j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// part(2)</span></span><br><span class="line"><span class="comment">// 每次画一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fbdev, (x &lt;&lt; <span class="number">16</span>) | (y + i) , SEEK_SET); </span><br><span class="line">    write(fbdev, fb[i] , draw_w);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>$part(1)$是不难理解的：因为$pixels$是一维数组，为了方便使用，第一部分将像素信息按照行优先存储在一个二维数组当中。$fb[i]$存储的就是第$i$行的像素信息。<br><div class="note warning"><p>$part(2)$：<br><code>lseek(fbdev, (x &lt;&lt; 16) | (y + i) , SEEK_SET);</code>的作用就是为<code>write</code>做铺垫，告诉<code>write</code>渲染的起点位置，也就是这一行要从那个位置“画”起。<br><!-- ![]() --></p><p>我们希望<code>write</code>在得到<code>offset</code>之后能够唯一确定$start_{-}x, start_{-}y$, 这其实就是一一映射!<font color="red"> 映射的方法有很多种</font>，这里采用的是将高16位映射为$start_{-}x$, 低16位映射为$start_{-}y$。<br>映射方式自然决定了<code>init_fs</code>的写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_fs</span></span><br><span class="line"><span class="keyword">int</span> wid = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">screen_wh(&amp;wid, &amp;height); <span class="comment">// 自行定义</span></span><br><span class="line"><span class="keyword">int</span> fbdev = fs_open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">file_table[fbdev].size = (wid &lt;&lt; <span class="number">16</span>)|height;</span><br></pre></td></tr></table></figure><br>至于<code>fb_write</code>，无非就是调用<code>io_write</code>，具体可以参考<code>am-test</code>里的<code>video.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fb_write</span></span><br><span class="line"><span class="keyword">uint32_t</span> *pixels = (<span class="keyword">uint32_t</span>*)buf;</span><br><span class="line"><span class="keyword">int</span> start_x = offset &gt;&gt; <span class="number">16</span>, start_y = offset &amp; <span class="number">0x0000ffff</span>; <span class="comment">// 将映射解析</span></span><br><span class="line">io_write(AM_GPU_FBDRAW, start_x, start_y , pixels, len, <span class="number">1</span>, <span class="literal">true</span>); <span class="comment">//写入一行的像素信息</span></span><br><span class="line"><span class="keyword">return</span> len;</span><br></pre></td></tr></table></figure></p></div></p><div class="note success"><p>流程图：<br><img src="/2021/11/06/PA3-3/13.png" alt="图一" style="zoom:75%;"><br><img src="/2021/11/06/PA3-3/14.png" alt="图一" style="zoom:75%;"><br>实现效果图：<br><img src="/2021/11/06/PA3-3/15.png" alt="图一" style="zoom:75%;"></p></div><div class="note warning"><p>后面我们会讲到，上面的$vga$实现是不兼容的——与$navy_{-}app$的$native$不兼容，因为$native$的映射法则与上面定义的不同。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-碎碎念"><a href="#1-碎碎念" class="headerlink" title="$(1)$碎碎念"></a>$(1)$碎碎念</h3><p>在阅读讲义的时候，看到关键的句子一定要及时摘抄下来（留一点印象），阅读代码的时候也可以将讲义中的关键语句作为注释添加在代码中。</p><h3 id="2-native"><a href="#2-native" class="headerlink" title="$(2)native$"></a>$(2)native$</h3><p>学会使用$native$进行架构无关的测试。</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.2</title>
      <link href="/2021/11/06/PA3-2/"/>
      <url>/2021/11/06/PA3-2/</url>
      
        <content type="html"><![CDATA[<p>程序的执行视图<br><img src="/2021/11/06/PA3-2/2.png" alt="图一" style="zoom:60%;"><br>remark:来自袁老师的课件。<br><span id="more"></span></p><h2 id="1-dummy"><a href="#1-dummy" class="headerlink" title="$(1)dummy$"></a>$(1)dummy$</h2><h3 id="1-1-Elf-Ehdr"><a href="#1-1-Elf-Ehdr" class="headerlink" title="$(1.1)Elf_{-}Ehdr$"></a>$(1.1)Elf_{-}Ehdr$</h3><p>终端执行<code>readelf -lh ramdisk.img</code>得到如下信息:<br><img src="/2021/11/06/PA3-2/1.png" alt="图一" style="zoom:80%;"><br><code>elf header</code>的$Entry\ point\ address$:<font color="red">程序执行入口</font><br>以及程序表头的数目等都是比较重要的信息.<br><div class="note primary"><p>使用<code>loader.c</code>前面宏定义的<code>Elf_Ehdr</code>可以将$ramdisk.img$里的程序表头读入:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elf_Ehdr eh;</span><br><span class="line">ramdisk_read(&amp;eh, <span class="number">0</span>, <span class="keyword">sizeof</span>(eh));</span><br></pre></td></tr></table></figure><br>注意这里并没有向物理地址写入指令,我们只是在$ramdisk.img$获取了一点必要的信息.</p><p><font color="red">请仔细阅读$elf.h$的<code>Elf32_Ehdr</code>和<code>Elf32_Phdr</code>两个结构体.</font><br>在获取了<code>Elf_Ehdr</code>的信息之后:<br><code>eh.e_entry</code>可以作为我们$loader.c$作为程序开始执行的地址返回给<code>naive_uload</code>;<br><code>eh.e_phentsize</code>是每一个$program\ header$的大小;<br><code>eh.e_phnum</code>是$program\ header$的数目;<br>还可以通过<code>assert(*(uint32_t *)eh.e_ident == 0x464c457f);</code>对魔数进行识别.</p></div><br><div class="note info"><p>$tips$:<br>在<code>~/.bashrc</code>里面配置环境变量:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=riscv32-nemu</span><br><span class="line">export ISA=riscv32</span><br></pre></td></tr></table></figure><br>如果要用<code>native</code>,那么则需要显式指出,否则终端直接执行<code>make</code>或者<code>make run</code>就可以了.</p></div></p><h3 id="1-2-Elf-Phdr"><a href="#1-2-Elf-Phdr" class="headerlink" title="$(1.2)Elf_{-}Phdr$"></a>$(1.2)Elf_{-}Phdr$</h3><p>好了,现在考虑怎么向物理地址载入$segment$.<br>前面我们提到了<code>e_phnum</code>,根据该值, 定义<code>Elf_Phdr ph[eh.e_phnum];</code></p><p>对于$ph[i]$, 通过<code>ramdisk_read(&amp;ph[i], eh.e_phoff + i*(eh.e_phentsize), eh.e_phentsize);</code>读取第$i$个<code>segment</code>的信息.(<font color="red">注意这里我们依旧没有向物理地址载入$segment$,我们只是获取了该$segment$的信息</font>)<br>根据$ph[i].p_{-}type$是否等于<code>PT_LOAD</code>决定是否加载.<br>如果需要加载:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ramdisk_read((<span class="keyword">void</span> *)ph[i].p_vaddr, ph[i].p_offset, ph[i].p_filesz); <span class="comment">//真正向&quot;物理地址&quot;载入segment</span></span><br><span class="line"><span class="comment">// ph[i].p_offset 代表该segment在文件中的偏移</span></span><br><span class="line"><span class="comment">// ph[i].p_filesz 代表写入的大小</span></span><br></pre></td></tr></table></figure><br>加载$segment$之后，返回$en.e_{-}entry$就可以了。<br>最后不要忘了在<code>void init_proc()</code>里调用<code>naive_uload(NULL, NULL);</code><br><div class="note warning"><p>$dummy$里面有两个需要加载的$segment$,一个是$.text, .rodata$，即只读代码段; 另一个是$.data$等的，即可读写数据段，第二个段的$memsize &gt; filesize$是因为：$.bss$节中的未初始化的全局变量在目标文件不占据磁盘空间，但是在加载到内存的时候则需要给它们分配空间。</p></div></p><h2 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="(2)系统调用"></a>(2)系统调用</h2><div class="note info"><p>需要阅读的重要文件:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navy-apps/libs/libos/src/syscall.c</span><br><span class="line">abstract-machine/am/src/nemu/isa/$ISA/cte.c</span><br><span class="line">nanos-lite/src/irq.c</span><br><span class="line">nanos-lite/src/syscall.c</span><br></pre></td></tr></table></figure></p></div><p>$Pa3.1$对$yield$事件分发的时候，我们提到需要在<code>__am_irq_handle</code>里面根据<code>c-&gt;GPR1</code>判断，如果等于-1的话，那么event识别为$yield$.<br>当<code>c-&gt;GPR1 != -1</code>时，我们暂时将其识别为$syscall$.所以<code>__am_irq_handle</code>里面需要作出修改。</p><p><code>__am_irq_handle</code>接下来会跳转到$irq.c$里面的$do_{-}event$函数，case分支添加$EVENT_{-}SYSCALL$，然后调用$do_{-}syscall()$</p><h3 id="2-1-nanos-lite-src-syscall-c"><a href="#2-1-nanos-lite-src-syscall-c" class="headerlink" title="$(2.1)nanos-lite/src/syscall.c$"></a>$(2.1)nanos-lite/src/syscall.c$</h3><p>请自行添加<code>SYS_exit()</code>和<code>SYS_yield</code>函数，并通过设置<code>c-&gt;GPRx</code>作为返回值。</p><h3 id="2-2-strace"><a href="#2-2-strace" class="headerlink" title="$(2.2)strace$"></a>$(2.2)strace$</h3><p>在<code>nanos-lite/src/syscall.c</code>调用$Log$函数，根据你的需求使用。</p><h3 id="2-3-write"><a href="#2-3-write" class="headerlink" title="$(2.3)write$"></a>$(2.3)write$</h3><p>请仔细阅读<code>man 2 write</code>的内容，重点关注函数的参数以及返回值。</p><p><code>navy-apps/libs/libos/src/syscall.c</code>的<code>_write</code>添加：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> _syscall_(SYS_write, fd, (<span class="keyword">intptr_t</span>)buf, count);</span><br></pre></td></tr></table></figure><br><div class="note primary"><p>请在<code>nanos-lite/src/syscall.c</code>添加<code>SYS_write</code>函数，并且通过case分支调用该函数，调用该函数的参数为$a[1], a[2], a[3]$即<code>c-&gt;GPR2, c-&gt;GPR3, c-&gt;GPR4</code>.返回值存储在<code>c-&gt;GPRx</code>里面(<code>c-&gt;GPRx = SYS_{-}write(...)</code>)</p><p>code:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERROR 2</span></span><br><span class="line"><span class="keyword">if</span>(fd == STDOUT || fd == STDERROR) &#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Stdin or Stdout&quot;); //trace for stdin or stdout</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = buf; i &lt; count; i++, p++) putch(*p);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></div></p><h3 id="2-4-sbrk"><a href="#2-4-sbrk" class="headerlink" title="$(2.4)sbrk$"></a>$(2.4)sbrk$</h3><p>待更新</p><h2 id="3-hello-的执行流程"><a href="#3-hello-的执行流程" class="headerlink" title="$(3)hello$的执行流程"></a>$(3)hello$的执行流程</h2><p><img src="/2021/11/06/PA3-2/3.png" alt><br>至于后面的<code>printf</code>也是类似的道理，只不过多考虑了<code>sbrk</code>。</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.1</title>
      <link href="/2021/11/06/PA3-1/"/>
      <url>/2021/11/06/PA3-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSR-寄存器"><a href="#1-CSR-寄存器" class="headerlink" title="$(1)CSR$寄存器"></a>$(1)CSR$寄存器</h3><p><code>isa-def.h</code>的<code>CPU_STATE</code>结构体对应了状态机的一部分:通用寄存器$(general\ purpose\ register)$和$pc$. <font color="red">对状态进行扩充,实际上就是添加系统寄存器$SR$</font><br>在<code>riscv32_CPU_state</code>添加:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">rtlreg_t</span> _csr;</span><br><span class="line"> &#125; sysr[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><br>规定: $sysr[0…3]$依次存储$mepc, mstatus, mcause, mtvec$<br><span id="more"></span></p><h3 id="2-cte-init"><a href="#2-cte-init" class="headerlink" title="$(2)cte_{-}init$"></a>$(2)cte_{-}init$</h3><p><img src="/2021/11/06/PA3-1/g.png" alt="图一" style="zoom:90%;"><br>上图是初始化$CTE$的过程.$cte.c$主要有以下两个任务:</p><ul><li><code>asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot;(__am_asm_trap));</code>将异常入口地址写入$mtvec$</li><li>注册回调函数</li></ul><p>$csrw$指令需要我们自己实现,查看<code>nanos-lite-riscv32-nemu.txt</code>的$cte_{-}init$部分的汇编代码, <code>csrw    mtvec,a5</code>的汇编代码是<code>30579073(16进制)</code>,查阅手册得知,高12位$0x305$实际上是mtvec对应的编号. <font color="red">添加好译码匹配规则之后</font>, $pseudo.h$里面添加如下代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec_csr 0x305 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(csrrw, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> csr)</span></span>&#123;</span><br><span class="line"><span class="comment">// 根据高12位立即数 csr 判断是哪个系统寄存器, 然后写入信息</span></span><br><span class="line">    <span class="keyword">if</span>(csr == mtvec_csr) mtvec = *src1;</span><br><span class="line">    TODO();<span class="comment">//添加其他系统寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note info"><p>$Q1:$为什么<code>&quot;r&quot;(__am_asm_trap)</code>可以将异常处理入口写入$mtvec$?<br>实际上,<code>__am_asm_trap</code>是一个函数,也是一个指针,存放的就是函数的入口地址.<br>$Q2:$<code>__am_asm_trap</code>的地址在哪?<br>查看<code>nanos-lite-riscv32-nemu.txt</code>可以知道其地址是:$0x80000730$(这个数字未必是定值,具体看情况). 通过$csrw$指令,<code>cte.c</code>做的第一件事情就是将该值写入$mtvec$寄存器.</p></div><div class="note warning"><p>更多的细节?!<br>查看<code>cte_init</code>的汇编代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">800007b7         lui a5,0x80000</span><br><span class="line">73078793         addi  a5,a5,1840 # 80000730 &lt;_end+0xfffed730&gt;</span><br><span class="line">30579073         csrw  mtvec,a5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8000a7b7         lui a5,0x8000a</span><br><span class="line">02a7a223         sw  a0,36(a5) # 8000a024 &lt;_end+0xffff7024&gt;</span><br><span class="line"></span><br><span class="line">00100513         li  a0,1</span><br><span class="line">00008067         ret</span><br></pre></td></tr></table></figure><br>前三条指令的作用就是将异常入口地址(<code>__am_asm_trap</code>)写入寄存器$a_5$,然后将其写入mtvec；注意<code>cte.c</code>的函数参数是一个函数指针,存放在$a_0$里面,而$36(a_5)$实际上就是usr_handler的地址.<code>sw  a0,36(a5)</code>对应的就是<code>user_handler = handler;</code>, <code>8000a024 &lt;_end+0xffff7024&gt;(具体数值可能会有变动)</code>这个地址自然就是我们在cte.c初始化的全局变量的<code>static Context* (*user_handler)(Event, Context*) = NULL;</code>的地址!</p></div><h3 id="3-实现新指令"><a href="#3-实现新指令" class="headerlink" title="$(3)$实现新指令"></a>$(3)$实现新指令</h3><h4 id="3-1-ecall"><a href="#3-1-ecall" class="headerlink" title="$3.1\ ecall$"></a>$3.1\ ecall$</h4><p>$ecall$是自陷指令,通过与<code>isa_raise_intr</code>的协作,它主要完成以下工作:</p><pre><code>(1)将当前PC值保存到mepc寄存器(2)在mcause寄存器中设置异常号(3)从mtvec寄存器中取出异常入口地址(4)跳转到异常入口地址</code></pre><p>代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intr.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc cpu.sysr[0]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause cpu.sysr[2]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"><span class="function"><span class="keyword">word_t</span> <span class="title">isa_raise_intr</span><span class="params">(<span class="keyword">word_t</span> NO, <span class="keyword">vaddr_t</span> epc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mepc = epc; <span class="comment">// 将当前PC值保存到mepc寄存器</span></span><br><span class="line">  mcause = NO; <span class="comment">//在mcause寄存器中设置异常号</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mtvec; <span class="comment">//从mtvec寄存器中取出异常入口地址, 并且返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pseudo.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(ecall, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> imm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">word_t</span> Event_NO = <span class="number">11</span>; <span class="comment">// 11在手册里面可以查到</span></span><br><span class="line">  s-&gt;dnpc = isa_raise_intr(Event_NO, s-&gt;pc); <span class="comment">//跳转到异常入口地址(__am_asm_trap)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary"><p>通过以下流程图梳理一下,$ecall$的调用过程<br><img src="/2021/11/06/PA3-1/h1.png" alt></p><p>$Q$:<code>__am_asm_trap</code>在哪?它的作用是什么?<br>$A$: 在$trap.S$里面,将所有的通用寄存器和系统寄存器压栈,为<code>__am_irq_handle</code>准备好参数(后面会提到),从<code>__am_irq_handle</code>返回之后恢复上下文.</p><p>$Q$:yiled在调用ecall之前将-1加载到$a_7$。这是为什么呢？<br>答：$ecall$指令主要用户程序向运行环境(OS)发出请求，具体的请求类别需要传递参数，$a_7$就是这个参数存放的地方。</p><p><a href="https://www.youtube.com/watch?v=UPHEkz_rHTY">https://www.youtube.com/watch?v=UPHEkz_rHTY</a></p></div></p><h4 id="3-2-csrr"><a href="#3-2-csrr" class="headerlink" title="$3.2\ csrr$"></a>$3.2\ csrr$</h4><p>跳转到<code>__am_asm_trap</code>之后.查看反汇编代码, <code>__am_asm_trap</code>做的事情就是将32个通用寄存器保存($sw$指令), 同时将$mepc$等存储到寄存器里面($csrr$指令), 接着跳转到<code>__am_irq_handle</code>处理函数.<br><code>pseudo.h</code>里面添加:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc cpu.sysr[0]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mstatus cpu.sysr[1]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause cpu.sysr[2]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// csr寄存器在指令当中体现为编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc_csr 0x341</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mstatus_csr 0x300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause_csr 0x342</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec_csr 0x305</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(csrr, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> csr)</span></span>&#123;</span><br><span class="line"><span class="comment">// 将csr寄存器信息写入目的寄存器</span></span><br><span class="line">    <span class="keyword">if</span>(csr == mepc_csr)*dest = mepc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(csr == mstatus_csr)*dest = mstatus;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(csr == mcause_csr)*dest = mcause;</span><br><span class="line">    <span class="keyword">else</span> panic(<span class="string">&quot;No such System Register!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-mret"><a href="#3-3-mret" class="headerlink" title="$3.3\ mret$"></a>$3.3\ mret$</h4><p>好了,现在我们已经跳转到<code>__am_irq_handle</code>函数了.在实现$mret$之前,先对函数行为进行分析.</p><div class="note info"><p><code>__am_irq_handle</code>的函数参数来自哪里??<br>$A:$答案就在<code>__am_asm_trap</code>的汇编代码中.<br><code>__am_irq_handle</code>的参数是$Context$指针,一个$Context$结构体应该包括32个寄存器和3个csr寄存器(这里先不管剩下的), <font color="red">由寄存器$a_0$传入, $a_0$存储的就是$context$的首地址</font>, 前面已经讲了<code>__am_asm_trap</code>将32个寄存器等压栈,形成一个124字节的栈, 在跳转到<code>__am_irq_handle</code>之前,<code>mv  a0,sp</code>的作用就是将$sp$的内容写入$a_0$,使得$a_0$能够指向结构体的首地址. <font color="green">所以参数是由<code>__am_asm_trap</code>准备好的!</font></p></div><p>接下来,我们对<code>__am_irq_handle</code>的汇编代码的一部分进行分析:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">8000067c &lt;__am_irq_handle&gt;:</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line">8000a024 : 全局变量usr_handlerd的地址,存储了do_event的入口地址, 写入a5</span><br><span class="line">8000067c: 8000a7b7            lui a5,0x8000a </span><br><span class="line">80000680: 0247a783            lw  a5,36(a5) # 8000a024 &lt;_end+0xffff7024&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">80000684: 00050593            mv  a1,a0</span><br><span class="line">80000688: 04078e63            beqz  a5,800006e4 </span><br><span class="line">判断handler是否为空</span><br><span class="line">&lt;__am_irq_handle+0x68&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">8000068c: 08052703            lw  a4,128(a0)</span><br><span class="line">注意这里的128(a0)是mcause,请自己思考原因</span><br><span class="line">---------------------------------------</span><br><span class="line">80000690: fd010113            addi  sp,sp,-48</span><br><span class="line">80000694: 02112623            sw  ra,44(sp)</span><br><span class="line">80000698: 00012a23            sw  zero,20(sp)</span><br><span class="line">8000069c: 00012c23            sw  zero,24(sp)</span><br><span class="line">800006a0: 00012e23            sw  zero,28(sp)</span><br><span class="line">---------------------------------------</span><br><span class="line">将a4即(mcause) 与1(EVENT_YIELD)进行比较</span><br><span class="line">800006a4: 00100693            li  a3,1</span><br><span class="line">800006a8: 00d70463            beq a4,a3,800006b0 </span><br><span class="line">&lt;__am_irq_handle+0x34&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">800006ac: 00400713            li  a4,4</span><br><span class="line">---------------------------------------</span><br><span class="line">800006b0: 00e12023            sw  a4,0(sp)</span><br><span class="line">800006b4: 01412703            lw  a4,20(sp)</span><br><span class="line">800006b8: 00010513            mv  a0,sp</span><br><span class="line">800006bc: 00e12223            sw  a4,4(sp)</span><br><span class="line">800006c0: 01812703            lw  a4,24(sp)</span><br><span class="line">800006c4: 00e12423            sw  a4,8(sp)</span><br><span class="line">800006c8: 01c12703            lw  a4,28(sp)</span><br><span class="line">800006cc: 00e12623            sw  a4,12(sp)</span><br><span class="line">800006d0: 000780e7            jalr  a5</span><br><span class="line">跳转到a5, 也就是执行usr_handler, 前面的几个指令准备了函数调用的参数</span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><br>从<code>__am_irq_handle</code>正常返回到<code>__am_asm_trap</code>之后,<code>__am_asm_trap</code>做的就是恢复上下文,并且执行$mret$指令,执行”异常指令”的下一条指令.<br>因此,mret的指令也就不难实现了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(mret, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> imm)</span></span>&#123;</span><br><span class="line">  s-&gt;dnpc = mepc + <span class="number">4</span>; <span class="comment">// 执行&quot;异常指令&quot;的下一条指令.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning"><p>上面给出的$mret$的实现<font color="red">在硬件上($nemu$)</font>将返回地址设置为$mepc+4$, 看上去并没有什么问题，在不开$difftest$的时候也能够正常运行，但根据讲义的内容，$mepc$是否加4应该由软件决定(目前的默认加4)，所以需要在$cte.c$的$do_{-}event$返回之前<code>c-&gt;mepc += 4</code>, 并且<code>mret</code>改为<code>s-&gt;dnpc = mepc;</code>.否则在开$difftest$的情况下会出现莫名的错误。</p></div><br><div class="note primary"><p>整理一下整个过程:<br><img src="/2021/11/06/PA3-1/h2.png" alt></p></div></p><h3 id="4-difftest"><a href="#4-difftest" class="headerlink" title="$(4) difftest$"></a>$(4) difftest$</h3><p>在$nemu$的<code>init.c</code>里面将$cpu.sysr[1]._{-}csr$ 的值赋为0x1800。</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab2-内联汇编</title>
      <link href="/2021/10/30/Lab2/"/>
      <url>/2021/10/30/Lab2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-asm-add"><a href="#1-asm-add" class="headerlink" title="$(1)asm_{-}add$"></a>$(1)asm_{-}add$</h3><p>“$add[q|l|w|b] \ A, \ B$”将$A+B$送至$A$.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">asm_add</span><span class="params">(<span class="keyword">int64_t</span> a, <span class="keyword">int64_t</span> b)</span> </span>&#123;</span><br><span class="line">__asm__(</span><br><span class="line"><span class="string">&quot;addq %[b], %[a]\n&quot;</span></span><br><span class="line">:[a] <span class="string">&quot;+r&quot;</span>(a)</span><br><span class="line">:[b] <span class="string">&quot;r&quot;</span>(b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-asm-popcnt"><a href="#2-asm-popcnt" class="headerlink" title="$(2)asm_{-}popcnt$"></a>$(2)asm_{-}popcnt$</h3><p>$asm_{-}popcnt(x)$的作用是计算$x$的二进制中含 $1$的数目.<br>思路比较简单,$x$不断逻辑右移直到$x = 0$, 右移$shr[q|l|w|b]$指令每次右移指定位数, 比如在这里指定$shamt=1$, <font color="red">操作数的最低位将会移动到</font>$CF$, 根据$CF==1$, 我们可以决定计数器$cnt$是否加一.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asm_popcnt</span><span class="params">(<span class="keyword">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;L1:&quot;</span></span><br><span class="line">    <span class="string">&quot;testq %[x], %[x] #判断x是否为零, 如果为零,跳转到end\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jz end\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;shrq $1, %[x] #右移1位,将最低位送到CF\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jnc not_to_cnt #如果CF为零, cnt不加1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;incl %[cnt] #cnt加1\n &quot;</span></span><br><span class="line">    <span class="string">&quot;not_to_cnt:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp L1  #跳转到L1继续进行判断\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:\n&quot;</span></span><br><span class="line">    : [x] <span class="string">&quot;+r&quot;</span>(x), [cnt] <span class="string">&quot;+r&quot;</span>(cnt)</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note info"><p>$test$指令将两个操作数相”与”,不改变原操作数,根据结果设置条件标志.比如要知道寄存器$\%eax==0$, 只需<code>testl %eax, %eax</code>, 然后再用<code>jz/jnz</code>跳转到指定的$label$<br>其它条件转移指令还有<code>jc/jnc, je/jne</code>等,可以查阅”计算机系统基础”的$Page111表3.6$</p></div><br>不少指令都会影响到$Flags$,如$add, sub, cmp,$移位指令.不同指令影响的标志位不完全一样.<br>将上面的代码的<code>testq %[x], %[x]</code>改为<code>cmpq $0, %[x]</code>具有一样的效果.也可以考虑$and$指令获取$x$的最低位.<br><div class="note default"><p>考虑用内联汇编实现$int64_{-}t \ max(int64_{-}t\ x, int64_{-}t\ y)$以及$\sum_{i=1}^{100}i$</p></div><br>$max$函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">max</span><span class="params">(<span class="keyword">int64_t</span> x, <span class="keyword">int64_t</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> gre = <span class="number">0</span>;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;cmpq %[y], %[x] # x - y并且获得标志位信息\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jge x_greater # x &gt;= y\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;movq %[y], %[gre] #y更大\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp end\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;x_greater:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %[x], %[gre]\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:\n&quot;</span></span><br><span class="line"></span><br><span class="line">    : [gre] <span class="string">&quot;=r&quot;</span>(gre)</span><br><span class="line">    : [x] <span class="string">&quot;r&quot;</span>(x), [y] <span class="string">&quot;r&quot;</span>(y)</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">return</span> gre; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>$\sum_{i=1}^{100}i$函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;movl $1, %%edx #作为变量 i \n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;l1: \n&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl $100, %%edx #跟100比较, edx - 100获得标志位\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jle l2 # edx &lt;= 100\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp end #edx &gt;100 直接结束\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;l2:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;addl %%edx, %%eax # eax += i\n&quot;</span></span><br><span class="line">    <span class="string">&quot;incl %%edx #edx += 1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp l1 #继续下一轮的判断\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(result)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-asm-memcpy"><a href="#3-asm-memcpy" class="headerlink" title="$(3)asm_{-}memcpy$"></a>$(3)asm_{-}memcpy$</h3><p>$asm_{-}memcpy$的作用是将源地址数据复制到目标地址.<br><code>void   *asm_memcpy(void *dest, const void *src, size_t n);</code></p><p>这里的$size_{-}t$指的是需要拷贝的字节数, 所以一个很自然的想法就是,用一个变量$cnt$(初始化为$n$), 每拷贝一个字节,$cnt-1$,当$cnt = 0$时,循环拷贝终止.<br><div class="note info"><p>设$byte_{-}1$的地址存放在$ESI$, $byte_{-}2$的地址存放在$EDI$<br>$movsb$的作用:将$byte_{-}2$换成$byte_{-}1$, 也即$movsb$的操作数省略可以不写,默认取$ESI(源变址寄存器), EDI(目标变址寄存器)$</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d1, d2;</span><br><span class="line">  <span class="keyword">int</span> cnt = n;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;LOOP:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl $0, %[cnt]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jz Final\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;movsb\n&quot;</span></span><br><span class="line">    <span class="string">&quot;dec %[cnt]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp LOOP\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;Final:&quot;</span></span><br><span class="line">    :<span class="string">&quot;=&amp;D&quot;</span>(d1), <span class="string">&quot;=&amp;S&quot;</span>(d2), [cnt] <span class="string">&quot;+r&quot;</span>(cnt) </span><br><span class="line">    :</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用$REP$前缀简化上述过程<br><div class="note info"><p>$REP$将$rcx$寄存器数值作为计数器,比如初始化$rcx=100$, 那么$rep$后面跟的指令就会执行100次, 因此初始化$rcx=n$, 然后$rep \ movsb$就可以了.</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d1, d2, cnt = n;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;rep movsb\n&quot;</span></span><br><span class="line">    :<span class="string">&quot;=&amp;D&quot;</span>(d1), <span class="string">&quot;=&amp;S&quot;</span>(d2),<span class="string">&quot;+c&quot;</span>(cnt) </span><br><span class="line">    :</span><br><span class="line">    :<span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>既然有$movsb$,那我们可以也考虑$movsq$,这样子拷贝数据不就更快了? 比方现在我们要拷贝5个$int(n=20)$,每次1个字节的话需要20次$movsb$, 如果每一次拷贝 8 个字节的话,那么只需要 2 次$movsq$和 1 次$movsb$就可以了.所以,$memcpy$还可以按以下的写法写.</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d0, d1, d2; </span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;rep ; movsq # 每次拷贝8个字节, 总共执行 n / 8次\n\t&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;movq %4,%%rcx #剩下的不足8个字节, 换用movsb\n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;rep ; movsb # movsb需要执行(n &amp; 7)次\n\t&quot;</span></span><br><span class="line">       : </span><br><span class="line">      <span class="string">&quot;=&amp;c&quot;</span> (d0),                                                                                   </span><br><span class="line">      <span class="string">&quot;=&amp;D&quot;</span> (d1),</span><br><span class="line">      <span class="string">&quot;=&amp;S&quot;</span> (d2)</span><br><span class="line">      :<span class="string">&quot;0&quot;</span> (n &gt;&gt; <span class="number">3</span>), </span><br><span class="line">      <span class="string">&quot;g&quot;</span> (n &amp; <span class="number">7</span>), </span><br><span class="line">      <span class="string">&quot;1&quot;</span> (dest),</span><br><span class="line">      <span class="string">&quot;2&quot;</span> (src)</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">      );  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-asm-setjmp"><a href="#4-asm-setjmp" class="headerlink" title="$(4)asm_{-}setjmp$"></a>$(4)asm_{-}setjmp$</h3><p>$asm_{-}setjmp$的作用是保存”快照”, 需要保存的信息自然是跟当前的栈帧相关的信息:<br>$rsp(栈顶),rbp(栈底), rbx, r12, r13, r14, r15$, 后面四个寄存器作为被调用者保存寄存器也应当保存.(set_jmp是被调用者)<br>$asm_{-}jmp_{-}buf$是用来存放这些寄存器的结构,它的定义如下(定义方式不唯一):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _JLEN 7</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">uint64_t</span> _jb[_JLEN + <span class="number">1</span>];&#125;asm_jmp_buf[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><p>比如我们现在在$main$调用$asm_{-}setjmp$,在执行$call$指令之前,$main$的栈帧如下:<br><img src="/2021/10/30/Lab2/g1.png" alt="逻辑图" style="zoom:100%;"><br>执行$call$指令,首先将$asm_{-}setjmp$的返回地址压栈.然后跳转到$asm_{-}setjmp$.执行$asm_{-}setjmp$之前,栈如下:<br><img src="/2021/10/30/Lab2/g2.png" alt="逻辑图" style="zoom:100%;"></p><div class="note info"><p>现在考虑$asm_{-}setjmp$究竟干了什么?!简单来说:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">asm_setjmp</span><span class="params">(asm_jmp_buf env)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 注意env这个时候是一个指针</span></span><br><span class="line">  <span class="comment">// mov %rsp to env-&gt;_jb[0] 将rsp保存</span></span><br><span class="line">  <span class="comment">// mov M[%rsp] to env-&gt;_jb[1], 将返回地址保存</span></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// mov $0, %rax, 直接调用setjmp的返回值是 0 </span></span><br><span class="line">  <span class="comment">// ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><p>好了回归正题,我们进入$asm_{-}setjmp$后, 手里握着若干的需要保存的寄存器数据,关键就是获知上面的$env\rightarrow_{-}jb [ 0 ,1,2…]$的地址.<br>$x86-64$的过程调用约定:当函数的入口参数是整数类型或者指针类型并且小于等于6个的时候,无需用栈来传递参数,依次存放在$RDI,RSI\dots$中.这里的env传进来的只是一个指针,因此$env\rightarrow_{-}jb [ 0 ]$的地址就是$R[rdi]$,$env\rightarrow_{-}jb [ 1 ]$的地址存放在$R[rdi] + 8$中,后面类推.</p><p><img src="/2021/10/30/Lab2/g3.png" alt="图3" style="zoom:100%;"></p><p>代码部分实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">asm_setjmp</span><span class="params">(asm_jmp_buf env)</span></span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;movq %%rsp, (%%rdi) # 将rsp保存\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq (%%rsp), %%rdx # rdx临时存放返回地址\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rdx, 8(%%rdx) \n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;TODO&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;ret\n&quot;</span></span><br><span class="line">    :</span><br><span class="line">    :</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">// 之所以需要临时寄存器,是因为并没有&quot;mov 内存, 内存&quot;的指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-asm-longjmp"><a href="#5-asm-longjmp" class="headerlink" title="$(5)asm_{-}longjmp$"></a>$(5)asm_{-}longjmp$</h3><p>$longjmp$和$setjmp$一般是搭配使用的.<br><div class="note success"><p>$asm_{-}longjmp$做的事情:恢复”快照”,设置val, 并将自己的返回地址设置为对应的$jmp_{-}buf$当中的返回地址.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">asm_longjmp</span><span class="params">(asm_jmp_buf env, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="comment">// mov env-&gt;_jb[0] , %rsp</span></span><br><span class="line">  <span class="comment">// mov env-&gt;_jb[1] , M[%rsp]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set the val as return value</span></span><br><span class="line">  <span class="comment">// ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><p><font color="red">直接调用$setjmp$的返回值是0</font>.而$longjmp$将自己的返回地址换成$setjmp$的返回地址之后,在$main$看来跟直接调用$setjmp$并无区别,唯一不同的就是返回值.<font color="red">返回值为整型的函数的返回值一般存放在$\%rax|\%eax$中, $main$的视角下,$setjmp$的返回值是$\%eax$</font><br>根据前面讲的内容,val存放在第二个参数寄存器$\%rsi$中,因此<code>movl %esi, %eax</code>就可以解决返回值问题了.</p><div class="note primary"><p>一个简单的理解方式:<br>$asm_{-}longjmp$实际上就是”窃取了”$asm_{-}setjmp$的返回地址, “伪装成”$asm_{-}setjmp$”堂而皇之”地回到调用$asm_{-}setjmp$的函数中,这个过程还通过修改$\%eax$改变了它的返回值.</p></div>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内联汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA2.3</title>
      <link href="/2021/10/26/PA2-3/"/>
      <url>/2021/10/26/PA2-3/</url>
      
        <content type="html"><![CDATA[<p>$PA2.3$主要是设备的实现.关系图如下:<br><img src="/2021/10/26/PA2-3/gra.png" alt="逻辑图"><br><span id="more"></span></p><p>AM抽象计算机直接跟我们在其上面运行的各种应用程序打交道,<strong>在am-tests里面的各种测试程序都算是运行在am上的应用程序.(很重要!!)</strong></p><p>应用程序如果想要访问设备,比如说测试集里的$rtc.c$想要获取当前的时间,那么需要跟am进行交互.具体就是通过$io_{-}read,io_{-}write$函数.<br>而AM跟nemu进行设备相关的交流,得通过$inl, outl$等函数对各种设备的地址进行读写<br>$nemu$模拟的硬件设备会将其对应的数据存在指定的内存地址里面,访问和更新设备,实际上就是对内存地址的访问,取出相应的数据和对内存地址的信息进行改写.</p><div class="note danger"><p>将设备的访问放在nemu原则上也是可行的,但是不同架构之间设备的访问是不兼容的.而在AM中,我们约定在不同的架构中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象, 因此我们只需要在<code>abstract-machine/am/src/platform/nemu/ioe/</code>目录下实现一份IOE, 来供NEMU平台的架构共享.<br>AM的出现使得不同架构访问设备更加方便,不用分别在不同架构里面分别实现设备的访问.</p></div> <h3 id="一-时钟的实现"><a href="#一-时钟的实现" class="headerlink" title="(一)时钟的实现"></a>(一)时钟的实现</h3><h4 id="1-riscv-h-和-nemu-h"><a href="#1-riscv-h-和-nemu-h" class="headerlink" title="(1)$riscv.h$和$nemu.h$"></a>(1)$riscv.h$和$nemu.h$</h4><p>$riscv.h$定义了$inb, inw, inl, outb\dots$等函数,<strong>这些函数特别关键,是AM与设备的桥梁.</strong><br><img src="/2021/10/26/PA2-3/image-20211003204455099.png" alt="关键的函数"><br>inb(addr)获取addr地址的数据, 该数据为一个字节.其他类似. outb(addr, data),向addr地址写入一个一字节的数据data.</p><p>$nemu.h$定义了各种设备的的相关物理地址,时钟的物理地址<code>#define RTC_ADDR        (DEVICE_BASE + 0x0000048)</code>,该64位数的地址存储了时间数据(以微秒为单位).</p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>在$timer.c$的<code>__am_timer_uptime</code> 做如下修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime-&gt;us = indl(RTC_ADDR);</span><br></pre></td></tr></table></figure><br>其中<code>indl</code>函数是我们在$riscv.h$<strong>自定义</strong>的访问64位数据的函数,原理与inl等函数完全一样.</p><h4 id="3-如何测试"><a href="#3-如何测试" class="headerlink" title="(3)如何测试?"></a>(3)如何测试?</h4><p><strong>在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=t run</code>.</strong><br>结果如下图:<br><img src="/2021/10/26/PA2-3/image-20211026204348486.png" alt><br><div class="note info"><p>在<code>am-kernals/tests/am-tests/src</code>的main.c定义了各种测试的首字母, 如<code>[&#39;t&#39;] = &quot;real-time clock test&quot;,</code>mainargs根据终端的字母缩写确定运行哪一个测试集. 可以尝试在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=H run</code>,看看会发生什么.</p></div> </p><h4 id="4-流程图"><a href="#4-流程图" class="headerlink" title="(4)流程图"></a>(4)流程图</h4><p><img src="/2021/10/26/PA2-3/gra1.png" alt><br>注:上图的回调函数就是:<code>nemu/src/device/timer.c</code>的<code>rtc_io_handler</code></p><h4 id="5-buggy"><a href="#5-buggy" class="headerlink" title="(5)$buggy?!$"></a>(5)$buggy?!$</h4><p>事实上,上面的代码是有BUG的,而且这个bug虽然在测试终端看不出来(或者说,不明显),但是跑分的时候就会出现非常大的问题(爆分!).因为64位的时间意味着需要调用两次回调函数,先访问高32位还是低32位会一定差别.<br>所以需要将上述代码的64位读取改为<strong>先访问高32位数然后再访问低32位</strong>. 高32位地址为<code>RTC_ADDR + 4</code>, 低32位为<code>RTC_ADDR</code>,两次调用$inl$函数再拼接就可以了.<br><code>(uint64_t)inl(RTC_ADDR + 4)&lt;&lt;32+inl(RTC_ADDR)</code></p><div class="note info"><p>为什么会有访问顺序不同造成的差别?<br>实际上,虽然我们调用两次回调函数,但两次调用只有一次是真正有效的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(nemu/src/device/timer.c)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_io_handler</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">int</span> len, <span class="keyword">bool</span> is_write)</span> </span>&#123;</span><br><span class="line">  assert(offset == <span class="number">0</span> || offset == <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> (!is_write &amp;&amp; offset == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> us = get_time();</span><br><span class="line">    rtc_port_base[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>)us;</span><br><span class="line">    rtc_port_base[<span class="number">1</span>] = us &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出,<strong>只有offset = 4才能将”当前系统启动时间”写入内存</strong>,换而言之,如果在<code>inl(RTC_ADDR + 4)</code>之前调用<code>inl(RTC_ADDR)</code>,那么访问到的低32位的时间是上一次”残留”的时间,并不是”当前时间”.</p></div> <h3 id="二-键盘的实现"><a href="#二-键盘的实现" class="headerlink" title="(二)键盘的实现"></a>(二)键盘的实现</h3><p>在我们使用AM(软件)输出键盘信息之前,$nemu$(硬件)模拟的$i8042$芯片已经根据我们在电脑的键盘输入情况将对应的键盘码写入nemu键盘对应的物理地址,所以我们<strong>直接调用前面讲的in函数就可以取出相应的信息了</strong>.至于模拟的芯片怎们写入数据的,可以查看keyboard.c文件.(讲义:每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以访问数据寄存器, 获得键盘码,<strong>只有一个字节(256足够对应整个键盘的所有键了)</strong>)</p><p>值得一提的是,芯片在写入按下(down)时加了一个<strong>掩码处理</strong>,比如1对应空格键盘,如果按下,那么写入信息为0x8001,如果松开,写入信息为0x0001,因此我们在AM(软件)读取地址信息后,还需进一步做<strong>还原处理</strong>,才能正确获知keydown的值.</p><h4 id="1-掩码处理"><a href="#1-掩码处理" class="headerlink" title="(1)掩码处理?!"></a>(1)掩码处理?!</h4><p>查看nemu下面的$keyboard.c$, 掩码处理最重要的一句:<br><code>uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);</code> </p><p>当你按下键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | KEYDOWN_MASK = keymap[ESCAPE] | 0x8000</code>;当你松开键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | 0 = keymap[ESCAPE]</code>.</p><div class="note info"><p><code>i8042_data_io_handler</code>函数的<code>i8042_data_port_base[0] = key_dequeue();</code>将键盘码写入键盘对应的内存!!!</p></div><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>$input.c$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) &#123;</span><br><span class="line">   kbd-&gt;keydown = <span class="number">0</span>;</span><br><span class="line">   kbd-&gt;keycode = inl(KBD_ADDR);<span class="comment">//读取键盘码,类似于时钟的数据获取</span></span><br><span class="line">   <span class="keyword">if</span> (kbd-&gt;keycode != <span class="number">0</span>)<span class="comment">//不为空(无输入)</span></span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">//判断第16位(二进制)是否为1, 如果是,说明做了掩码处理,需要还原,同时将keydown设置为true</span></span><br><span class="line">      <span class="keyword">if</span>(kbd-&gt;keycode &gt;&gt; <span class="number">15</span>)&#123;        </span><br><span class="line">        kbd-&gt;keydown = <span class="literal">true</span>;</span><br><span class="line">        kbd-&gt;keycode = (kbd-&gt;keycode &lt;&lt; <span class="number">17</span>) &gt;&gt; <span class="number">17</span>;<span class="comment">//掩码逆处理</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         kbd-&gt;keydown = <span class="literal">false</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果:<br><img src="/2021/10/26/PA2-3/1.png" alt></p><h3 id="三-vga的实现"><a href="#三-vga的实现" class="headerlink" title="(三)vga的实现"></a>(三)vga的实现</h3><p>$vga$的控制端有两个重要的寄存器(这两个寄存器的具体含义可以通过查看<code>nemu/src/device/vga.c</code>得知), <code>vgactl_port_base[0]</code>的高低16位分别存储屏幕的宽度和高度.<code>vgactl_port_base[1]</code>存储的是是否将屏幕刷新的值(true or false).<strong>(同步寄存器sync register)</strong></p><div class="note info"><p><code>init_vga</code>函数的 <code>vgactl_port_base[0] = (screen_width() &lt;&lt; 16) | screen_height();</code>将屏幕大小信息写入一个32位的存储空间</p></div><h4 id="1-在硬件层面"><a href="#1-在硬件层面" class="headerlink" title="(1)在硬件层面"></a>(1)在硬件层面</h4><p>此处硬件指的是$nemu$的$vga.c$, 里面的<code>void vga_update_screen()</code>提示的非常清楚:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when the sync register is non-zero,</span></span><br><span class="line"><span class="comment">//根据前面</span></span><br><span class="line"> <span class="keyword">if</span>(vgactl_port_base[<span class="number">1</span>] != <span class="number">0</span>)update_screen();</span><br><span class="line"><span class="comment">// then zero out the sync register</span></span><br><span class="line">  vgactl_port_base[<span class="number">1</span>] = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><br>通过阅读vga.c, 还可以知道$width = 400, height = 300$</p><div class="note success"><p>  查看 AM(软件层面) 下面的gpu.c, 可以发现__am_gpu_fbdraw里面有这么一句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);<span class="comment">//写入 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:向sync_addr写入1之后,vga_update_screen检查sync寄存器的值(不为 0 ),然后调用update_screen();</p></div><p>添加好讲义给定的测试代码之后,正确的运行结果如下:<br><img src="/2021/10/26/PA2-3/2.png" alt></p><h4 id="2-在软件层面"><a href="#2-在软件层面" class="headerlink" title="(2)在软件层面"></a>(2)在软件层面</h4><p>正确实现$AM_{-}GPU_{-}FBDRAW$的画面如下:<br><img src="/2021/10/26/PA2-3/3.png" alt></p><div class="note warning"><p>上面动画效果怎么来的?    </p></div><p>流程图如下:<br><img src="/2021/10/26/PA2-3/gra2.png" alt></p><p>代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) &#123;</span><br><span class="line">    <span class="comment">//*ctl接受了来自APP(应用程序)的缓冲信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width = inw(WID_ADDR), height = inw(HEIGHT_ADDR);<span class="comment">//获取屏幕宽度, 高度</span></span><br><span class="line">    <span class="keyword">int</span> col, row;</span><br><span class="line">    <span class="comment">//uint32_t *fb = (uint32_t *)(uintptr_t)FB_ADDR;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pixelss = ctl-&gt;pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> point_x = ctl-&gt;x, point_y = ctl-&gt;y, target_w = ctl-&gt;w, target_h = ctl-&gt;h;<span class="comment">//开始的x, y以及绘画区域的w, h</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = point_y; row &lt; (point_y + target_h) &amp;&amp; row &lt;= height; row++)</span><br><span class="line">      <span class="keyword">for</span> (col = point_x; col &lt; (point_x + target_w) &amp;&amp; col &lt;= width; col++) </span><br><span class="line">      outl(FB_ADDR + (col + row*width)*<span class="number">4</span> , pixelss[target_w*(row - point_y) + col - point_x] );</span><br><span class="line">      <span class="comment">// outl的作用不就是将信息写入指定物理地址</span></span><br><span class="line">      <span class="comment">//等价于fb[col + row*width] = pixelss[target_w*(row - point_y) + col - point_x];</span></span><br><span class="line">  <span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">    outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码实际上是讲义给出的测试的<strong>进阶版本</strong>,不信可以对比一下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">400</span>;  </span><br><span class="line"><span class="keyword">int</span> h = <span class="number">300</span>;  </span><br><span class="line"><span class="keyword">uint32_t</span> *fb = (<span class="keyword">uint32_t</span> *)(<span class="keyword">uintptr_t</span>)FB_ADDR;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;<span class="comment">//向地址写入像素信息(所以我们会看到第一幅图从左边到右边颜色的递变)</span></span><br><span class="line"> <span class="comment">//等价于for (i = 0; i &lt; w * h; i ++) outl(FB_ADDR + 4 * i, i); 想想outl的作用</span></span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><div class="note info"><p>还是不太理解?!<br> <code>_am_gpu_fbdraw()</code>属于软件层面的函数, 归$AM$管理,这个函数的作用就是将来自于$APP$客户程序的像素信息(该信息存储在缓冲区,并作为<code>_am_gpu_fbdraw()</code>的参数传入)写到物理地址里面,前面讲过,$AM$想要将数据写入物理地址需要借助$out[b|w|l]函数.$ </p></div>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六次OJ</title>
      <link href="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/"/>
      <url>/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/</url>
      
        <content type="html"><![CDATA[<h2 id="A-最大内切球"><a href="#A-最大内切球" class="headerlink" title="A. 最大内切球"></a>A. 最大内切球</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在三维空间中，线性方程$ax+by+cz\leq d$ 构成一个“半空间”。</p><p>现在给出 $n$ 个这样的线性方程，第 $i$ 个线性方程用$(a_i,b_i,c_i,d_i)$表示.</p><p>求在这 $n$ 个线性方程与限制$\{x\geq 0,y\geq 0, z\geq 0\}$构成的”半空间交“中，内切球的最大半径是多少。</p><p>若这个“半空间交”为空（即上述线性方程组无解），则输出4位小数0.0000。</p><p>如果这个球的半径可以为无穷大，则输出”Infinity”，否则输出一个4位小数，表示最大内切球的半径。<br><span id="more"></span></p><p><strong>输入格式</strong></p><p>第一行一个正整数 $T$，表示测试组数。</p><p>每组测试中，第一行输入一个正整数 $n$，表示线性方程的个数，接下来 $n$​ 行，每行4个整数$a,b,c,d$，表示线性方程$ax+by+cz\leq d$.</p><p>保证对每一组线性方程, $a,b,c$​ 不同时为0。</p><p><strong>输出格式</strong></p><p>共 $T$ 行，每行输出一个保留4位小数的答案，或者$Infinity$。</p><p><strong>样例</strong></p><p><strong>样例输入 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>样例输出 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.5000</span></span><br><span class="line"><span class="number">0.2113</span></span><br><span class="line"><span class="number">0.5901</span></span><br><span class="line"><span class="number">0.5000</span></span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>保证$1\leq T \leq 150, 1\leq n \leq 100, -100\leq a,b,c,d \leq 100, \sum n \leq 2500$。</p><p>保证对于所有答案不为”Infinity“的答案，答案都$\leq 10^9$。</p><p>良心的助教提供了单纯形的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设输入给定的 n 个方程形式为：</p><p>$\begin{cases} a[1, 1] x+ a[1, 2]y + a[1, 3]z\leq a[1, 0]\\a[2, 1] x+ a[2, 2]y + a[2, 3]z\leq a[2, 0] \\\dots \\ \end{cases}$​</p><p>根据给出的==单纯形模板的要求==：</p><p>我们需要将$a[i][j],\ 1\leq j\leq3$取为相反数，记作$b[i][j]$​，那么方程变为</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\ \end{cases}$​​</p><p>这样子就可以直接使用单纯形模板了。</p><p>假定现在的半径为 $radius$​​，设半空间内的某点$(x, y, z)$​​， 根据点到平面的距离公式，我们有：<br>${|ax + by + cz - d|\over\sqrt{a^2 + b^2+c^2} }\geq radius$​</p><p>由于给定条件下$ax + by + cz\leq d$​, 化简之后：</p><p>$-ax -by-cz + d - \sqrt{a^2 + b^2+c^2}\times radius\geq0, \ (1)$​​</p><p>想要知道这个半径所形成的球能否放到我们约束的“半空间”，只需要在原来n个方程的基础上加上 (1) 所形成的 n 个新的约束方程</p><p> ,当然还要注意题目的要求：$x, y, z\geq 0$,根据半径要求：</p><p>$x, y, z\geq radius$</p><p>因此所形成的$2\times n + 3$个限制方程如下：</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\b[n, 1]x +b[n, 2]y + b[n, 3]z+a[n, 0]\geq0\\前n个方程\\b[1,1]x+b[1,2]y+b[1, 3]z+a[1,0]-\sqrt{b_{1,1}^2+b_{1,2}^2+b_{1,3}^2}\times radius\geq0 \\\dots \\由于半径引入的n个方程\\x-radius\geq0\\y-radius\geq0\\z-radius\geq0\end{cases}$</p><p>然后调用单纯形算法就可以判定radius是否合理。==利用这个判定的性质，二分是适合这道题的解法。==</p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ld radius, <span class="keyword">int</span> temp_m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i + m][k] = a[i][k];<span class="comment">//新设立的 m 个方程的系数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新设立的 m 个方程的常数d - radius * sqrt(a^2 + b^2 + c^2)</span></span><br><span class="line">        a[i + m][<span class="number">0</span>] = a[i][<span class="number">0</span>] - <span class="built_in">sqrt</span>(a[i][<span class="number">1</span>]*a[i][<span class="number">1</span>] + a[i][<span class="number">2</span>]*a[i][<span class="number">2</span>] + a[i][<span class="number">3</span>]*a[i][<span class="number">3</span>])*radius;</span><br><span class="line">    &#125;</span><br><span class="line">    m += temp_m;<span class="comment">//增加了 temp_m + 3个方程 </span></span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">1</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">1</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">1</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        n = <span class="number">3</span>;<span class="comment">//只有三个变量x, y, z</span></span><br><span class="line">        <span class="comment">//输入m个原始约束，并将系数取相反数, b数组用来临时存储a的数据，因为后续单纯形算法可能会改变 a 的部分值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][<span class="number">1</span>]&gt;&gt;a[i][<span class="number">2</span>]&gt;&gt;a[i][<span class="number">3</span>]&gt;&gt;a[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i][k] = b[i][k]= -a[i][k];</span><br><span class="line">            b[i][<span class="number">0</span>] = a[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理进行判断：半空间是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;0.0000\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">        ld left = <span class="number">0</span>, right = inf;</span><br><span class="line">        <span class="keyword">int</span> temp_m = m;<span class="comment">//临时存储 m 的值,因为二分每一次check都会修改new_m = old_m*2 + 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; eps)&#123;</span><br><span class="line">            ld medi_radius = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(medi_radius, temp_m))left = medi_radius;</span><br><span class="line">            <span class="keyword">else</span> right = medi_radius;</span><br><span class="line"></span><br><span class="line">            m -= temp_m + <span class="number">3</span>;<span class="comment">//恢复 m 的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复数组a的值，因为单纯形算法可能影响原先数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">                a[i][k] = b[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; eps + <span class="number">1e9</span>)cout&lt;&lt;<span class="string">&quot;Infinity&quot;</span>&lt;&lt;endl;<span class="comment">//半空间不是有限空间（此时left = right = inf = 1e12）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.4Lf\n&quot;</span>,left); <span class="comment">//有限解,注意long double的输出方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-文理分科"><a href="#B-文理分科" class="headerlink" title="B. 文理分科"></a>B. 文理分科</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在高中时候，yjher所在的班级要进行文理分科。他的班级可以用一个 $n\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：</p><p>如果第 i 行第 j 列的同学选择了文科，则他将获得$art_{i,j}$的满意值，如果选择理科，将得到$science_{i,j}$ 的满意值。</p><p>如果第 i 行第 j 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same_art_{i,j}$的满意值。</p><p>如果第 i 行第 j 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加$same_science_{i,j}$的满意值。</p><p>yjher想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。</p><p><strong>输入格式</strong></p><p>输入第一行为两个正整数 n,m。</p><p>接下来 n 行 m 整数，第 i 行第 j 个整数表示$art_{i,j}$</p><p>接下来 n 行 m个整数，第 i 行第 j 个整数表示$science_{i,j}$</p><p>接下来 n 行 m整数，第 i 行第 j 个整数表示$same_{-}art_{i,j}$</p><p>接下来 n 行 m 个整数，第 i 行第 j 个整数表示$same_{-}science_{i,j}$</p><p><strong>输出格式</strong></p><p>输出为一个整数，表示最大的满意值之和。</p><p><strong>样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">13</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="symbol">18 </span><span class="number">17</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">13</span> <span class="number">15</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">3</span> <span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">18</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>$n,m\leq 100$,读入数据均$\geq 0,\leq 500$</p><p>1 表示选择文科，0 表示选择理科，样例方案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">152</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>解法：网络流</strong></p><p>现在先不考虑由于临近的同学选择相同的科目而带来的收益。<br>建立如下网络图：<img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211019203309059.png" alt></p><p>对这个网络调用最大流算法，根据<strong>最小割最大流定理</strong>，这样子求出来的==满意值总和实际上是最小值， 割掉的边实际上是不选的科目==。</p><p>所求满意值最大值为$\sum (art_{i,j}+science_{i, j}) - max_{-}flow$​</p><p><code>----------------------------------------------------------------------------------------------</code></p><p>现考虑由于临近同学选科情况带来的满意值：</p><p>新加入5号点和9号点作为1号的虚拟节点。5 与1,2,3,4的之间边的容量为 $inf$​​ .</p><p>1, 2, 3,4与9之间边的容量为 $inf$<br><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020093816755.png" alt><br>具体分析由于邻近选科情况的满意值：</p><p>假如1号同学==最后选择了文科==，那么根据前面的分析，这里<strong>割掉的边应该是$1\longrightarrow T$</strong>​​</p><ul><li><p>如果与之相邻的2, 3, 4 同学最后选择的也是文科，那么$2, 3,4 \longrightarrow T$​的边均被割断， $S\longrightarrow 5$​不可能被割断（采用反证法：$cut(L, R)， S\in L, T\in R, \ $​如果s -&gt; 5被割断了，那么$5\in R$​, 而$1, 2, 3,4 \in L$​, $cut(L, R) = inf$​, 意味着容量为 inf 的边被割断了，这显然不行)，所以$maxflow$​不包括$same_{-}art_{1, 1}$​​</p><p>最后用$\sum (art_{i,j}+science_{i, j} +same_{-}art_{i,j}  +same_{-}sci_{i, j}) - max_{-}flow$​​​​ 时==没有减去$S\longrightarrow 5$​​​​​的边权==，最大满意值也就将1, 2, 3 , 4选择文科时 ,1 号同学所带来的附加满意值计算在内了。 </p><p>按照这个分析，这个时候$9\longrightarrow T$是应该被割掉的边，因为此时 1 并未与邻近的2, 3, 4一起选择理科。那事实是否如此？</p><p>确实如此，记$cut(L, R)， S\in L, T\in R$​, 那么 9 号要么在L，要么在R。</p><p>假设$9\in R$​​​, 因为$1,2, 3,4 \in L$​, 此时$cut(L, R) = inf$​​​​，因为该cut割掉了2, 3, 4与 9 的容量为 inf 的边，这与容量为 inf 的边无法割断矛盾， 因此符合事实。 所以$9\in L$​, 所以$9\longrightarrow T$​被割断。</p></li><li><p>如果2， 3， 4未必都选文科，根据以上分析，$S\longrightarrow 5$​的边和$9\longrightarrow T$​​都会被割断。</p><p>证明：（反证），不妨设 4 号最终选择了理科，那么$4\longrightarrow T$没有被割断（==割掉的边实际上是不选的科目==），这时如果$S\longrightarrow 5$没有被割断，那么增广路径$S\longrightarrow 5\longrightarrow 4 \longrightarrow T$存在，与最大流终止条件矛盾，9号类似。</p></li></ul><p><code>---------------------------------------------------------------------------------</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_edge_num = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_point_num = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S = <span class="number">0</span>, T;</span><br><span class="line"><span class="keyword">int</span> tot_point_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123; X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> X*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星建图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, capacity;</span><br><span class="line">&#125;edges[Max_edge_num];</span><br><span class="line"><span class="keyword">int</span> total_edge_num = <span class="number">0</span>;<span class="comment">//总的点数</span></span><br><span class="line"><span class="keyword">int</span> head[Max_point_num];</span><br><span class="line"><span class="comment">//分析边数数目：原图的点最多有100*100个，与S和T形成20000条边，新点至多有20000个，每一个新点至多6条边，至多120000条边</span></span><br><span class="line"><span class="comment">//这样子至多有：140000*2（注意双向加边）条边，有约30000个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个二维的点赋唯一的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建图加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    edges[total_edge_num].to = end;</span><br><span class="line">    edges[total_edge_num].next = head[start];</span><br><span class="line">    edges[total_edge_num].capacity = capacity;</span><br><span class="line">    head[start] = total_edge_num;</span><br><span class="line">    ++total_edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ISAP模块</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">int</span> d[Max_point_num],  cur_edge[Max_point_num], numd[Max_point_num], pre[Max_point_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//三个数组初始化 </span></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">memset</span>(numd, <span class="number">0</span>, <span class="keyword">sizeof</span> numd);</span><br><span class="line"><span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot_point_num; i++)cur_edge[i] = head[i];<span class="comment">//初始化当前弧（当前边）数组 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numd[<span class="number">0</span>] = tot_point_num; </span><br><span class="line"><span class="keyword">int</span> max_flow = <span class="number">0</span>;<span class="comment">//存储最大流 </span></span><br><span class="line"><span class="keyword">int</span> u = S;</span><br><span class="line"><span class="keyword">while</span>(d[S] &lt; tot_point_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> neck, i; </span><br><span class="line"><span class="comment">//找到增广路径 </span></span><br><span class="line"><span class="keyword">if</span>(u == T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_flow = inf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据（*）寻找增广路径 </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(min_flow &gt; edges[cur_edge[i]].capacity)</span><br><span class="line">&#123;</span><br><span class="line">min_flow = edges[cur_edge[i]].capacity;</span><br><span class="line">neck = i;<span class="comment">//找到瓶颈节点  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改增广路径上各边的容量:正向边减min_flow，反向边加min_flow </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line">edges[cur_edge[i]].capacity -= min_flow;</span><br><span class="line">edges[cur_edge[i] ^ <span class="number">1</span>].capacity += min_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_flow += min_flow;</span><br><span class="line"><span class="comment">//cout&lt;&lt;max_flow&lt;&lt;endl;</span></span><br><span class="line">u = neck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从瓶颈点继续寻找增广路 </span></span><br><span class="line"><span class="keyword">for</span>(i = cur_edge[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span> &amp;&amp; d[u] == d[edges[i].to] + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到可行出点 </span></span><br><span class="line">cur_edge[u] = i;</span><br><span class="line">pre[edges[i].to] = u;</span><br><span class="line">u = edges[i].to;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">-1</span>)<span class="comment">//找不到下一个点了</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">numd[d[u]]--; </span><br><span class="line"><span class="keyword">if</span>(numd[d[u]] == <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//算法终止</span></span><br><span class="line"></span><br><span class="line">cur_edge[u] = head[u];<span class="comment">//从头再来</span></span><br><span class="line"><span class="keyword">int</span> h = tot_point_num - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">h = <span class="built_in">min</span>(h, d[edges[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">d[u] = h + <span class="number">1</span>;<span class="comment">//当d[u] = n时说明u点已经退出残留网络</span></span><br><span class="line">numd[d[u]]++;</span><br><span class="line"><span class="keyword">if</span>(u != S)u = pre[u];<span class="comment">//回溯到上一个顶点</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//找得到下一个出点就继续找，可省略这句 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_flow;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="keyword">sizeof</span> head);<span class="comment">//初始化为 -1</span></span><br><span class="line">    T = n*m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理点的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; j++)&#123;</span><br><span class="line">            id[i][j] = <span class="built_in">get_id</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入第一个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += art_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, id[i][j], art_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], S, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入第二个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            science_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += science_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], T, science_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(T, id[i][j] , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入后两个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> new_node_id = n * m + <span class="number">1</span>; <span class="comment">//新点的id从此数 + 1开始</span></span><br><span class="line">    <span class="keyword">int</span> same_art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += same_art_i_j;</span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, new_node_id, same_art_i_j);<span class="comment">//加一条从源点S到新点的边，权值为same_art_i_j</span></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, S, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//枚举4个方向合理的邻居并且加边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> same_science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_science_i_j = <span class="built_in">read</span>();</span><br><span class="line">            </span><br><span class="line">            sum += same_science_i_j;</span><br><span class="line"></span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, T, same_science_i_j);<span class="comment">//加一条从新点到汇点 T 的边</span></span><br><span class="line">            <span class="built_in">add_edge</span>(T, new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tot_point_num = new_node_id;</span><br><span class="line">    cout&lt;&lt;sum - <span class="built_in">ISAP</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Did-you-just-say-……-Acesrc"><a href="#C-Did-you-just-say-……-Acesrc" class="headerlink" title="C. Did you just say …… Acesrc?"></a>C. Did you just say …… Acesrc?</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc解决下面的问题:</p><p>一个梯图$(ladder\ graph)L(n)$一个由$2N$个顶点以及$3N−2$条边组成的平面图。它和如下$2\times N$的格点图是同构的。</p><p><img src="http://roundgod.com/resources/wcy-2.png" alt="http://roundgod.com/resources/wcy-2.png"></p><p>你希望删掉$L(n)$中一些边的集合(可能为空)，并保证剩下的图仍然是联通的。计算你有多少种合法的删除的方案。请输出答案对$10^9+7$取模后的结果。</p><p>如果你能做出这道题，Acesrc便会不再做人，成为唯一A皇。对了,你刚才说了Acesrc,……对吧?</p><p><strong>输入格式</strong></p><p>输入仅包含一行，一个正整数N。</p><p><strong>输出格式</strong></p><p>输出仅包含一行，合法的删除的方案数对$10^9+7$取模后的结果。</p><p><strong>样例</strong></p><p><strong>样例输入1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>样例输出1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>样例输入2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024</span><br></pre></td></tr></table></figure><p><strong>样例输出2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">399356307</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>对于$50\%$的数据，有$1\leq N\leq 10^7$。</p><p>对于$100\%%$的数据，有$1\leq N\leq 10^{18}$。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020154943537.png" alt><br>记$g[i]$表示一个$2\times i$​​​的梯图最右侧两个点（上图的 i 和i + i）==不连通，并且整个图只有两个连通分支==的方案数。</p><p>记$f[i]$为$2\times i$的梯图最右侧两个点是连通且整个图只有一个连通分支的方案数。</p><p>考虑状态转移如下：</p><p>$f[i] = 4f[i-1]+g[i-1]$​</p><p>解释：</p><ul><li>在$f[i-1]$的基础上，考虑最后一个格子三条边的情况：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020162606799.png" alt="image-20211020162606799"></p><p>这四种加边情况都可以保证最后整个图是连通的。</p><ul><li>在$g[i-1]$​的基础上，只能加上图的第一种情况。</li></ul><p>$g[i] = 2f[i-1]+g[i-1]$</p><p>解释：</p><ul><li>在$f[i-1]$​​的基础上，考虑最后一个格子三条边的情况（有两种情况,分别是加上边,加下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165138823.png" alt></p><ul><li>在$g[i-1]$的基础上，考虑最后一个格子三条边的情况（只有一种情况,加上边和下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165254450.png" alt></p><p>构造矩阵</p><p>$Relation_{-}Matrix = \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)$​​</p><p>$\because f[1] = 1, g[1] = 1$​,</p><p>$\therefore \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right)$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^2\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right) = \left(\begin{matrix}f[3]\\g[3]\end{matrix}\right)$</p><p>$\dots$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^{n-1} \left(\begin{matrix}f[1]\\g[1]\end{matrix}\right) =  \left(\begin{matrix}f[n]\\g[n]\end{matrix}\right)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    ll data[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span> data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_row_col</span><span class="params">(matrix &amp;m, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    m.col = col; m.row = row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="function">matrix <span class="title">matrix_multipy</span><span class="params">(matrix &amp;A, matrix &amp;B)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(ret, A.row, B.col);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A.row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B.col; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= A.col; k++)</span><br><span class="line">              ret.data[i][j] = (ret.data[i][j] + A.data[i][k]*B.data[k][j]%mod)%mod;</span><br><span class="line">              <span class="comment">//注意不要写 += ，否则结果可能超过mod，还得再取一次模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始矩阵(f[1], g[1])^T</span></span><br><span class="line">    matrix original_matrix;</span><br><span class="line">    original_matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(original_matrix, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    original_matrix.data[<span class="number">1</span>][<span class="number">1</span>] = original_matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递推矩阵(4, 1, 2, 1)</span></span><br><span class="line">    matrix Relation_Matrix;</span><br><span class="line">    Relation_Matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Relation_Matrix, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Relation_Matrix.data[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span>, Relation_Matrix.data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    Relation_Matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>, Relation_Matrix.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用Re_pow存储关系矩阵的 n - 1 次方</span></span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    matrix Re_pow;</span><br><span class="line">    Re_pow.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Re_pow, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Re_pow.data[<span class="number">1</span>][<span class="number">1</span>] = Re_pow.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//Re_pow初始化为单位矩阵</span></span><br><span class="line">    <span class="comment">// 矩阵快速幂加速矩阵乘法</span></span><br><span class="line">    <span class="keyword">while</span>( n )&#123;</span><br><span class="line">        <span class="keyword">if</span>( n &amp; <span class="number">1</span> )Re_pow = <span class="built_in">matrix_multipy</span>(Re_pow, Relation_Matrix);</span><br><span class="line">        Relation_Matrix = <span class="built_in">matrix_multipy</span>(Relation_Matrix, Relation_Matrix);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用递推矩阵的n - 1次方乘以Original_matrix</span></span><br><span class="line">    matrix ret = <span class="built_in">matrix_multipy</span>(Re_pow, original_matrix);</span><br><span class="line">    cout&lt;&lt;ret.data[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//即f[n]</span></span><br><span class="line">    <span class="comment">// ret.data[1][2]此时为g[n]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第6次OJ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
