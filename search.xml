<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PA4.3</title>
      <link href="/2021/12/30/PA4-3/"/>
      <url>/2021/12/30/PA4-3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="05691bee3800cee429dad0dff99b10c9c6b130bd60964a85205064e29418ad5a">98c5eac1e431cec725e9b50c1f9552a7cfc86e5f98ff8e04356e5c7ae46d7fa8c939043e0dc57294bc08fcfdfa007373369b2c0bf63cc1dd1c59e56e019d1bf6cc387debe35d6e46472770db5140f15cf94e3c294290f031a75e5f7e480b26c2a28c714d84e1a4b67c3e9090fd529d978173c04b4c30b3b0e41d76d54e43f2d84e7af6d4e16e60c4d52d76623218c05de4d1815b0b6cb6d464127e1ccc492e39896f6740120a21b55313cbb3c2f1f11c88c4fe1eb95581963b3e58fd693598b4b63b045e7ac53fdca2218237c698c3f6a99bfbdd39359fb26ae26c61bb12ab9074df54ef71d79eadb4aca8e738510392cd339695c0a78550e610499c99ba5cef1e4fab945ee99a10b1f5a63ababdb68866a233e21628d179548c561c5740a009068b2358f2393466b805fc3a04c7bfa64c84f4834afde710021547c6b80490800e052ec7c1f45fd3fb43f6a1a6a344a2322f6299414725150042567482e43d52cb3191f81cc12aa0a235666dfd1c903b8a569a763a4b2445abcf639690bb275c63dd566fe99a931f4e598e5367f297b71af649026c3bdda9be952cd86c1837a69e7b5f20530ed60feabb4f27cf4543f6e9a271c30cabf8e9f70d3a1d293c35cfa5129099428b3e8a95da6eb72f0485254d9f6dca88e5234740c7561bc62584abf08a5cc32b7da111fdfcb7f85804656c871a32a0f2b09d1688cdeb9cc14ab9dd2c195f7d049213135baa779da65d52f7d35bac49e2e3d813492fecb452dac1a36b86a90987c6bf8cc11019c1b1c79afb9a637fa3349b982e6c1ae4ca48374eaa8d068d74dd809c62a799fbe32ab96ab308256dab873d648eb552c47e2d0229e1464b0315dee09e8d4f0171726b4a66010e3e8d1990493d9873ee2fcfe9430e12c94fdd743d681158b112ce19b1a18551380007ca428b14dbf3f6f0722a14d766ead11e0602cd20ac9d5be0ea0457a206630e62dc75e1bacbc2f132f5a85a6a0b2937df0399b35cb353642cf3454e911dc9a5b6f94c0e2cc27d1b818cecdc94854612ad87c06dfefdbb8ea746afc1ba4536a828512b15cbb5e43ae2399a342ecea0cbbd5e8999a503c4e090e7f0e246975b45f72e84653e4a80834020b7d0e64940d62237521691f9525573895882b858810a1c0a43a6b9f45db0f107542ce9aa4c56b15941e3807826c834c9b96169fb90164e09080e397a58385bdebb745b6f1325ee0788ebfc2fd4f5b6b6941c552796c0b6ca0e3e563be5a46b00088dfb8c5f91509f1d2ddbfe3a53226d56c7d62cd666f2ea365c465e450a917f66542c14d4ecbc32b12af5dc93da139c656d1dda15b9d7ee67d6e78bbc81206d539554a8990dfe9d8525457b52f704afb1163a06d08d6c348fd92ed7136d4f67aae4b65937966fbc0b558aa6fdf11255a86e861a8e5d91701e8564b56b5bc1cb58f43c06910747f668c8e0e2ea9572424b86a2a260af3f25bd732175db1b91aa332a18262ff915cd2081355dd2429716335e185e9191d21f017858726c430e446297b4984c09245e0cde257150b067948bd3e2892ef58ae3c53564c63965b78c1198ac3973608ab8d0b2a9e4e7db7ab4a68cbe419c0a2bc74812ebb4bb7f894bdd086c3fc01ded0d0510bf4e4eb0067ff23dd7afc5ace5023b4b3192e1118d740251b04a237332480f3cbca991d5e91b9d40926bbfb36046b089179f19dbf22cd713db73eeac72ddf2399cca22e2add530c59fc32762b2f46013d26200fdeb0d3eafbda75bbe509a591d3b3fd16e74194f3dbbaf148df3d671d3d5323716ed094deac6e20a367be82790433cc4c09249e11fc2ff98e1d752b6ffc390fd0be5029e6332d35845229673aafc2b69d0bb121abc387772b275922038753866578c573eaab578c0d25396234932865e4158e87e5f2afba615366f4401b95014d0d5cbde7a247ac6ca237cf9b32814aea6b2c7d6d7fe163266505e70e68e2a3b20848ce7c2ceb2e79779e5ff385ae2cb8e3d567b290eae96723baf75d95ea205993e47675b9e7c321a7857dbdbfede0d624976dd54452970de934ec2a6dbe821d6a584a34eeb208209bfcd09c167afa43a97345b7840bb6a5f70eaabf09952bf4608e56a4601a81791ec29b4eadfb8042b8a07c2918f3159d964c2869b3603bae4fb36df9ec599deb556f3042541da2c6e1a1e476f6b1a8fbf2f865ce552c56b6ca6f5614d25d1924c772a03c7e9da7d39bbf329c6bdf9d62e937cc084f2a7985261841afc37c764645a9e5f91b1440b359b904167233077ef84b31770892c8b11c6e10e66407896da09fee33a216db7e14d86fc8cbb9ac87ad08a8dd6d4d76754455ede48b0ed5c984717de020cd45aaefad26f4000ed19165224c18627ed365e18f5c809a0b7166cab8031fffc47f02bf045e4d6c15c4b4798a71daf87c323a7246cf06a10eb2c713ad37235f304a0e81d460973d2d55ed8e63287434b02b7cdf507eb314357de5744ca8135f17bdc412a715f98b7b1bd4d8fe64dc7056d9077dc57fddd5111b277083f69f7468c6c6a0a243fa77d4a70a29adec8c700470337c08f124ddb4b3a422b9882ff7d99a22d24aa1829acb5d8640ed924d97a5fa34caf590206dc49ff507e0b16c3a3923d170af071faf02c50d845fc16af3b857fbe33617b7a6bc618aec8109a26193a7bd36e004651de75fa1123828126b5b9e44426dcb949c41aeb2b77c575ecaed683d318662258eeb8d017262d13dd83f2730cb08f3d5e5e5de9bff429419b5f57b0dcda82674ff731e06f593fad5f4880c8ef13b401bb9f3d8baf06ad8f417a83004626758ea81254355ffbe7558c6c17f2b3ac5f21c26df668e439285abb977e7ac3fbf2b80bb59137ad8f6a223a6b28d8d9ec5d26d5ed1a6090c5135a46fd71bb2a5618aaaacba692fefcf133aecfb7ae648df339b9af83184724cf89e6a1582b12994cd00c3df78a37670b42cc9036346d1d5ef35ecc34c9d363839fb90964a6eb5fa00295d2e8c40b6c3f93dcfd59b13c9f3cf573f07fd0f13c5b80589060f9ba0547d6a1917319b5d57ede9f3d358e3eac5d2f7e32ab38b761aed11878ea258c2df4afb8f088625161ec86b18d53ef9fc74d93eb0fa3ec5a1cd3bf259111b09d8a60baacdbe299dda0737cf8af30ae17ebc16e77dc8faa9a8f85f577304299b1ad3e98fcecd22f4c90245353bcd6190e4a28796a43b34e7e6d2cd2c6056416e7fe17123742d69a3e380c69309a4c26874daaf5029178f360d95852a23ab173977014ef1793c21d0568c9fd81e52991c22849f413e2ad544216db49942275316c8d0bb6c7bf3c881e3531a2e82c760817f022316a416e0bc46923b47a31e5094483b88049a63c07815c87cc938573333c0946297b6e834de3ebc46bbbaa5e7555801c947fbab0f581f42e153e73bb932985c71e725a847e08f0569bc7585448b17092b2772237d338735a415a93e933b3cdc68a3c18205886b017d21463e09af30b1546158efe1f6bdd35e68174e97399e7972d702c5a229e80f9077e597ac419b34752a05c7906b3ad0e07f7d7323d9cfefab58a098f6e8dbd1b2fdab91cd103817bdf83db4e6188ce2873df00c4fdf184f962d6e92e764148b0337d09ae5ddb84c424c94a34522290d7de8bc4883c675648db33747082c23f86413f94c604ebb6d90707b9a3552b4b22dc22e247ca8b74243f65f03fc8a52d895786f83d5937fabb331a20367deca0017e29aa60fa07a8497931c60974595291e40acf922b642db95fa095c43f23e00c77bbaf7e1ed99e07601a2fbf0cc63cb70de425d8c4698c5111fb0cc3b8a2d0fe0b61c2fbac6dc10cf42cb9bb5be4a98095dcc6f1434b19b5e91fdf31570a9771b6ce24a2c762b5ec6808ee7e4fc45f9120b7a5ca737e5c74d9d90fed353b11952edaa631de68453b3d2c34540c0a4744639d7e3a33c1dfe5e2ababb3a05e4b72cdd75e18a68a4c43db2176fac30f8f882f19dac9c7ac10b7d2c2d51c8fb2273d3296ae09cbf6e1beb961787282f45b6d333524ee71098d5d24d111a9c041fc83e2386ff3cb5f604c91f214aa5e738003a75d63f4864248e5284bd31af7e51db1eadcdba69be9b2dbbbc743973c0c0400cc6eca9dae9a83c137350a84ea018d896debed6ce32c2e3ceb7e2283f020ada1aee744c4c27cd7cfd0bce3da3c70dcd4569c31e0fa4d90a316dc056ffe66cdab6752af675dc1a7d5c41d45d4368de53b5f08ab3e974ed7f2ee105b97f991daa5db74fda8a8e7939866dcb5c47a815e2314b7cdfdfe081258f3e7d7189d7351586f1f03aff4c3df7533fc7d9d3bf37dbd8039be203330f357d57e4522199f28bca5def5345a057f95b7166791f143a6a186eaff876c0c6063eb79832b1a009cd831b253056d8c101f82877e4c8bd2e8353a13a14cc86d9f15a69d72f5692e7264e49a5d9f197c4e44153b60eefe32bfdd7864ef6210e568ec9d4c1618b3db001e1bd46857a0d5d8c9aa88b8a2720b65cab8c02f394e34da8daa5b610085ca6e91368f720cf5ecdbd3dee90382c8e1f01ca9f460f8c0177ac409fa77c5968b159a42efc652a0125ce72e4aca5f4c9b6ce45a2917d028b3cd3573c94c4d6b5ad2dc7bd8b27ab15381a12985a0757d2984b9db655604d89302cca53027a0a48bfc882fb32b498bb6796217c589c2b177e934514201137e081c538f359b5bd98d6c289eb09512e2755beac645c97e4c59c261c35694a1efaa1e666c739f3fe75523e9835f90fdf994ceb7a7ae37c2074ab350c2499feec76fb1b25adf99160bf54d79d0b14c617acc41fc90ecc30479fa4f1ad85e69e0f2f71c4aa675e581455565951768ef5efb85424928822f8c6a3318ba00fe5addd56014a3251f565d692b04f10a03a9b813e6468bd9c5a3f840fce9d9ee8053de2178221b069ef6e87e7f2ed509a393c3fd8f50f33d3ab49292f9dc74888a7a4bb87f68907e9a133a3c72542ce973100565ae2aecf9098f84178603181c0c66e58d56840a3c484ab988c50b28cd6c90e626b1cd7efda80757a0fa221daf6960ba7bbe48be68034148a7173970216420368ad11218e479daea0ee70d6e87164c01702b7bbe3f5803b611594f950062f577ecc7b20ea235c4d42dbd2365979d1c2f8f127d1c2228d40c743e967e07816a62ea6cf2f09fbbc378488ee0817eeb57ee673a14f0807d894392d69694546da123be57b7c0b37496ee974401a5715e9dbe428d0b513d28c37935cc9bc1ff3400a10734e8be2391bd01ada9179445893d24e68a8fc513db015617a6be836c3fec9423e251100953c49e9d7bf219af5a1e9c851587b16ba9b82739d7b25fa6df6d52a94bbef8fec8580b310b8ef71c7dbec64814e6d4390bff3477fe7e4ca68185e6eb7daf676853da3cc84584a7cbf51c703ed0fef8cb6615b9bddbfb6e1b718e67580f702d357d8b24800ca801bf795ce45faf2aa394d9a13d45d410c4434ea6956e2c38c54809216705ab6dd2570ca2e016f171378ffa9b06ea78e83873886a962bac35d6332b2578eb6a448f8bb6cbd6690ec7637f268f711425ae4ed1911bb835e811063924ecc84aa2240c7711f168a35ec964ca64b248f7c4fbaf1b9eab33294cc5207ff25bb1323e2f2934d057e558db57e6560cfae79437f1db66b2b130d36122daadee9319252b68c98542d5707d5c31b76c9b72f0cacbc384b530cd606940b74649677f17ec867e7cb5463354f6862e8135e3af059e2c47fd225248dad9ecd453156642f0d1801cbbd015fa545945edfa6de6d62c8207bbd94f91077a1571c5e27517447bd9713c86fa8a0036d03e9a44b91e874563a63e11ce017f31853b3c43d31f82bc4937131b448ef71aa427e42136c2c6204e67f408d173185ad30180f7d540a685559bfeec521cb46165b58fe0db998b74de546fbcc021f4e8de7af7d676f2f2c6e6e61d9cdefeac5b50a97cf69eb69a10db2e7d990909e01f634f3791a6654035b2752eecd47e23dbc98b0b56c414cd58c198a10fb5f113a0f48f4643de9a0958f2f8207d96cd57fdbfd79f1ac87885f59b36a545cce7acf00e100ecd02c112faf3a1b616cae0a308e252b9d0ab8989e397dba60ae3b17235bc8f341867c3fe5f6ebab8262093cdb9906918c108756d6e2055b125646e65670269e7049b0320343f6aa3ee301f6ac8576837ece690d154fe4bd76398a821f2cb2f41c51439155d6308759b8521153e944ac3bf2068b109e6c409fba281462580b3fc069db9c67e06720e0c5a58cc8dd2c0abb2881c168fbc3d3e41393f2e156c83ba70859507e6b3e7cba1bfef80a3a3d966189b413438740d06ae8ddf7242834ac3f34edcfc5270ecd941d551670a52cdc91711a8cc26903cb23026a518b783b63500197616d39298b1050424db2a9c2d4e700e34749e9e451d5a00b561f208843154f45c5e2e290cef31616580a90001bd2c0c14b34972dbb0cc719288693238a3979baff6fe08ecfb2c71af7f7108102e630665dfe8ffc8c839bd9240ca55efc07fb315ef26135e9eccac744d1d2686842b08ca1f32917e70aea0ca27a8a959ab24ecbd645cbac44b07ecc8f5bd5696565a2313a53407bc56652c7087fd64cc5e75c15d8be5de46a39659222b55a36628e897dee183f76c012fea0d271892c8d0c41447ebdd03c968d45d79bea1f3deeef219075c063a621d68bf63461fc2ce27e369942c50c061123268f1252300da0a3aa42ee428c71eed94d9a53f83ff9f54d89bd41055ebc0e149f3d4b0a1106c96141ecb0a6c021a440cbbb7da3e1d8ce4294e80f3dc74c6b69d1b85654eec05c498fab0f62559d92b02b0e3a5d477064adfb3d2392961714c1309fb19cff65f1e0e1f6c423c63f06fd2082f3930eb9e93fbafcadefc5bae15e985f68292ed1a09796cbb39c370102b2c5509a998ac99e6399aaabf5555837aaed260654bcf3f2fb43ec6d6de2de8186f0ba5c09fe506fcb260c15b8d150fb3add95942cb6264c8c34c47ddd27ebde32622be72b6ed663a028ccc765985a2be705fdce371db23a73420f85897a2a30a4857dadf0ee6f97f4f3e1d14c7b8bc8c7e94b45e23ee03a91f80f700f24d19bb020a4cbf96999baecdcab75beb2e30e1462cc5e5557668c303a80c5157f2f8db709ac11e5881278b0da7d7d592b78367a37ad69a98f18f7013074bb773e574d498849e535203e756aaa8524e2adcc252e3a31fa6703162c03b5d662933d8092af8ca77c5e269b0fcafc09fdade1679e190ee50e2314e6b20d64abc7d26d6038b91091148e2c88eb2d81ea25bc82dd2fe08dcc58243884e4ab66274ac9020701b8cb3a5e594365436b08c3eaaebed2ba3d4b045bba32c95318c56c2e5df49fb69ccfacef079785be2df81e9aebc71d62ec6dc934b25f947c5093e2df1cf23d616eaf611ddb626fd13660c375f1cdb3833fc5074a93efc8c3d8da776956ca61002fc259027274bd681bcb020d601cb7d9132727f3107c765cdeae3703ebc9cc2ad2eceb966d34a91b71f4034844b45430907496018ccde3743a9073d5e9ceb20f35f44bd2a57c7a403a7d85f050d2031b89359e86fb947ed9d528561617e04d70494e27d29d2be607b799ce8c0f6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA4.2</title>
      <link href="/2021/12/29/PA4-2/"/>
      <url>/2021/12/29/PA4-2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bffe60605c8cd3d19ff9be544811951713018186c9af92f57e3ed36867f26e52">98c5eac1e431cec725e9b50c1f9552a7cfc86e5f98ff8e04356e5c7ae46d7fa8f85eb2760518ed1a5f34f95580f31276700da2c847e215b5e04ad71cb89036ae1993d869f20c8c1d4a6982d789ecc650f30eb31fc11ff0993a0a113e5804f78099c4e60a7c46a76610630c5a56a2847878f8dad13f0e462a7b63670fcdddd23f3d8dc4b7ae6223bca2ff326c1d31ddcd40f2180ed41403abfbc4743099f9e4a9c2be0eea9284cbfbab71d1b3e1c1781f79a680a5385524db5d15b4076fc6ea9660cd42b85967c9955fb41489f07b9707ee6d0f28831db2245b59fd10de9d9d20d04b808248b67c24e8db6cfc6431921bad3944e68e32fd55a9aa6ff67b7a04d3a4f1c7b82c34faa4f6f2d12fec6204302e52bb4d3f208d91bf118977e6225b18a99b32b76abffd10233c9d289a0c930fdb48276267a1d3cfab0e0daecb6242efecbd8fc2d3e51d688d567d4e066bcd15ae803f5fbeee61e18c0701aa0a3810d65e75fafe82bd915b96797d98fbbf96a3c032c584ca97903a8d5611ce84ac4d195c589a218697fb2a407bfd481b81378bde360c59ea893df0dbd5621990d364b33240184bf0681c51fdb96573ed6738c6a7a477c7857a6a184b33618660c33859f11e0e8c4a30491c63ebfe9e190f390246b423d36748d8f0ed8d89892999e1aa6d460a506b8ebbd6ebd4d4899c7265c20fa179af66900429457e0b06f4139234ff3c16668651350b7f6e3ea4e1aab62b78ed5d3cbf4006adcfbe26401402994df6a40173cdc086702bef8b2cecfb4f3aa0c5ede5c7789322d4297e03cc2b453d1650d7655d5107a55046ebe6a6cca41e5317594b692f3701cb58a62adc4b84a82bbb4d0bf513a02647fe2948e59186610990302d8cd3898a8a4882be56d873dd52ec676be765e6ddacb85a20c304ba0b19adc011cc3d3ded2cc1892459e14f76f22c9d4d5a092e8408e6b92d117d993d3247811da08edda021a3f4d85cc953881bbe275c192ee75fc740338d5f09b27d768ee42052bc59fa7a94d8fdedf5264712c7f16495c191e10fede9ab98ef11765c3d2014c097e81f9767dfbd792c9e68847df72c84b00fd1086d692776b5d13f04b4230e39d0526d11685761ef5529e917604c26d167c6568493343b57c52a176f30ca780f6fb54e6fccd4f4b02b7cec8d0764b3f6aea23cce55ccc0b8f19f4c81c8b2bee48df4e02f76100354ea9f2b900d9278785f9bd8c6f69da63e44f81b1131f04984d8479fdc12edde1669c40763fa4b4734984f393f4a4109431028a88d187c96b586209c7409c587f1d12cf4572d50f9667bd780b701da1cdad88b3f77b0ea2893677cc3749941515fbd92c0558394f70d3924c34c4c8d2841cf647a95575c3476f80333bfb6441ff8d06733c9e67285c38ed4a1a31ddb63c45a8288e7dca17e01da6291d3f51f48ca6f515d92b89c90cf8f28ba9939d8ad9d3503f3c32519e4977474e581c605aaf2ffc8ffcbea6f549c924a4904a027fa466101a014f029ff397d3c2e17c11f03731394e79312e69d75b07f6323027b4640361fc54a9e957a6139a028667e59252e94298c898e7f9451cbaad168c22cfb2f930dc10c75c8490358221d7e4484f7597101a3b76212faf9df432dd46c12cd2dcdc29a0b660683a19a1bdb8dfeee0db671a4352e4d1504a33c509ced72ffea3e9ab71fab913f5e34a6d0a62c74f6d4c1ab6c3fe9ef7b1ab2e35fed30a60d367f3009d5af6ec5a9c86bf1d5a9e77e853222bab2f082a7ac606a3c4f6938c0afb3c8b296ab3dc2521bcbbecb40c61bef6d6587f29cb2d8460b6d822f39667fef5fd7fa85617fa9b9d914d25785cea387c0b8a9df0f0f69fbce6e73c14000e6e4e260eb9a14ff39c8e37c74dc434743a03f08c84ab481d8f45f99acabf11039d42a8554b8d8105fc78b1243c437b970d14f76453341300534b1439198110dabf383453689096ec903580fe851b58c4c71b58b20e847b0fbeda5868d410b067d49535e87b1c51ab1d39664045628aa71bc377eeb3d6e312262066b200d45e960989577a9e3c1b7571be27581bc38a569a3454d9d096dc9de4e53613e4f15c899f9a76e6943517fdfda07429eb92a36a15481d583e2978ca4167da5b0689fbdd282901212a5da00617a68636208141cb362934816196060d95bf9137dfe03029568217d64cd0bd0e13b1b9d52804eed6e6e354fedcc9a86c1c6a440c8bd13bc109667c5da3d7df73c8d5c91e95e21daa1e4c94c29a2d1f3f8ca08931ed55fdd89716e898835472452c8c4dbeba12dfef46ea32503a2268a7818100fdb556e2c09aa3f23f5e228e0a40608d64ef626265b607a166a57dc2d972063be1964f70f01f670563c5ec3fd8eada6a600778209da7e2e6d53d2be6ebd10480d48529d3a92a61bfff351a2e3deadb80774989d241fcde0f0266f3df7bb68f15aab20765257697d10f6228292bf3b6913e103821ddb453813beb8ac2f2daa81a099f0c11b95551ebd96865f596ee296bfef3be93103d5aeceda6657e6dd06bfa6958f89a84ac06ec242fb3c516dec78d6f628ecb1706e94b0c377499c48694c5b7d6afb620a2c3a0ebf0d4bb7d06adfbb09b83ef4106f80190fb1845ab4df76659c30bfcafee47888ec4414f86f9e5a0316c13f7dc90ada8152315b89863987435880376c2da9fc84e772ae80af56ba1bee2420a00ff21b81249e5c9e321e7ac94e95c2365cee37ff4a331e80bbeacf4aba4bd009e8761e5e903792066aa1953ec3bd5927fbc2e722d0dabcc724b2f1be43c8a6d57a7d7d92330a794f4ea054089f6f5c5d966b76d588b0d54de48d23d9377e96aee3c380a0c09b0ae186ce260e91dfff2ecf1f58578c5dfbf7c07925c41b748d92ada0ca0a7749b2c3f021340b54f4c830b86d424a9dfbefdbb85b15076030a72dafc3f12f24fe9ca979ca4334b678e8bc38101585b07df03baad3865dfb1d5e2b4bff9372d3868dd022e7111794cc071480fa975e457a7b6eb633adbe820778898d88a3576e7a91ec44b80e695074592e3f02ad1f94416a70bb8d34ad59dc58327ba511aaada863bb5750437a547c62b6c6d55e03eadfb96c1be7176bae7a17a4a346e2c80607eeda92a8b852f05a3f43ab28c22202bcf1375456369196433ce891b754e648a5310bce4aac989d069230e61191cf6a0d664bb3c842044047e0ef29831df5cb03e09959632e3f4403073fd33e171f883b76db82197acbb27c26f059333ff7c09bb76cb43eae8daf0697b0d1de099262560a050580efc4abdf30caf3929b9af7add1afc2585d8c7625d43ea6ce5981c26a159c6d1d9ff541e4c4dd3616f4548a956bd2dd251ceff276336b605257fd90f114ba763308706c67d798cef23fec053f76390d297b64b04cef4f72e49c59e2ea738b53cf38bfa8d223c1abc4977ef304c6a09d05d8db2fb96a2e5b8cdbaee804716b4838f934b0e3abe98b8ce1a72ee1ae39cb299371c6be032a8a9a1b3e4e23a0661767c68b4b320409acf2635a320b0b4ea9adcde7fa6c3a52cb1c3590bc772713e82308253177d49b1c2057d0e3f3a7f8305eefb12a51fd187ba484f9a4f080b6433ced812c48bb31897f3d5eb2816120fc710193ef2a50f147826f760cd765e011f8904ab27a46613819fecef3361ece655cf794e2cfc0179b9557e5be826cab3cc628ac7095ed39693818a11b7ae6e1484ee7415396c5b2a311abd44f146f21022408c94bd9412c23bd8acfd5525bcffc7a8cb37f86ebae96014d31a5204ae10fedb385b267f9fa58c33fb48080bf35230ecc0ef49c87a491495db413153e41005663a1333244324b1253cdae0ebe1b72f69b7325a9276e593402d5946f61beca223da4904a021e22dbfea21e17d105ef217ab998174b50e541296dc87e7c53e97bee15a770cec61aee0ba10550164061c69866fd7249e66ca9798cdaa580355d7102e848ae5c0035193c04d216e7a808830637525982511257a6b4eaefb56cd7f9bd2bfefe3fea7c1050b0173bb07e4767d05fcae83c8d70e80a2fc99d55657cc54a570d97243bd25c600df99c28bc9c9c80bccd835cf2de8805e497b4c2783289dfdbfdf5f755e897c69231d6219fc2d6eea6331639b732f9986da4d7554095a5f924e4ff31b102206d715408dc230bdfd66dbb1b8097eaaf8733e449a2e2bcc875bab003c011219cd6f80cf242e48e6949ab6ad20e436717b85040833d55c8eefd7bba9447b9bf58f1fe5ba30d7c3f136062118ad78f20cbdacdeb3e05397ba63d9dc54c23eeb26aeb50e76276c3b496e953e00e95c28fe529fd5c038d7ff355904d17c5013db5cca463d2e2f9dd7157d78df8bcad6408627b2890b60cc1fd8c22b61384c75798da84da1f43ad874ee6060c2ff5b57ed1d0deaeb50576d661a98f7709e8b38f9cd6ec872d1aab4d46bd354f451b2f38cedc33dcf267d50037ac244b3c92a5bdc4dad40ea71a1c79ac02618e8b922b981eb22bac4a71fe95fe23f0be1a23914a905034b97fe1a4b38a070a06a79d117df275d303f886639ee825ebc3436c77e1edd7373a82421b68252b5c98e6962c3d44587c261b5414d74a65500481dc306ed204bc5a44538e76170725f814bb6f75b659f9461bc0cbb288695028633b4f4105bef76794c657dfd872932952bd02f4e6e874ef5acfb4b8fb6d08d0ab280bbd9070dc6e2e53c5ea318523d31b97bb7f6b7bb44f4de7bf04f09a02bb8e77a74741642c0f2e61a368f10dbd541bcaebb714e4158a667de30b0eea15ca43340aea2f0f6a1b6aad4103110811399b7e96cb972bbd5b0a14720da0bebed5cb29159223fd29f1fb32a61676945924c430b394913e71c876aadfc4aed55f97405ef85a0f6448568167a7da2bb4baca0d3ea139095fac82f95199cade938e7b61fa0d790171390942236186be3544ba1db3cbd4480057d2a8f0b6bd30f23e840a2bd0d3f5e50533ce4c856cad5e529a4dd29bcc5359ee6761ae04829a21a3481ce16255b41a069ae454d81505ec5f8c39b80e1e5ee79fd5c21c46e31392c5b26f9056d2b76a44677eeb087509a44d6446106090a256334fb9a2a63a0be1e432f020b13a5cacae0358b7b91cbe12cd73b0cc379385182c76a44b14d0f65d6325814fb156f05b964ebf9e90df7e92ec20cb14eda1b853ee917414ed22f7c576249025b18855f880cfc646b60dccdd2a38a5cf8878235fb904fa798a7c8ebbe0ec63c98bac99b27316f637c2efbaaf194bc23a370ef6e88b168daaafdf8ece6b0d0f41ad8261c4cb096ab0fe68b352d5a4637b1734b0132cffab2c4032a39f9ee3d14724787268de1d4a6c8d21ce78b8f104008fe32fad2c41ded84609c0977f5fad0891f008881c7c1d610ec8ab11eeae7fc1a111e77c380a11df5c6714033d7befa16b281facc46027b016d8335483101ed6aa9cfb21efc4310ee9f491e86f4cb899e891a3cfdf6992dbaf8ccc9815e7651e0247ce1b1a7a7e2425ba31f79af02a8d360c36d7591e219f925aac1d965e6172961b35ef86a30b66a1b8b563ab27992b89390a71ad173ee6424699da22bce8803a14b90753b9688efd61bbc39eb76eb14b9c039b2eda936d4ec628118d191d371b1a9a7122a0210cf18abd18797c4e16a2c2c15531083d8e56b28fda7dd1605eb632eca0dcb1b75ada711298a22c3cc0f2e87e30dc24dce9ed57e6a6dee2ef5e1b4117c2d0fc28760067da5d5fdce3dbefa52905e08f61bb8a5030a9781c6fee6b97d1be5495fb84b05a6c1b1d2634491383668645b1fb1f80c7245ca7302e2e38e46aa93d9a5665673a6f111d1211442817f239e3026b42b6fbc38df5498dfc8e2845805c23fdcfce419a1c47cfa05a1f536892d21ef84b1af54aa539eb64574f03d60e90b76a17bfaead05d473e912db233506596d2295e2e41254da9abdeecc979c7fb31e27fc137ba6edc0a85204beee31d69f640b3e8e5d30c6e5e8cf05e84dd371809dc324478ea473fc329e51d5be359ffddddefdfbea889d3df2b6d85c26ddd2c3e85ae8b151b1c6f45fe85ebf5884699175004a4a7e99f0131064dfacda21683caf3a3eeba007b0326a0901f6718e37e54fca46b99fb8e00c7a35013021a4daae2f4ec6fe3e506f37ddde96bf0a7225e811268d9e39029252c35344e558eeb4b55e15105b9886c37fc643b013363fa206fcd4d79d45e0a6fba98751871fd69d170b503c64e1ee9aa0c8d2baf38edb7311c7f1a1e90b9e7ce4fd1a95596d45641ae43294aae0d9f1581324a5ab7567d212f81db7a09f12695df55ef46ecd27011cddb877d558a1bf8c452e2062c1163f7e55262660bc092fa016b9c3f13a12557c434e26113031a2d8e71d91e80e09620f97a1557fd3ef2c83d07449d8346c7839201ac7f261bc5ce5da7a179d0efdde41bd87bf0a578b9476fc1ed434eb5a4e1cbbe005ae4857101cc8b0fdd1361c285166ac04975591203383bd4f3ae0f4e4af233492226e190f390592b9a76ec0ec530bf42b776bae83d1e3e2cb326a0d096a52aace2fd0828e0c91c79104d5d3c6c52659a8dda15a6b0f7d411efad01e1b2d8f8f215fca910c137c7de9fed0acce0fd3bb4ee40f71da3a7ae6dcafa3ca5cfb8212c70528e7004fc4b701f7c93e61e061d7cf2fe0ff3aaf3a0562b53f3e27a68ffa62c196d084d62bbb2b8237710414f3488d6be20b989836c9a24234923dfe38e74f947e1fdc7efba13c2ee7ea641350ac6eb44c995837056ac978dbc0ca71179ab9cf451321cee0926cab1fad2df174c378a9ac0d2bb28eb8e4ae74c11ff46774bbdc5ae4ce7106d2d4ef4326661ba8a10426de8d15faa08ac456fb5124144735bcf208c442e29a5e6efec56f7316f92455807baadc57988c1f51d8a9f4a0198a4a71f64cfae5fd507dfc63ecf52c1ea921b63c36ee0f72131992ca768341d4d3b7f4de20c29cf92f756c1e3a093a1f0c1c096054f0612fd10b445a2079355991ccb1e48739e089b478eb97ea0309375b6bf65168bc768eb9e2ab2dabe2367a11e2aec49ab6b40d59f29df1c1fa5a0ccd63a9d0d4301034b63c353ba7fc558cb79f0387df33652b50ae24dc997caa21cb0421aa7ff5897d8cfea3a91a3e0e408d1c8dbd51ab300599a2313922870ce7eb7dcd099111ea4680c3c04304b59bbe863fcdaaa0ad8fe4245cd8a74ae791f96460d35484fb8d8e3d8a91ab4058ed1d05ab00b2c480b9f4092d98040bb7d3a8ce1b91446cb95a4c230e5c680b85c7f848a43e7bfbd073e388ea756cad4535acfd9d1fca570e7e46aab22ae13966651a2b14575ca93baf100d8db66eec5ad2f407ef74ac45538ba30d27319059da5e54233fad07731d9b56a140159347e523c3aa3c7068752728eeea049e0da6cff40e7c65c9446e3f36b4e939205fd860df9878886a0ad697e40dcc372a1ce61c6d6f42435ea08715f4201c1e5744293cfa10006d31df1deda333a43cfaf550245590f1397555c7aeb7a8f17738b7a1c74ce578b66a92ab4675557fe6919e87b2805c9d89525899cb3ab9db22ed279ddd2333c53745094607af13fe38c0faf0059222ca81debee714df7d671b74d8c184d6768d18aa7c795724786f11093c2e7ea6896ec70a3d7cddcd8070c52a6c40aafcf1f7cefbf8288e12c59a30475de2413d84dc70644f9d3779e746b9b57b16cadd34e5510ee9e57a15fff2c153ba5620c99614e580be9345ac7eba2ab647f99343c07c8b6dceca6327be477145c2780159c3895811a0741eaa8ac21c14632ee6d5d300ec8f9fd67f8af81d6255d17566bb1ab4e218570d02c55466423ca7ffb9a3a16945d9e233a05d49878f78f84066bb6591266d30fff75d430624b15a1c7ee66618519806c4ebd7d0803b5f8814a122a6222c5874baf4c2d20b88cecbc3e19d236a411ab356c0c1fa86f907d78c2672abc7903c5248c6890b93359db8f64a67b830e24beb12a01cc5bcb47b4ae835a3abbcc4c00d40d3c770f43d4f9e83ebd9804908aa30589c87ea0711e4439375f7bc57242222058f988240904a0faa6ee1d3554eb0ecdea5b58993e79daade544ad4aad06f54127bb46d10ca426535d1a111620bb765f62da8534e951ca1825cc88971825bf4d7f5c8ef9541a9e3ba4b9a6bbe425303430cae8c77c86ed641f5eb60376ebdff51b37b51a5f34b8b1eb4237f64bffa6824a02d95b5017d46cb4e5fb651dab1a9eea91a8540f11d7ab6ceebba75b26a5c32acfe61f5baa92787799146a72822979c5e6f2fff51cf6bc295483538fc1e262754b1cd937d4ca6e565f8a748d7520ee7e6149dc91cf25fb40893d771114b5504be85a8294735b184c2d8b06b8b3a533064c47568801f0e9680021b935fe73d2c50371fc07728a5e28877758497ac027d350f2dbb74cb885b8e3166409ed34b2672247a489c05c2f7a1e075c323a121c43b053f79649521967e58ddb2573755b6e8737ac534f621bb5fad07503d22eef716d83225f49f554834be680c3e6c9687d0410c3bb2c8c3d37a57dda1f7628ec16a38c200b9e214b3ea5eb17411291759bf0e64f463c3d560dc5b21e02d99e05279ab893727b3c854bd1ee53d9db564185d1a20c8bdda8d8df095542e430a8b05218bbc6eaaa74c355a1df9f3ea18d0a34ee80d9f273b158c9754539757b0cb0abdde736688e03aad8d47359fa9bc2b82e19faa767425901df704ee93406cbfafbfc043a3b2422dc92c1f6dc9ff3e0ef5a401c04045447df67b7ab974ad82d52322826534538aa9625a30ba17e2b129887733b3a4da8a88397f7a05752849d590746e22dc924144eb537315313d6fdcecd93c01fdd5bc9840b50c6129ea772fb7588980613adce310c6c1acb175aa426c34387f80338082c91617094294cbe51835f379dd04470f03b2dbc8034141a2e3710f7412c76161939b41a2cf09865cd17ee9036e1781797d4f32202fb94426916741678eee5e1c3901e031827b6b538e33e62de300cc751cb51a8b248f3fb57a7b600fcfb4af72cd1091626a79973b859771ae13866c2c03622f21e3dac7eb9aa4a4b6468bc85a6958cf5857ed6858d661733a878a2f224e0b2190fe723674be17cd4bb186672e5a87b1637194b26b74d3b415fc266acb63560523b7e935e657ce0416d22fffbc637c2371cf7eeceaed68eb74084e49d05a9aba88547d9d4df50e17d4294781c68df8e11ec2e286b6b00221010ba576141484310274ca16408f431ee1d5cdc81e1374235f70f6d57c8310da5fc0904a308a34197a5a8eb372937952defabaabf3af05fedbe60fadbb5a4cf889b7567de9543f087cc0d185a8deb13c998db73f552b2628c5b800e12f9c4c10d45ff39f877473488118f8f86f8a4041821eb989a03fe152d4af70588a7251134cd167f24a2971d93e22d17d50aa9d8323f47e1dc4b542a302e7fa83d4bd7caa34b3f01de775cb22f37ff133661f7f481ded441fa2e615a394060ac7d071a4e134db16c4739eb77913f0599e748b2846dc90c8910c6ae60abcb35ad15e591fde15ae2c46731e49989e9c429cc64b5b60a95fec812d0ba52f5674fe1555ac175d008832f6d29bf48d214639045d293090f4e8cba1c1bd0b1a5b2843066b0ebca3dfc85ab5e8734e0852b035f3bd335babce3d656517432f93ffc1b32ecc5b9c10a698ce00aa50bff18fe88ee34b38afc6e56752c688c94bd75720dc3f43d309848278b8eb771f201bbbfc31584a6facc238dbac601f1f70bdf3886db712c1b15b21d35c496dc4bf9b9df22a5a79fb30a0227565b0dc10d785507c9775790962860ab06eb736ec84d47ac46ef39a7233439a6c8d19ac70f984acb0d0e528181eb5970314f308ad368334d4e5464f8771cdb56fbb0824ee3be36523fe90644de164985af5e2f1083e7c63903e6231d8fac53a3324c684353541cbb79c4bf60fed8e60f0b8bdec4703545820bea2e8c8d0774dd5c264cd8eb61a34e8192df2bb72db4e0e9603278ef6051df52e1afe4d9168198dcc6d3d0b56e0e26b59c8ce3f49699e26e3917cf565b495dd0356f6f6391bca17174fb983b7785156757e7f0fe2799cf7865201288ae41b3bab4fee336fbf38ee08ccbbed8de83b907beae8a30c20cfb043a7ff5473d5fcc4d51921b2658bb83aea891559d9a100b3d8391750e1c4da0afe78f7fb447fcee1c300760365813052a014aa8dd0f0aafdeeb35792e08c5332ad85dced0746f22e8e205ab7770e3aae5eabf712f50c5336a166195e6c419b90db4314f448ef77b697ea43d8d075ce62ad44bf75477249e6e1ca19ad4e0da2a47a908b1ba8226a37960f606fe3a67a06ee8fb98e62f5cb3c1a6da157ee0e30fde6a7b84818d1dbedecfd44d6a087e52f562b932704a92719e9bd8c7013f7d9cf06754ef1fadd3a43a4926cf2d16c95f9fed42020b8c4b66df99d68b2282e3e21c34075b51e00247c1103a67e626de034555280a88595126b0fe0d153caf6191f9f87bf0eea4a23a215f5bdfe7bfc024b1716106b975a4fd3420a98c10cb862d065da4e1123cbeb084f94840c75186253775c31e2abed189824b02fd10f0d9426336a1b1b9c3bf2621fa9dd754ca8bf3bced4540cd39b63718735cdc9047a233fdb6c56a35f82b75b610fecd9b0e13e122d17d58bdf8cce1169f12a56be8abc62f66b1e46cb64feec234f819fb4019a650a825de60da92f706beb0872cd2d5389c27b0094d98e10ac9de95c26c2ede243dfc43f5000e6139f00ea18465ab5843184c15e6863c1281db2ecc99ddf26f244cbe241cd028b14f9f04d53e4caa58970020d1e72e817654412dde7b2e0c66c318aa779667ad247f1929b9f013443fabe58cfb2a30c5b721c4690c3987307eb08ec2f207400cbcad94b45fb1105a6aef4f955a7a60edf7b97dc253fd9570bf8287c8443cef6d67b4292a1aa46c8001d9204b5b17eec3f0bfc9f5486cf0a0a1a5d7c26c26a62fc6b65871672485d503c792efc1960256db4f78deebfbc871e56a58b70c1a0010e6754020a769acdb406443b2572d6f855d83d7ed10631283a59d6849fdab8f95eb4063de51e19457cd6a769f94aad0ae64b908c58ec36b79f7c1930db5c228715c7b795a5aadcd3a0074a7a78bef73d5dafc0cfe868104dd973a0888e2db8689cc7358f6567120a613887cfdd32b071f6d5bfda3f9335ba1a4d4a40bf87fa43361a0778b76db00d349f879485e7ea5ef71e0184b9a07588489735faad9da7ea238fc7b09e70be1a4fec81d1b3e6938d868bfb9f582d2ad0ff4322b16e81e8c2d9de9fd927e1b5091c6d065743953e3b889c3eabea9702eec307ed0c48d943e5a273f7fbe47f0e998c4de012ee896b1be615da4cb6e1ecdadd08b429f3df07881176278c994366eeb0d13e87fa25c248a57c984ab190c4dc8d511544e2d79bfa5b72a6a03e7f9ac59c1e6aa5a5dca8080886cde736f6e156dc501ebf7fcf666f9920ca2fa1bb11f473e95b0e9bb7643d0d6db9325a7d7293634ac387c3427dabe87b9a89c8a3301d72becd728ad16747c32bb75e546230410e7092255d622c167b4a2b6a1a5734ff6288781366cad794d20f20254c0e91826eef56eeaf252b55018797943636ec093eb1335e85dd4907d5a54ed2615a74114af561bceacec7e964254924ba4f1c0a04f73aaf2f0022b68c6acf057e9a1a6e6e9336b10fb09cb80dc46856b467262df0669f9c32d4ef81c4d2e0e4ade8c904d7fea8ff03f8ddca77bcedae980a65ef857ff94f88d93159685983cdae47fc3f6e6651406d440cbdbf3f47b5cb4b6541c69714f918111c7f2cf6bf5f1ffc01d02afb61d775d0dd4f7c9b087bce1b6fb93de6eb1b698831d07099f995f80f667c89fc3000d569c10db536901b6b00e6e2b95101d5d24fd6c50be5b646385543eda12d01bd8ed3db1ff1ca9517f510a2671dbcc4941458beeeebaa6693eed2653df38faa32e71a16b28cd7fef63b4bbb19cb25bc102dba6e4d84e760a5deda996a17077255e606f1226024c45bb3cb63c22c5af5a9a1bc28625bc38c11dff331c35151e7582f4eb3f2c3d299b55767e2c40a2367333b035fbff4134afd3ed8e3315b07780c7a3f09fdfd305a2f1e5d56bb3d538500d892c2b7309a6b70740b35526da58b888efd33b0b7d4f46495a9d4cab469c05b157b8bcc7cda409ca01a3b1db9f177ffba7647a905c963aa94b2891515920546c6370c020e42e97a4aadcb696c4fadc65ac1965da4fff2f8d83e9296a9444b124c2b5a2af47d10b7426e16568bc09130250e2e4f5f7d331b8f48400fed44c7a27c896ed819b1666fb03c09441cce199fd24e96c2467b9489c8682ae903dfc1c09f36214646588f12f3532d3ca3c8bfffebea1eabbe16f9d2004449343cd193a41c04218e4f193696a7ae8cdf08ab6828fea0c45a1ea0d805757d645e7089e0197ae953e01af0d5c3b1e3e6f803bf09dc72d996d868b9787cb752693dee12dc6a730f98b1e16b5206cac08643d64f0376c96baceb376e15b8d77c7d0a1df83c9dbaa91cf841c9dd05203d37fd2c43e5e0c1881d3777c74537405f20a6a5bb22a7bb42cd99e19394d074ac27a85b020f99440d5af5d59ae2a15bd6c12f8bfe72620b2e097214276ce7f13bb493035870257dfff52f11b9bc8e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA4.1</title>
      <link href="/2021/12/15/PA4-1/"/>
      <url>/2021/12/15/PA4-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-kcontext-的实现"><a href="#1-kcontext-的实现" class="headerlink" title="$(1)kcontext$的实现"></a>$(1)kcontext$的实现</h3><p>实现相对简单<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kcontext</span></span><br><span class="line">Context * ctx = (Context*)(kstack.end - <span class="keyword">sizeof</span>(Context)); <span class="comment">// 创建context</span></span><br><span class="line">ctx-&gt;mepc = (<span class="keyword">uintptr_t</span>)entry; <span class="comment">// 设置返回地址</span></span><br><span class="line"><span class="keyword">return</span> ctx;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>在$loader.c$创建函数<code>context_kload</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_kload</span><span class="params">(PCB *pcb, <span class="keyword">void</span> (*entry)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// creat a kernel stack</span></span><br><span class="line">    Area kstack;</span><br><span class="line">    kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">    kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set pcb context pointer as the return value of kcontext</span></span><br><span class="line">    pcb-&gt;cp = kcontext(kstack, entry, arg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-am-asm-trap"><a href="#2-am-asm-trap" class="headerlink" title="$(2)am_{-}asm_{-}trap$"></a>$(2)am_{-}asm_{-}trap$</h3><div class="note primary"><p>在$pa3.1$的实现$mret$指令时，我们已经对汇编代码进行解读，里面涉及的关键点就是寄存器$a_0$, 从$am_{-}asm_{-}trap$跳转到$handle$函数之前，<code>mv a0 ,sp</code>将参数地址写到$a_0$. 我们当时并没有讲到返回值的处理问题。实际上，$a_0$也是函数调用返回值的存放位置，因此从$handle$回到$am_{-}asm_{-}trap$之后，添加<code>mv sp a0</code>就可以了。</p></div><h3 id="3-hello-fun-添加-arg"><a href="#3-hello-fun-添加-arg" class="headerlink" title="$(3)hello_{-}fun$添加$arg$"></a>$(3)hello_{-}fun$添加$arg$</h3><div class="note info"><p>$context$的若干$GPR$的作用在$pa3$里面已经很清楚了，此处做一个总结：</p><ul><li>$GPR1\ gpr[17]\ a7$  $type$</li><li>$GPR2\ gpr[10]\ a0$  第一个参数</li><li>$GPR[3|4]\ gpr[11|12]\ a[11|12]$  第二、三个参数</li><li>$GPRX\ gpr[10]\ a0$  返回值</li></ul></div><p>作如下的代码修改：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kcontext</span></span><br><span class="line">  <span class="keyword">if</span>(arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ctx-&gt;GPR2 = (<span class="keyword">uintptr_t</span>)arg;</span><br><span class="line">  &#125;<span class="comment">//传参,记得判断！NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init_proc</span></span><br><span class="line">context_kload(&amp;pcb[<span class="number">0</span>], hello_fun, <span class="string">&quot;THe 1st&quot;</span>);</span><br><span class="line">context_kload(&amp;pcb[<span class="number">1</span>], hello_fun, <span class="string">&quot;THe 2st&quot;</span>);</span><br></pre></td></tr></table></figure><br>实现效果：<br><img src="/2021/12/15/PA4-1/1.png" alt></p><div class="note warning"><p>尝试将$nanos-lite/src/main.c$的$yield$注释掉，看看会出现什么现象。<br>上述代码只是将$hello_{-}fun$的入口地址和参数放在内核区域，并没有马上跳转到$hello_fun$流程如下：<br><img src="/2021/12/15/PA4-1/12.png" alt></p></div><h3 id="4-用户进程"><a href="#4-用户进程" class="headerlink" title="$(4)$用户进程"></a>$(4)$用户进程</h3><h4 id="4-1-ucontext-和-context-uload-的实现的实现"><a href="#4-1-ucontext-和-context-uload-的实现的实现" class="headerlink" title="$(4.1)ucontext$和$context_{-}uload$的实现的实现"></a>$(4.1)ucontext$和$context_{-}uload$的实现的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Context *<span class="title">ucontext</span><span class="params">(AddrSpace *as, Area kstack, <span class="keyword">void</span> *entry)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// almost the same as kcontext</span></span><br><span class="line">  Context * ctx = (Context*)(kstack.end - <span class="keyword">sizeof</span>(Context));</span><br><span class="line">  ctx-&gt;mepc = (<span class="keyword">uintptr_t</span>)entry;</span><br><span class="line">  assert(ctx != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_uload</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the app entry</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> entry = loader(pcb, filename);</span><br><span class="line">  <span class="comment">// 用内核区保存上下文结构体，入口保存在内核区</span></span><br><span class="line">  Area kstack;</span><br><span class="line">  kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE; </span><br><span class="line"></span><br><span class="line">  pcb-&gt;cp = ucontext(<span class="literal">NULL</span>, kstack, (<span class="keyword">void</span>*)entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把栈顶位置设置到GPRx中</span></span><br><span class="line">  <span class="keyword">void</span>* Ustack_Top = heap.end;</span><br><span class="line">  pcb-&gt;cp-&gt;GPRx = (<span class="keyword">uintptr_t</span>)(Ustack_Top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note primary"><p><code>_start</code>修改?!<br>Nanos-lite把栈顶位置设置到GPRx中, 上述代码已经实现了.但是这个返回值要怎么处理呢?<br>查看$crt0/start$的$riscv32.S$, 在跳转到<code>call_main</code>之前添加<code>mv sp, a0</code>就可以将返回值设置到栈指针寄存器<code>sp</code>了.<br>让我们再来梳理一下流程:<br><img src="/2021/12/15/PA4-1/13.png" alt><br>这样一来,我们就可以看到二者”同时运行”的状态了.</p></div><h4 id="4-2-用户进程的参数"><a href="#4-2-用户进程的参数" class="headerlink" title="$(4.2)$用户进程的参数"></a>$(4.2)$用户进程的参数</h4><h5 id="1-参数解析"><a href="#1-参数解析" class="headerlink" title="$(@1)$参数解析"></a>$(@1)$参数解析</h5><div class="note info"><p><code>char ** argc | char * argv[]</code><br>参考:<a href="https://stackoverflow.com/questions/29338321/how-initialize-char-const-argv-in-c">https://stackoverflow.com/questions/29338321/how-initialize-char-const-argv-in-c</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_proc()</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">&quot;--skip&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span>&#125;;</span><br><span class="line">  context_uload(&amp;pcb[<span class="number">1</span>], <span class="string">&quot;/bin/pal&quot;</span>, argv, envp);</span><br></pre></td></tr></table></figure></p></div><p>需要认真理解:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">|               |</span><br><span class="line">+---------------+ &lt;---- ustack.end</span><br><span class="line">|  Unspecified  |</span><br><span class="line">+---------------+</span><br><span class="line">|               | &lt;----------+</span><br><span class="line">|    string     | &lt;--------+ |</span><br><span class="line">|     area      | &lt;------+ | |</span><br><span class="line">|               | &lt;----+ | | |</span><br><span class="line">|               | &lt;--+ | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|  Unspecified  |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|     NULL      |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|    ......     |    | | | | |</span><br><span class="line">+---------------+    | | | | |</span><br><span class="line">|    envp[1]    | ---+ | | | |</span><br><span class="line">+---------------+      | | | |</span><br><span class="line">|    envp[0]    | -----+ | | |</span><br><span class="line">+---------------+        | | |</span><br><span class="line">|     NULL      |        | | |</span><br><span class="line">+---------------+        | | |</span><br><span class="line">| argv[argc-1]  | -------+ | |</span><br><span class="line">+---------------+          | |</span><br><span class="line">|    ......     |          | |</span><br><span class="line">+---------------+          | |</span><br><span class="line">|    argv[1]    | ---------+ |</span><br><span class="line">+---------------+            |</span><br><span class="line">|    argv[0]    | -----------+</span><br><span class="line">+---------------+</span><br><span class="line">|      argc     |</span><br><span class="line">+---------------+ &lt;---- cp-&gt;GPRx</span><br><span class="line">|               |</span><br></pre></td></tr></table></figure><br>解析参数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">context_uload</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the app entry</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> entry = loader(pcb, filename);</span><br><span class="line">  <span class="comment">// 用内核区保存上下文结构体，入口保存在内核区</span></span><br><span class="line">  Area kstack;</span><br><span class="line">  kstack.start = pcb-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  kstack.end = pcb-&gt;<span class="built_in">stack</span> + STACK_SIZE; </span><br><span class="line"></span><br><span class="line">  pcb-&gt;cp = ucontext(<span class="literal">NULL</span>, kstack, (<span class="keyword">void</span>*)entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize stack end by new_page</span></span><br><span class="line">  <span class="keyword">void</span>* Ustack_end = new_page(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 字符串区域的开始地址, 可以自己决定String_Area_Size,比如512,1024</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> String_Area_Start = (<span class="keyword">uintptr_t</span>)(Ustack_end - String_Area_Size);</span><br><span class="line">  <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the value of argc and store it directly at Addr : heap.end - Usr_Stack_Size</span></span><br><span class="line">  <span class="keyword">int</span> * argc = (Ustack_end - Usr_Stack_Size);</span><br><span class="line">  *argc = <span class="number">0</span>; <span class="comment">//initialization</span></span><br><span class="line">  <span class="keyword">while</span>(argv[*argc] != <span class="literal">NULL</span>)(*argc)++;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// to load the arg vector, recall that argv_0, argv_1 ... are char *</span></span><br><span class="line">  <span class="comment">// argv_0 在argc的上面一个单元位置</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> * argv_0 = Ustack_end - Usr_Stack_Size + <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> One_String_Size = <span class="number">16</span>; <span class="comment">// decide by you own</span></span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)*argv_0 = (<span class="keyword">uintptr_t</span>)<span class="literal">NULL</span>; <span class="comment">// empty string </span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *argc; i++) &#123;</span><br><span class="line">      *(argv_0 + i) = String_Area_Start + offset; <span class="comment">// 让argv_i指向对应的字符串的开始位置</span></span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(String_Area_Start + offset), argv[i]); <span class="comment">// 将argc[i]复制到指定区域</span></span><br><span class="line">      offset += One_String_Size;   </span><br><span class="line">    &#125;</span><br><span class="line">    *(argv_0 + *argc) = (<span class="keyword">uintptr_t</span>)<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO : envp is just the same</span></span><br><span class="line">  Log(<span class="string">&quot;Successfully load the arguments!&quot;</span>);</span><br><span class="line">  pcb-&gt;cp-&gt;GPRx = (<span class="keyword">uintptr_t</span>)(Ustack_end - Usr_Stack_Size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note info"><p>修改Navy中_start的代码, 把argc的地址作为参数传递给call_main()?!<br>我们已经不止一次提到参数传递了,对于$riscv32$, $a_0$一方面作为context的返回值$GPRx$, 另一方面又可以直接作为参数(当只有一个参数时),因此<code>riscv32.S</code>的<code>_start</code>并不需要修改,或者你可以认为<code>mv a0 a0</code>.<br>至于在<code>call_main</code>解析参数,这并没有什么难的.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> argc = *args;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to get the arg vector</span></span><br><span class="line"><span class="keyword">char</span> *argv[argc];</span><br><span class="line"><span class="keyword">uintptr_t</span> * argv_0 = args;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= argc; i++) &#123;</span><br><span class="line">    argv[i - <span class="number">1</span>] = (<span class="keyword">char</span>*)(* (argv_0 + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simply ignore the envp since it is useless</span></span><br><span class="line"><span class="keyword">char</span> *empty[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">environ = empty;</span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv, empty));</span><br><span class="line">assert(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p></div><h5 id="2-execve"><a href="#2-execve" class="headerlink" title="$(@2)execve$"></a>$(@2)execve$</h5><p>$nanos-lite$的<code>Sys_execve</code>,实现比较简单.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果它执行成功, 就不会返回到当前程序中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sys_execve</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv [], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过fs_open()来进行检查.</span></span><br><span class="line">  <span class="comment">// 如果需要打开的文件不存在, 就返回一个错误的值, 此时SYS_execve返回-2</span></span><br><span class="line">  <span class="keyword">int</span> fd = fs_open(filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    Log(<span class="string">&quot;No such file or directory: %s&quot;</span>, filename);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将current的context信息修改</span></span><br><span class="line">  context_uload(current, filename, argv, envp);</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line">  yield();<span class="comment">// 进程调度</span></span><br><span class="line">  panic(<span class="string">&quot;Should not reach here!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note success"><p>请仔细阅读<code>exec-test</code>的测试代码,解释为什么<code>init_proc</code>的调用如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> argv[] = &#123;<span class="string">&quot;/bin/exec-test&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> envp[] = &#123; <span class="literal">NULL</span>&#125;;</span><br><span class="line">context_uload(&amp;pcb[<span class="number">1</span>], <span class="string">&quot;/bin/exec-test&quot;</span>, argv, envp);</span><br></pre></td></tr></table></figure><br>最后,测试成功的图片如下:<br><img src="/2021/12/15/PA4-1/14.png" alt></p></div></p><h5 id="2-pal-—skip"><a href="#2-pal-—skip" class="headerlink" title="$(@2)pal —skip$"></a>$(@2)pal —skip$</h5><p>在<code>builtin-sh.cpp</code>的cmd处理函数添加处理代码:<br>这里简化处理了,只是考虑了只有一个参数的情况.即使是多个参数,也是类似的处理.<br>至于在pal的main函数怎么处理<code>--skip</code>参数,这个就很简单了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sh_handle_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> pathname[<span class="number">16</span>], argv_0[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to get the pathname | filename</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(; i &lt; <span class="built_in">strlen</span>(cmd); i++) &#123;</span><br><span class="line">     <span class="keyword">if</span>(cmd[i] != <span class="string">&#x27; &#x27;</span>)pathname[i] = cmd[i];</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">        pathname[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(cmd[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; <span class="built_in">strlen</span>(cmd))i++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// to get the argv[0]</span></span><br><span class="line">  <span class="keyword">int</span> break_i = i;</span><br><span class="line">  <span class="keyword">for</span>(; i &lt; <span class="built_in">strlen</span>(cmd) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    argv_0[i - break_i]= cmd[i];</span><br><span class="line">  &#125;</span><br><span class="line">  argv_0[i - break_i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * argv[Max_Arg_Nr] = &#123;argv_0, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  execvp(pathname, argv);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning"><p>使用了<code>execvp</code>的前提是正确设置env参数,请在<code>builtin-sh.cpp</code>的<code>builtin_sh_run</code>函数的<code>while</code>循环之前添加:<br><code>setenv(&quot;PATH&quot;, &quot;/usr/bin:/bin&quot;, 0);</code></p></div><br><div class="note primary"><p>尽管能够满足最低要求了,但还是感觉上面的实现不太满意?!<br>这里给出一份实现更加优美的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> split[<span class="number">2</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sh_handle_cmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// since cmd is end with &#x27;\n&#x27;, we have a pretreatment</span></span><br><span class="line">  <span class="keyword">char</span> cmd_cpy[<span class="number">32</span>],pathname[<span class="number">16</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(cmd_cpy, cmd);</span><br><span class="line">  cmd_cpy[<span class="built_in">strlen</span>(cmd) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> argc = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">char</span>* argv[Max_Arg_Nr] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *token;</span><br><span class="line">  token = strtok(cmd_cpy, split);</span><br><span class="line">  <span class="keyword">while</span>(token != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(pathname, token);</span><br><span class="line">      argc = <span class="number">0</span>;</span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      argv[argc++] = token;</span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, split);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  execvp(pathname, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><h3 id="5-Pal-续"><a href="#5-Pal-续" class="headerlink" title="$(5)Pal$续"></a>$(5)Pal$续</h3><div class="note success"><p>尚未实现的<code>SDL_GetKeyboardState</code>返回空指针,是程序越界的原因.<br>在具体实现之前,我们看一下源码是怎么实现这个函数的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Uint8 *</span></span><br><span class="line"><span class="function"><span class="title">SDL_GetKeyboardState</span><span class="params">(<span class="keyword">int</span> *numkeys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SDL_Keyboard *keyboard = &amp;SDL_keyboard; <span class="comment">//SDL_keyboard是一个全局数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numkeys != (<span class="keyword">int</span> *) <span class="number">0</span>) &#123;</span><br><span class="line">        *numkeys = SDL_NUM_SCANCODES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyboard-&gt;keystate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可见这个函数不需要调用<code>NDL_PollEvent</code>.<br>在 navy 的<code>event.c</code>里作如下修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Key_Nr sizeof(keyname) / sizeof(keyname[0])</span></span><br><span class="line"><span class="keyword">uint8_t</span> Key_State[Key_Nr];</span><br></pre></td></tr></table></figure><br>并在<code>SDL_PollEvent</code>函数识别到非空键盘事件之后对<code>Key_State</code>进行更新.<br>至此, $Pal$调试完毕.</p></div>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十次OJ</title>
      <link href="/2021/12/07/%E7%AC%AC%E5%8D%81%E6%AC%A1OJ/"/>
      <url>/2021/12/07/%E7%AC%AC%E5%8D%81%E6%AC%A1OJ/</url>
      
        <content type="html"><![CDATA[<h2 id="A-加密"><a href="#A-加密" class="headerlink" title="A. 加密"></a>A. 加密</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>题目描述<br>现在有一个这样的加密算法，将原文数字$w$加密为密文$c$：</p><p>Step 1：在$[10^5,10^9]$随机的选择一个正整数$x$。</p><p>Step 2：找到最大质数$p$，满足$p\leq x$。</p><p>Step 3：找到最小质数$q$，满足$q &gt; x$。</p><p>Step 4：令$n=p\cdot q$。</p><p>Step 5：计算$w^{2^{30} + 3}\ mod \ n$得到$c$。</p><p>现在给你密文$c$，以及上述算法过程中的$n$，你需要还原原文$w$的值。保证$0\leq w &lt; n$。<br><span id="more"></span><br>输入格式<br>第一行一个正整数$T$，表示测试组数。</p><p>接下来$T$行，每行两个正整数$n,c$，保证$10^{10} \leq n \leq 10^{18}, 1\leq c &lt; n$</p><p>输出格式<br>共$T$行，第$i$行一个正整数，表示第$i$组测试的答案。</p><p>样例<br>Input<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">181857896263</span> <span class="number">167005790444</span></span><br><span class="line"><span class="number">218128229323</span> <span class="number">156323229335</span></span><br><span class="line"><span class="number">352308724847</span> <span class="number">218566715941</span></span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175267324024</span></span><br><span class="line"><span class="number">209603568635</span></span><br><span class="line"><span class="number">282077284785</span></span><br></pre></td></tr></table></figure><br>数据范围与提示<br>对于$50\%$的数据， $1\leq T \leq 10$。</p><p>对于$100\%$的数据，$1 \leq T \leq 10^5$。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>以下$e, d$分别代表$RSA$加密和解密的钥值。<br>本题相当于$RSA$加密机制中告诉了公钥对$(n, e = 2^{30} +3)$, 假设已经求出$p, q$, 那么$d = e^{-1}\ mod\ (\phi(n))$。<br>因此$w = c^d\ mod n$<br><div class="note info"><p>题目的前3步使得$n$的分解代价不会太大：$q-p$的值不会太大，并且二者距离$\sqrt n$不会太大。</p></div><br>$code_1$:这里求$w = c^d\ mod n$用了题目$C$的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line">ll n, c, w;</span><br><span class="line"><span class="keyword">const</span> ll e = (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) + <span class="number">3</span>;</span><br><span class="line">ll p, q, d, phi;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速乘法</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_mul_mod</span><span class="params">(ll x, ll y, ll mod)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = (ret + x)%mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = (x + x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用的快速乘的快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_power_mod</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = <span class="built_in">qucik_mul_mod</span>(ans, a, mod);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        a = <span class="built_in">qucik_mul_mod</span>(a, a, mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;y = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line">y -= (a/b) * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算a关于mod的乘法逆元</span></span><br><span class="line"><span class="function">ll <span class="title">mod_reverse</span><span class="params">(ll a, ll mod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际上就是调用拓展的欧拉函数</span></span><br><span class="line">    <span class="comment">//记b = mod</span></span><br><span class="line">    <span class="comment">//等价于求出ax + by = 1的x</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, mod, x, y);</span><br><span class="line">    <span class="comment">// To make sure x is positive</span></span><br><span class="line">    <span class="keyword">return</span> (x%mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出p, q</span></span><br><span class="line">        p = (ll)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">double</span>)n);</span><br><span class="line">        <span class="keyword">while</span>(n%p != <span class="number">0</span>)p++;</span><br><span class="line">        q = n/p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出phi</span></span><br><span class="line">        phi = (p - <span class="number">1</span>)*(q - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求逆元</span></span><br><span class="line">        d = <span class="built_in">mod_reverse</span>(e, phi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//w = c^d mod n</span></span><br><span class="line">        w = <span class="built_in">qucik_power_mod</span>(c, d, n);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码会超时$50\%$的测试点。下面利用中国剩余定理优化。<br>$w\equiv c^d\ mod \ n$等价于方程组：<br>$\begin{cases} w \equiv c^d\ mod p\\w \equiv c^d\ mod q\end{cases}$<br>根据费马小定理：$c^d\ mod\ p = c^{d\ mod(p-1)}\ mod\ p =c_1$,<br>$c^d\ mod\ q = c^{d\ mod(q-1)}\ mod\ q=c_2$<br>记$t_1 = q^{-1}mod\ p, t_2 = p^{-1}mod\ q$，那么<br>$w = [ q(t_1  c_1\mod p)\mod n +p(t_2 c_2\mod q)\mod n]\mod n$<br><div class="note info"><p>证明：记$w = Ap + Bq$, 因为$w&lt; n$, 所以$A &lt; q, B &lt; p$.<br>$\because w\equiv Bq\mod p$, 所以$B\equiv wp^{-1}\mod q$,所以$B=wp^{-1}\mod q$, 同理，$A=wq^{-1}\mod p$<br>$\therefore w = [(wq^{-1}\mod p)\times p + (wp^{-1}\mod q)\times q ]\mod n$</p></div><br>$code_2$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">LL n, c, w, p, q, d;</span><br><span class="line"><span class="keyword">const</span> LL e = <span class="number">1073741827</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">LL <span class="title">Fast_MUl</span><span class="params">(LL a, LL b, LL mod)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    LL base = a%mod;</span><br><span class="line">    <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1LL</span> != <span class="number">0</span>) </span><br><span class="line">            res = (res*base)%mod;</span><br><span class="line">        base = (base*base)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">x = <span class="number">1</span>;y = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line">y -= (a/b) * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mod_reverse</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,n,x,y);</span><br><span class="line">    x = ((x%n) + n)%n;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">        q = (LL)<span class="built_in">sqrtl</span>((<span class="keyword">long</span> <span class="keyword">double</span>)n);</span><br><span class="line">        <span class="keyword">while</span> (n%q != <span class="number">0</span>) q++;</span><br><span class="line">        p = n/q; <span class="comment">//找到p, q</span></span><br><span class="line"></span><br><span class="line">        LL phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>);</span><br><span class="line">        d = <span class="built_in">mod_reverse</span>(e, phi);<span class="comment">//获得逆元</span></span><br><span class="line">        </span><br><span class="line">        LL c1 = <span class="built_in">Fast_MUl</span>(c, d%(p<span class="number">-1</span>), p);</span><br><span class="line">        LL c2 = <span class="built_in">Fast_MUl</span>(c, d%(q<span class="number">-1</span>), q);</span><br><span class="line"></span><br><span class="line">        LL t1 = <span class="built_in">Fast_MUl</span>(q, p<span class="number">-2</span>, p);</span><br><span class="line">        LL t2 = <span class="built_in">Fast_MUl</span>(p, q<span class="number">-2</span>, q);</span><br><span class="line"></span><br><span class="line">        w = ((c1*t1)%p*q%n + (c2*t2)%q*p%n)%n;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;w&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B-可以看见的点"><a href="#B-可以看见的点" class="headerlink" title="B. 可以看见的点"></a>B. 可以看见的点</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>题目描述:<br>给你一个$n \times n$的网格，任意一点和$(0,0)$连线，可以组成一条直线，前面的点可以挡住后面的点，问你能看到的点到底有多少个？</p><p>输入格式:<br>读入一行一个数，表示$n$</p><p>输出格式:<br>输出一行一个数，表示答案</p><p>样例:<br>样例1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure></p><p>样例2<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><br>数据范围与提示:<br>$n\leq 100000$<br>题目实际上就是问在这个网格上有多少种不同的斜率</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>显然有如下事实:<br>点$(a, b)$不与其他任一点共线的充分必要条件是$gcd(a, b)$.所以这道题实际上就是求方格互质点对$(a, b)$的数目.</p><p>最暴力的做法是枚举点对,即$ans = \sum_{(a,b)}gcd(a, b)==1$,但显然会超时.</p><p>考虑方格的右半边$a &lt; b$, $ans’ = \sum_{i}\sum_{j &lt; i}gcd(j, i)==1, (1)$.<br>对于某一个固定的$i$, $\sum_{j &lt; i}gcd(j, i)==1$的含义实际上就是$\phi(i)$, 因此$(1)$可以写作$ans’ = \sum_{i}\phi(i)$。其中$\phi(i)$为欧拉函数.<br>$ans$和$ans’$的关系是$ans  =2ans’+3$.加3的原因是特殊考虑斜率为1, 斜率为0(方格的下边界), 斜率为无穷(方格的左边界)的三条直线.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> is_prime[N];</span><br><span class="line">ll phi[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">phi[i] = i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">phi[i] -= <span class="number">1</span>; <span class="comment">//对于质数：phi(n) = n - 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) &#123;</span><br><span class="line">is_prime[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//对于非质数，根据欧拉函数的公式求算欧拉函数的值</span></span><br><span class="line">phi[j] = phi[j] * (i - <span class="number">1</span>) / i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)ans += phi[i];</span><br><span class="line">ans = ans*<span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note info"><p>以上的做法的埃式筛求$\phi(i)$。实际上我们还可以利用线性筛求$\phi(i)$。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, prime[N];</span><br><span class="line"><span class="keyword">bool</span> is_prime[N];</span><br><span class="line">ll phi[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(is_prime, <span class="literal">true</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(is_prime));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">phi[i] = i - <span class="number">1</span>; <span class="comment">//对于质数：phi(n) = n - 1</span></span><br><span class="line">prime[++cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">is_prime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] != <span class="number">0</span>) phi[i * prime[j]] = phi[i] * phi[prime[j]]; <span class="comment">//欧拉函数的积性性质</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">phi[i * prime[j]] = phi[i] * prime[j]; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)ans += phi[i];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="number">2</span> * ans + <span class="number">3</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><h2 id="C-POWERMOD"><a href="#C-POWERMOD" class="headerlink" title="C. POWERMOD"></a>C. POWERMOD</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>题目描述<br>在Miller-Rabin算法中需要计算$powermod(a, b, m) = a^b\ mod\ m$，请你实现这个函数</p><p>输入格式<br>输入一行三个数 $a,b,m$</p><p>输出格式<br>输出一行一个数，即$a^b\ mod\ m$</p><p>样例<br>样例输入1<br><code>2 10 1000</code><br>样例输出1<br><code>24</code><br>数据范围与提示<br>对100%的数据，$1 \le a \le 10^{18}, 0 \le b \le 10^{18}, 1 \le m \le 10^{18}$<br>注意$m$的范围，考虑从快速幂变成快速乘</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll a, b, mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求算(x * y)%mod</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_mul_mod</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ret = (ret + x)%mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = (x + x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿造快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qucik_power_mod</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = <span class="built_in">qucik_mul_mod</span>(ans, a); <span class="comment">//ans = (ans * a)%mod;</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">        a = <span class="built_in">qucik_mul_mod</span>(a, a); <span class="comment">//a = (a * a)%mod;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;mod;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">qucik_power_mod</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第10次OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab4</title>
      <link href="/2021/12/04/Lab4/"/>
      <url>/2021/12/04/Lab4/</url>
      
        <content type="html"><![CDATA[<p>实现<strong>组相联</strong>,<strong>写回</strong>的$cache$.</p><h3 id="1-变量声明和初始化"><a href="#1-变量声明和初始化" class="headerlink" title="$(1)$变量声明和初始化"></a>$(1)$变量声明和初始化</h3><p>每一行的结构:<br><img src="/2021/12/04/Lab4/23.png" alt><br><div class="note primary"><p>$Cache$的总行数为$Cache$的数据容量除以一个$BLOCK$的大小，比如$SIZE=16KB = 2^{14}B$,$BLOCK_{-}SIZE=64B$,<br>那么总的行数为$2^{8}$行。对于4路组连而言，每一组有4行， 因此总的组数为 $2^6$,也即<code>GROUP_WIDTH = 6; GROUP_SIZE = 1 &lt;&lt; 6;</code></p><p>对于每一个主存地址，其划分如下：<br><img src="/2021/12/04/Lab4/24.png" alt><br>其中块号由tag和组号组成.</p></div><br><span id="more"></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个组有多少行，比如4路组相联，那么ASS_SIZE = 4; 2路组相联，ASS_SIZE = 2;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> ASS_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总的组数目，每一个组有ASS_SIZE行</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> GROUP_WIDTH, GROUP_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个行的组成，valid位，标记位，数据（一个BLOCK）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid, dirty;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[BLOCK_SIZE];</span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个组的组成，由若干行组成</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    cache_line cl[<span class="number">4</span>];</span><br><span class="line">&#125; cache_group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> cache_group* Cache;</span><br></pre></td></tr></table></figure><p>根据上述定义,我们不难有以下的初始化过程:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GROUP_WIDTH = total_size_width - BLOCK_WIDTH - associativity_width;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//总的组数目</span></span><br><span class="line">    GROUP_SIZE = <span class="number">1</span> &lt;&lt; GROUP_WIDTH ;</span><br><span class="line">    </span><br><span class="line">    Cache = (cache_group*)<span class="built_in">malloc</span>((GROUP_SIZE + <span class="number">1</span>) * <span class="keyword">sizeof</span>(cache_group));</span><br><span class="line"></span><br><span class="line">    ASS_SIZE = <span class="number">1</span> &lt;&lt; associativity_width;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-cache-read"><a href="#2-cache-read" class="headerlink" title="$(2)cache_{-}read$"></a>$(2)cache_{-}read$</h3><p>读写的替换采用随机替换:<br><code>static inline uint32_t replace(uint32_t n) &#123; return rand() % n; &#125;</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">cache_read</span><span class="params">(<span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//分别获得地址所对应的组号,标志位和块号</span></span><br><span class="line">  <span class="keyword">uint32_t</span> group_num = (addr &gt;&gt; BLOCK_WIDTH) &amp; (GROUP_SIZE - <span class="number">1</span>),</span><br><span class="line">           tag = addr  &gt;&gt; (BLOCK_WIDTH + GROUP_WIDTH),</span><br><span class="line">           Block_Num = addr  &gt;&gt; BLOCK_WIDTH;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> valid; <span class="comment">// 有效位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> shift = ( addr &amp; (BLOCK_SIZE - <span class="number">1</span>) ); <span class="comment">// 块内偏移量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">uint32_t</span> * Data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所在的组是否有标记跟自己一样的</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ASS_SIZE; i++)&#123;</span><br><span class="line"></span><br><span class="line">    valid = Cache[group_num].cl[i].valid;</span><br><span class="line">    <span class="keyword">if</span>(Cache[group_num].cl[i].tag == tag &amp;&amp; valid) &#123;</span><br><span class="line">         <span class="comment">// 数据在cache中,取出,返回</span></span><br><span class="line">          Data = (<span class="keyword">void</span>*)Cache[group_num].cl[i].data + (shift &amp; ~<span class="number">0x3</span>);</span><br><span class="line">          <span class="keyword">return</span> *Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> rt = replace(ASS_SIZE); <span class="comment">// replace_target</span></span><br><span class="line">  <span class="comment">// 并不是每一个被替换的cache块都需要写回内存,需要判断dirty</span></span><br><span class="line">  <span class="keyword">if</span>(Cache[group_num].cl[rt].dirty) &#123;</span><br><span class="line">    <span class="comment">// be carefull about the replace_target&#x27;s block number</span></span><br><span class="line">      mem_write((Cache[group_num].cl[rt].tag &lt;&lt; GROUP_WIDTH) | group_num,</span><br><span class="line">              Cache[group_num].cl[rt].data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the new Block</span></span><br><span class="line">  mem_read(Block_Num, Cache[group_num].cl[rt].data);</span><br><span class="line">  Cache[group_num].cl[rt].valid = <span class="literal">true</span>;</span><br><span class="line">  Cache[group_num].cl[rt].tag = tag;</span><br><span class="line">  Cache[group_num].cl[rt].dirty = <span class="literal">false</span>; </span><br><span class="line">  <span class="comment">// recall that when data is loaded from mem to cache, ditry is set to 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Data = (<span class="keyword">void</span>*)Cache[group_num].cl[rt].data + (shift &amp; ~<span class="number">0x3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> *Data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary"><p>如何在已经知道块内偏移量的情况下访问<code>uint8_t</code>的数组元素,<code>mem.c</code>的<code>mem_uncache_read</code>和<code>mem_uncache_write</code>给了很大的提示.尝试将上面代码的修改为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read:</span></span><br><span class="line">shift &gt;&gt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> Data[shift];</span><br><span class="line"><span class="comment">// write:</span></span><br><span class="line">shift &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">Data[shift] = data &amp; wmask;</span><br></pre></td></tr></table></figure><br>并解释为什么这样会出错.</p></div></p><h3 id="3-cache-write"><a href="#3-cache-write" class="headerlink" title="$(3)cache_{-}write$"></a>$(3)cache_{-}write$</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分别获得地址所对应的组号和标志位</span></span><br><span class="line">  <span class="keyword">uint32_t</span> group_num = (addr &gt;&gt; BLOCK_WIDTH) &amp; (GROUP_SIZE - <span class="number">1</span>),</span><br><span class="line">           tag = addr  &gt;&gt; (BLOCK_WIDTH + GROUP_WIDTH),</span><br><span class="line">           Block_Num = addr  &gt;&gt; BLOCK_WIDTH;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// the target data to write with mask</span></span><br><span class="line">  data &amp;= wmask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> valid;</span><br><span class="line">  <span class="keyword">uint32_t</span> shift =  addr &amp; (BLOCK_SIZE - <span class="number">1</span>) ; <span class="comment">// 块内偏移量，</span></span><br><span class="line">  <span class="keyword">uint32_t</span> * Data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否在cache当中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ASS_SIZE; i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在cache当中，那么直接写，并且修改dirty位</span></span><br><span class="line">    valid = Cache[group_num].cl[i].valid;</span><br><span class="line">    <span class="keyword">if</span>(Cache[group_num].cl[i].tag == tag &amp;&amp; valid) &#123;</span><br><span class="line">          Data = (<span class="keyword">void</span>*)Cache[group_num].cl[i].data + (shift &amp; ~<span class="number">0x3</span>);</span><br><span class="line">          *Data = (*Data &amp; ~wmask) | data; <span class="comment">// be carefull</span></span><br><span class="line">          Cache[group_num].cl[i].dirty = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果不在cache当中，我们直接替换掉该组的随机一行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> rt = replace(ASS_SIZE); <span class="comment">// replace_target</span></span><br><span class="line">  <span class="keyword">if</span>(Cache[group_num].cl[rt].valid &amp;&amp; Cache[group_num].cl[rt].dirty) &#123;</span><br><span class="line">    mem_write((Cache[group_num].cl[rt].tag &lt;&lt; GROUP_WIDTH) | group_num,</span><br><span class="line">              Cache[group_num].cl[rt].data);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  mem_read(Block_Num, Cache[group_num].cl[rt].data);</span><br><span class="line">  Data = (<span class="keyword">void</span>*)Cache[group_num].cl[rt].data +(shift &amp; ~<span class="number">0x3</span>);</span><br><span class="line">  *Data = (*Data &amp; ~wmask) | data;</span><br><span class="line">  Cache[group_num].cl[rt].tag = tag;</span><br><span class="line">  Cache[group_num].cl[rt].valid = <span class="literal">true</span>;</span><br><span class="line">  Cache[group_num].cl[rt].dirty = <span class="literal">true</span>; <span class="comment">//刚从内存载入cache的块数据被改写,所以需要将dirty位改为 1 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success"><p>你也可以考虑实现如直相联,写通,非写分配…</p></div>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3-3(2)</title>
      <link href="/2021/12/02/PA3-3-2/"/>
      <url>/2021/12/02/PA3-3-2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-NSlider-NJU-Slider"><a href="#1-NSlider-NJU-Slider" class="headerlink" title="$(1)NSlider (NJU\ Slider)$"></a>$(1)NSlider (NJU\ Slider)$</h3><div class="note danger"><p>本小节的重要参考网站:<a href="https://wiki.libsdl.org/">https://wiki.libsdl.org/</a></p></div><h4 id="1-1-SDL-UpdateRect"><a href="#1-1-SDL-UpdateRect" class="headerlink" title="$(1.1)SDL_{-}UpdateRect$"></a>$(1.1)SDL_{-}UpdateRect$</h4><div class="note info"><p>$pdf$的生成：将$PA2$的幻灯片截图得到两种$png$，然后再转$pdf$就可以了。<br>脚本运行出错的解决方法：$overstackflow$上面有解答.</p></div><p>将<code>nslider</code>添加到$Makefile$里的$APP$变量。<br><div class="note primary"><p><code>void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h)</code>的作用是将画布 s 渲染到系统屏幕上，画布的左上角坐标为$(x, y)$,<br>目前直接调用<code>NDL_DrawRect(s-&gt;pixels, x, y, w, h);</code>就可以了,不过需要特判<code>w = 0 &amp;&amp; h = 0</code>的情况,将二者改为<code>s-&gt;w</code>和<code>s-&gt;h</code>.</p></div><br><span id="more"></span><br><div class="note warning"><p>前面我们提到映射的问题,这里将<code>NDL_DrawRect</code>作如下修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">   lseek(fbdev, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) * (x + (y + i) * screen_w), SEEK_SET);</span><br><span class="line">   write(fbdev, pixels + i * w , <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) * w);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>offset</code>是如何映射的呢?这显然不难理解 :<br>$x = offset \% screen_{-}w,\ \ y = offset / screen_{-}w$.<br>只是在文件中,需要考虑<code>sizeof(uint32_t)</code>,在<code>device.c</code>里面注意解析映射的正确性.<br>映射法则对应的<code>fb_write</code>的写法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fb_write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于把buf中的len字节写到屏幕上offset处. </span></span><br><span class="line">  <span class="comment">// 先从offset计算出屏幕上的坐标,然后调用IOE来进行绘图. </span></span><br><span class="line">  <span class="keyword">int</span> real_len = len / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">  <span class="keyword">int</span> real_offset = offset / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">  <span class="keyword">int</span> screen_w = <span class="number">0</span>, screen_h = <span class="number">0</span>;</span><br><span class="line">  screen_wh(&amp;screen_w, &amp;screen_h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *pixels = (<span class="keyword">void</span> *)buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start_y = real_offset / screen_w, start_x = real_offset % screen_w;</span><br><span class="line"></span><br><span class="line">  io_write(AM_GPU_FBDRAW, start_x, start_y , pixels, real_len, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> real_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><h4 id="1-2-SDL-WaitEvent"><a href="#1-2-SDL-WaitEvent" class="headerlink" title="$(1.2)SDL_{-}WaitEvent$"></a>$(1.2)SDL_{-}WaitEvent$</h4><p>用于<strong>等待</strong>一个事件. 你需要将NDL中提供的事件封装成SDL事件返回给应用程序.<br>实现逻辑相对简单,既然是等待,注意用$while$判断.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_WaitEvent</span><span class="params">(SDL_Event *event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>], k_state[<span class="number">4</span>], k_code[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!NDL_PollEvent(buf, <span class="keyword">sizeof</span>(buf)))<span class="keyword">continue</span>;</span><br><span class="line">    TODO();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-MENU"><a href="#2-MENU" class="headerlink" title="$(2)MENU$"></a>$(2)MENU$</h3><h4 id="2-1-SDL-FillRect"><a href="#2-1-SDL-FillRect" class="headerlink" title="$(2.1)SDL_{-}FillRect$"></a>$(2.1)SDL_{-}FillRect$</h4><p>$TODO()$</p><h4 id="2-2-SDL-BlitSurface"><a href="#2-2-SDL-BlitSurface" class="headerlink" title="$(2.2)SDL_{-}BlitSurface$"></a>$(2.2)SDL_{-}BlitSurface$</h4><div class="note danger"><p>From wiki:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The width <span class="keyword">and</span> height in srcrect determine the size of the copied rectangle.</span><br><span class="line"><span class="function">Only the position is used in the <span class="title">dstrect</span> <span class="params">(the width <span class="keyword">and</span> height are ignored)</span>.</span></span><br><span class="line"><span class="function">Blits with negative dstrect coordinates will be clipped properly.</span></span><br><span class="line"><span class="function">If srcrect is <span class="literal">NULL</span>, the entire surface is copied. </span></span><br><span class="line"><span class="function">If dstrect is <span class="literal">NULL</span>, then the destination <span class="title">position</span> <span class="params">(upper left corner)</span> <span class="title">is</span> <span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span>.</span></span><br></pre></td></tr></table></figure></p></div><p>据此不难写出该函数的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wid , height, src_x, src_y, dst_x, dst_y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part(1): check the srcrect</span></span><br><span class="line"><span class="keyword">if</span>(srcrect == <span class="literal">NULL</span>)&#123; wid = src-&gt;w; height = src-&gt;h; src_x = src_y = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; wid = srcrect-&gt;w; height = srcrect-&gt;h; src_x = srcrect-&gt;x; src_y = srcrect-&gt;y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part(2): check the dstrect</span></span><br><span class="line"><span class="keyword">if</span>(dstrect == <span class="literal">NULL</span>)&#123; dst_x = dst_y = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; dst_x = dstrect-&gt;x; dst_y = dstrect-&gt;y; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// part(3): format</span></span><br><span class="line"><span class="keyword">if</span>(src-&gt;format-&gt;BitsPerPixel == <span class="number">32</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span>* src_pixels = (<span class="keyword">uint32_t</span>*)src-&gt;pixels;</span><br><span class="line">  <span class="keyword">uint32_t</span>* dst_pixels = (<span class="keyword">uint32_t</span>*)dst-&gt;pixels;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wid; j++)</span><br><span class="line">    <span class="comment">// 二维化一维</span></span><br><span class="line">      dst_pixels[(i + dst_y) * dst-&gt;w + j + dst_x] = src_pixels[( i + src_y )*src-&gt;w + j + src_x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-Flappy-Bird"><a href="#3-Flappy-Bird" class="headerlink" title="$(3)Flappy\ Bird$"></a>$(3)Flappy\ Bird$</h3><p>$TODO()$</p><h3 id="4-Pal"><a href="#4-Pal" class="headerlink" title="$(4)Pal$"></a>$(4)Pal$</h3><div class="note danger"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UpdateRect</span></span><br><span class="line"><span class="keyword">if</span>(s-&gt;format-&gt;BitsPerPixel == <span class="number">8</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    SDL_Palette * palette = s-&gt;format-&gt;palette; <span class="comment">// 取色板</span></span><br><span class="line">    SDL_Color color;</span><br><span class="line">    <span class="keyword">uint32_t</span>* pixels = <span class="built_in">malloc</span>(w * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)); <span class="comment">//存放某一行的颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次只是画一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">        TODO();</span><br><span class="line">      &#125;</span><br><span class="line">    ConvertPixelsARGB_ABGR(pixels, pixels, w); <span class="comment">//将该行的颜色进行正确排列,因为从取色板中取出的颜色顺序需要处理</span></span><br><span class="line">    NDL_DrawRect(pixels, x, y + i , w, h); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>等等,<code>malloc</code>之后没有<code>free</code>?em这个$bug$…<br>至于<code>SDL_BlitSurface</code>和<code>SDL_FillRect</code>的<code>src-&gt;format-&gt;BitsPerPixel = 8</code>的情况,就交由你自己处理好啦.</p></div><div class="note info"><p>$pal$确实不是很好调试.即使是正确写完sdl的三个函数,游戏运行时依旧会”莫名其妙”地越界.<br>请尝试在游戏源码里面插入<code>printf</code>,找到越界的原因.这一部分还是挺有意思的,请尽量自己动手,如果实在想不出,有关$pal$的剩余部分,请移步至$PA4.1$.</p></div><h3 id="5-NTerm"><a href="#5-NTerm" class="headerlink" title="$(5)NTerm$"></a>$(5)NTerm$</h3><p>$nterm$完善似乎没什么困难的,在$Pa4.1$中,我们稍微做了一点补充.</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.3(1)</title>
      <link href="/2021/11/06/PA3-3/"/>
      <url>/2021/11/06/PA3-3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="$(1)$文件系统"></a>$(1)$文件系统</h2><div class="note primary"><p>需要阅读的重要文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.h <span class="comment">//自行添加fs_XXX函数声明</span></span><br><span class="line">fs.c <span class="comment">//特别是结构体Finfo和file_table，在这个文件我们需要添加各种fs_XXX函数实体</span></span><br><span class="line">files.h</span><br></pre></td></tr></table></figure></p></div><span id="more"></span><h3 id="1-1-loader-c"><a href="#1-1-loader-c" class="headerlink" title="$(1.1)loader.c$"></a>$(1.1)loader.c$</h3><p>在<code>loader.c</code>将<code>fs.h</code>包含进来，将<code>fs_XXX</code>函数声明放在<code>fs.h</code>里面。<br>$Pa3.3$的$ramdisk.img$不再向之前一样只是包含一个可执行文件，因此<code>loader.c</code>需要跟<code>fs_XXX</code>协作完成在$Pa3.2$里面做的事情——将指定文件的segment加载到内存空间。<br>流程图：<br><img src="/2021/11/06/PA3-3/5.png" alt><br>有关载入$segment$和系统调用的问题这里<font color="red">暂时搁置</font>。<br><div class="note info"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">2</span> <span class="function">open</span></span><br><span class="line"><span class="function">The <span class="title">open</span><span class="params">()</span> system call opens the file specified by pathname.The file descriptor is used in</span></span><br><span class="line"><span class="function">subsequent system <span class="title">calls</span> <span class="params">(read(<span class="number">2</span>), write(<span class="number">2</span>), lseek(<span class="number">2</span>), fcntl(<span class="number">2</span>),etc.)</span> to refer to the open file.</span></span><br></pre></td></tr></table></figure><p>由此可见open()函数就是为后续文件的读写操作做铺垫。<br>返回值：成功则返回文件描述符，失败则返回-1,在$Pa$里，你可以用<code>assert</code>处理失败的情况。<br>总而言之，<code>fs_open()</code>做的事情就是在<code>file_table</code>里面进行检索。</p></div></p><h3 id="1-2-open-offset"><a href="#1-2-open-offset" class="headerlink" title="$(1.2)open_{-}offset$"></a>$(1.2)open_{-}offset$</h3><p>将<code>open_offset</code>添加到<code>Finfo</code>结构体里。在$Pa$里，<code>open_offset</code>是每一个文件的属性，用来指示当前的读取开始位置相对于文件起始位置的偏移量。<code>fs_open</code>函数调用的时候，该值被初始化为 0。</p><h3 id="1-3-lseek"><a href="#1-3-lseek" class="headerlink" title="$(1.3)lseek$:"></a>$(1.3)lseek$:</h3><div class="note warning"><p><code>size_t lseek(int fd, size_t offset, int whence);</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">man lseek</span></span><br><span class="line"><span class="function"><span class="title">lseek</span><span class="params">()</span> repositions the file offset of the open file description</span></span><br><span class="line"><span class="function">       associated with the file descriptor fd to the argument offset</span></span><br><span class="line"><span class="function">       according to the directive whence as follows:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_SET</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to offset bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_CUR</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to its current location plus offset </span></span><br><span class="line"><span class="function">              bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       SEEK_END</span></span><br><span class="line"><span class="function">              The file offset is <span class="built_in">set</span> to the size of the file plus offset</span></span><br><span class="line"><span class="function">              bytes.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><br><code>fs_lseek</code>所需要做的就是根据<code>whence</code>的值分分以上三种情况对<code>file_table[fd].open_offset</code> 进行修改。后面会对<code>loader.c</code>如何使用<code>fs_lseek</code>进行说明</p></div><h3 id="1-4-read"><a href="#1-4-read" class="headerlink" title="$(1.4)read$:"></a>$(1.4)read$:</h3><p><code>size_t read(int fd, void *buf, size_t len);</code><br><div class="note warning"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">man read</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> attempts to read up to count bytes from file descriptor fd</span></span><br><span class="line"><span class="function">       into the buffer starting at buf.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       On files that support seeking, the read operation commences at</span></span><br><span class="line"><span class="function">       the file offset, <span class="keyword">and</span> the file offset is incremented by the number</span></span><br><span class="line"><span class="function">       of bytes read.  If the file offset is at <span class="keyword">or</span> past the end of file,</span></span><br><span class="line"><span class="function">       no bytes are read, <span class="keyword">and</span> <span class="title">read</span><span class="params">()</span> returns zero.</span></span><br></pre></td></tr></table></figure><p>根据这个描述，<code>fs_read</code>在完成读取任务之后(即调用<code>ramdisk_read</code>)还需要修改<code>open_offset</code>，并且还需要进行一定的错误判断。请仔细阅读<code>read</code>的返回值说明。<code>fs_write</code>和<code>fs_read</code>类似，只是<code>fs_write</code>不需要修改<code>open_offset</code>。</p></div><br>回到<code>loader.c</code>的<code>segment</code>的加载问题，<code>fs_lseek</code>和<code>fs_read</code>在<code>loader.c</code>的具体工作如下：</p><ul><li><code>fs_lseek()</code>将<code>open_offset</code>设置为<code>ph[i]</code>的开始位置：<br><code>fs_lseek(fd, ph[i].p_offset, SEEK_SET);</code></li><li><code>fs_read()</code>将第$i$个$segment$加载：<br><code>fs_read(fd,(void *)ph[i].p_vaddr, ph[i].p_memsz);</code></li><li>最后不要忘记将必要的内存空间清 0。(未初始化的全局变量为 0 )</li></ul><div class="note success"><p>前面将了这么多，所做的事情跟$Pa3.2$并无本质区别，甚至连加载方式都如出一辙。<br>修改<code>pro.c</code>的<code>init_proc()</code>，调用<code>naive_uload(NULL, &quot;/bin/hello&quot;);</code>， 如果运行效果跟$Pa3.2$的一样，那么说明你加载成功了。你也可以试试加载<code>dummy</code>.</p></div><h2 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="$(2)$系统调用"></a>$(2)$系统调用</h2><p>待更新</p><h2 id="3-IOE"><a href="#3-IOE" class="headerlink" title="$(3)IOE$"></a>$(3)IOE$</h2><h3 id="3-1-serial"><a href="#3-1-serial" class="headerlink" title="$(3.1)serial$"></a>$(3.1)serial$</h3><p>在将串口抽象为文件之前，<code>SYS_write</code>将<code>stdout</code>和<code>stderr</code>和其他文件区别对待。<br>之前：<br><img src="/2021/11/06/PA3-3/h6.png" alt><br>现在：<br><img src="/2021/11/06/PA3-3/h7.png" alt></p><p>这样的话，$fs_{-}write$需要添加如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fd == FD_STDIN || fd == FD_STDOUT || fd == FD_STDERR)&#123;</span><br><span class="line">      <span class="keyword">return</span> file_table[fd].write(buf, <span class="number">0</span>, len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>在<code>file_table</code>里面将<code>FD_STDOUT ，FD_STDERR</code>的<code>invalid_write</code>改为<code>serial_write</code>。至于<code>serial_write</code>的实现，直接使用<code>putch</code>就可以。</p><h3 id="3-2-gettimeofday"><a href="#3-2-gettimeofday" class="headerlink" title="$(3.2)gettimeofday$"></a>$(3.2)gettimeofday$</h3><p>还记得在$Pa2.3$应用程序是怎么获取时间的吗？$am_{-}test$里的$rtc.c$作为基于$AM$运行的应用程序，它获得$update-time$的方式自然是通过$AM$提供的接口$io_{-}read$, $OS$是基于$AM$的特殊的程序，它获取$update-time$的方式跟$rtc.c$是一样的。</p><div class="note primary"><p><code>man gettimeofday</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval *<span class="keyword">restrict</span> tv, struct timezone *<span class="keyword">restrict</span> tz)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">               <span class="keyword">time_t</span>      tv_sec;     <span class="comment">/* seconds*/</span></span><br><span class="line">               <span class="keyword">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">           &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">               <span class="keyword">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>返回值：成功为0, 失败为-1。<br>在<code>nanos-lite/../syscall.c</code>定义上述两个结构体，其中的<code>time_t,suseconds_t</code>直接用<code>long</code>代替。<br>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SYS_gettimeofday</span><span class="params">(timeval *tv, timezone* tz)</span> </span>&#123;</span><br><span class="line">       tv-&gt;tv_usec = io_read(AM_TIMER_UPTIME).us; <span class="comment">//这样看来跟rtc.c是一样的嘛！！</span></span><br><span class="line">       tv-&gt;tv_sec = tv-&gt;tv_usec / <span class="number">1000000</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><p>增加测试<code>time-test</code>?, 如何写测试代码，这里就不再赘述了，值得一提的是，类似于<code>file-test</code>,我们也需要在<code>Makefile</code>里添加<code>time-test</code>，这样子<code>make update</code>之后<code>files.h</code>就会多出<code>time-test</code>， 接着<code>naive_uload(NULL, &quot;/bin/time-test&quot;);</code>就可以了。<br><div class="note info"><p><code>uint32_t NDL_GetTicks();</code><br>在<code>NDL.c</code>添加<code>gettimeofday</code>的头文件<code>sys/time.h</code>，至于<code>NDL_GetTicks()</code>，这是很简单的事情。<br>使用<code>time-test</code>测试<code>NDL_GetTicks</code>的时候，除了<code>main.c</code>添加<code>NDL.h</code>,还要记得在<code>Makefile</code>里面添加<code>LIBS = libndl</code>。(请参考<code>event-test</code>的文件组织结构)</p></div></p><h3 id="3-3-key-event"><a href="#3-3-key-event" class="headerlink" title="$(3.3)key_{-}event$"></a>$(3.3)key_{-}event$</h3><p>请仔细阅读$am_{-}test$里面的<code>keyboard.c</code>。<br>在具体编写代码之前，让我们先来梳理一下<code>event-test</code>里的<code>NDL_PollEvent(char *buf, int len);</code>的大概调用过程:<br><img src="/2021/11/06/PA3-3/7.png" alt><br><div class="note primary"><p>又是$io_{-}read$?<br>是的，还是之前那句话，$OS$作为基于$AM$的特殊的应用程序，跟设备打交道还是要通过<br>$io_{-}read|write$。<br>上面的调用过程不完全准确，在<code>read</code>之前，我们需要通过<code>open(&quot;/dev/events&quot;)</code>获得<code>file descriptor</code>。</p></div><br><div class="note info"><ul><li>实现层级1：<br>首先在<code>NDL.c</code>的<code>NDL_PollEvent</code>调用<code>open</code>函数，获得<code>file descriptor</code>, 接着调用<code>read(fd, buf, len)</code>, 根据<code>read</code>的返回值是否为0确定<code>NDL_PollEvent</code>的返回值为0或者1.<br>$remark:NDL.c$需要添加<code>open</code>的头文件<code>fcntl.h</code>。(这一点是通过<code>man 2 open</code>获知的)</li><li>实现层级2：<br>在<code>file_table</code>添加<code>{&quot;/dev/events&quot;, 0, 0, events_read, invalid_write}</code>，注意到读取函数句柄为<code>events_read</code>;<br>区别于普通文件没有读写指针，在<code>fs_read</code>需要判断当文件的的读指针不为空时，直接调用该函数的读指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(file_table[fd].read != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> file_table[fd].read(buf, <span class="number">0</span>, len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>这样的话，上述流程图就差<code>events_read</code>的实现了。请参考$am_{-}test$里面的<code>keyboard.c</code>，自行实现<code>events_read</code>。</li><li>实现效果：<br><img src="/2021/11/06/PA3-3/8.png" alt="图一" style="zoom:100%;"></li></ul></div></p><h3 id="3-4-vga"><a href="#3-4-vga" class="headerlink" title="$(3.4)vga$"></a>$(3.4)vga$</h3><div class="note info"><p>不要一上来就敲代码？！<br>首先让我们先来梳理一下大概的测试流程：<br><code>void *bmp = BMP_Load(&quot;/share/pictures/projectn.bmp&quot;, &amp;w, &amp;h);</code>将图片的长度和宽度存入<code>w, h</code>, 并且将图片相关的像素信息按照行优先的顺序存储在bmp所指向的连续的内存空间。<br>之后<code>NDL_OpenCanvas(&amp;w, &amp;h);</code>打开画布，在该函数我们获得了系统屏幕的长宽.<br>再接下来<code>NDL_DrawRect(bmp, 0, 0, w, h);</code>， 这里0,0代表的是图片的左上角是系统屏幕的原点， 该函数需要将<code>bmp</code>的像素信息写入指定位置。</p></div><h4 id="3-4-1-NDL-OpenCanvas"><a href="#3-4-1-NDL-OpenCanvas" class="headerlink" title="$(3.4.1)NDL_{-}OpenCanvas$"></a>$(3.4.1)NDL_{-}OpenCanvas$</h4><p>暂时忽略<code>if (getenv(&quot;NWM_APP&quot;))</code>分支，我们需要填充的内容写在<code>else</code>分支里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/dispinfo&quot;</span>,<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 获得文件描述符</span></span><br><span class="line">read(fd, buf, <span class="keyword">sizeof</span> (buf)); <span class="comment">//读取屏幕信息</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">&quot;WIDTH:%d\nHEIGHT:%d&quot;</span>, &amp;screen_w, &amp;screen_h);  <span class="comment">// 获取系统屏幕大小</span></span><br></pre></td></tr></table></figure><br><div class="note primary"><p><code>open</code>的流程：<br><img src="/2021/11/06/PA3-3/10.png" alt><br><code>read</code>的流程：<br><img src="/2021/11/06/PA3-3/11.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispinfo_read</span></span><br><span class="line"><span class="keyword">int</span> wid = io_read(AM_GPU_CONFIG).width;</span><br><span class="line"><span class="keyword">int</span> height = io_read(AM_GPU_CONFIG).height;  </span><br><span class="line"><span class="built_in">sprintf</span>((<span class="keyword">char</span>*)buf, <span class="string">&quot;WIDTH:%d\nHEIGHT:%d&quot;</span>, wid, height); <span class="comment">// 按照格式转化为字符串</span></span><br></pre></td></tr></table></figure></div></p><h4 id="3-4-2-NDL-DrawRect"><a href="#3-4-2-NDL-DrawRect" class="headerlink" title="$(3.4.2)NDL_{-}DrawRect$"></a>$(3.4.2)NDL_{-}DrawRect$</h4><p>像素信息按行优先排列：<br><img src="/2021/11/06/PA3-3/12.png" alt></p><p><font color="read">$Hope:$每次写入一行像素信息</font><br>这里先贴出$code$,再逐一解释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NDL_DrawRect</span></span><br><span class="line">fbdev = open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// to get the file descriptor</span></span><br><span class="line"><span class="comment">// part(1)</span></span><br><span class="line"><span class="keyword">uint32_t</span> fb[screen_h][screen_w];</span><br><span class="line">  <span class="comment">// 注意是行优先</span></span><br><span class="line"><span class="comment">// to rearrage the storing structure</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j ++)</span><br><span class="line">            fb[i][j] = pixels[i * h + j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// part(2)</span></span><br><span class="line"><span class="comment">// 每次画一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    lseek(fbdev, (x &lt;&lt; <span class="number">16</span>) | (y + i) , SEEK_SET); </span><br><span class="line">    write(fbdev, fb[i] , draw_w);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>$part(1)$是不难理解的：因为$pixels$是一维数组，为了方便使用，第一部分将像素信息按照行优先存储在一个二维数组当中。$fb[i]$存储的就是第$i$行的像素信息。<br><div class="note warning"><p>$part(2)$：<br><code>lseek(fbdev, (x &lt;&lt; 16) | (y + i) , SEEK_SET);</code>的作用就是为<code>write</code>做铺垫，告诉<code>write</code>渲染的起点位置，也就是这一行要从那个位置“画”起。<br><!-- ![]() --></p><p>我们希望<code>write</code>在得到<code>offset</code>之后能够唯一确定$start_{-}x, start_{-}y$, 这其实就是一一映射!<font color="red"> 映射的方法有很多种</font>，这里采用的是将高16位映射为$start_{-}x$, 低16位映射为$start_{-}y$。<br>映射方式自然决定了<code>init_fs</code>的写法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_fs</span></span><br><span class="line"><span class="keyword">int</span> wid = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">screen_wh(&amp;wid, &amp;height); <span class="comment">// 自行定义</span></span><br><span class="line"><span class="keyword">int</span> fbdev = fs_open(<span class="string">&quot;/dev/fb&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">file_table[fbdev].size = (wid &lt;&lt; <span class="number">16</span>)|height;</span><br></pre></td></tr></table></figure><br>至于<code>fb_write</code>，无非就是调用<code>io_write</code>，具体可以参考<code>am-test</code>里的<code>video.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fb_write</span></span><br><span class="line"><span class="keyword">uint32_t</span> *pixels = (<span class="keyword">uint32_t</span>*)buf;</span><br><span class="line"><span class="keyword">int</span> start_x = offset &gt;&gt; <span class="number">16</span>, start_y = offset &amp; <span class="number">0x0000ffff</span>; <span class="comment">// 将映射解析</span></span><br><span class="line">io_write(AM_GPU_FBDRAW, start_x, start_y , pixels, len, <span class="number">1</span>, <span class="literal">true</span>); <span class="comment">//写入一行的像素信息</span></span><br><span class="line"><span class="keyword">return</span> len;</span><br></pre></td></tr></table></figure></p></div></p><div class="note success"><p>流程图：<br><img src="/2021/11/06/PA3-3/13.png" alt="图一" style="zoom:75%;"><br><img src="/2021/11/06/PA3-3/14.png" alt="图一" style="zoom:75%;"><br>实现效果图：<br><img src="/2021/11/06/PA3-3/15.png" alt="图一" style="zoom:75%;"></p></div><div class="note warning"><p>后面我们会讲到，上面的$vga$实现是不兼容的——与$navy_{-}app$的$native$不兼容，因为$native$的映射法则与上面定义的不同。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-碎碎念"><a href="#1-碎碎念" class="headerlink" title="$(1)$碎碎念"></a>$(1)$碎碎念</h3><p>在阅读讲义的时候，看到关键的句子一定要及时摘抄下来（留一点印象），阅读代码的时候也可以将讲义中的关键语句作为注释添加在代码中。</p><h3 id="2-native"><a href="#2-native" class="headerlink" title="$(2)native$"></a>$(2)native$</h3><p>学会使用$native$进行架构无关的测试。</p><h3 id="3-学会正确搜索"><a href="#3-学会正确搜索" class="headerlink" title="$(3)$学会正确搜索"></a>$(3)$学会正确搜索</h3><p>有问题直接用google, 不要在baidu上浪费时间.很多问题直接上<code>overstackflow</code>就有答案了.</p><h3 id="4-流程图思维"><a href="#4-流程图思维" class="headerlink" title="$(4)$流程图思维"></a>$(4)$流程图思维</h3><p>用流程图理清函数的调用流程对于理解很有帮助.</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.2</title>
      <link href="/2021/11/06/PA3-2/"/>
      <url>/2021/11/06/PA3-2/</url>
      
        <content type="html"><![CDATA[<p>程序的执行视图<br><img src="/2021/11/06/PA3-2/2.png" alt="图一" style="zoom:60%;"><br>remark:来自袁老师的课件。<br><span id="more"></span></p><h2 id="1-dummy"><a href="#1-dummy" class="headerlink" title="$(1)dummy$"></a>$(1)dummy$</h2><h3 id="1-1-Elf-Ehdr"><a href="#1-1-Elf-Ehdr" class="headerlink" title="$(1.1)Elf_{-}Ehdr$"></a>$(1.1)Elf_{-}Ehdr$</h3><p>终端执行<code>readelf -lh ramdisk.img</code>得到如下信息:<br><img src="/2021/11/06/PA3-2/1.png" alt="图一" style="zoom:80%;"><br><code>elf header</code>的$Entry\ point\ address$:<font color="red">程序执行入口</font><br>以及程序表头的数目等都是比较重要的信息.<br><div class="note primary"><p>使用<code>loader.c</code>前面宏定义的<code>Elf_Ehdr</code>可以将$ramdisk.img$里的程序表头读入:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elf_Ehdr eh;</span><br><span class="line">ramdisk_read(&amp;eh, <span class="number">0</span>, <span class="keyword">sizeof</span>(eh));</span><br></pre></td></tr></table></figure><br>注意这里并没有向物理地址写入指令,我们只是在$ramdisk.img$获取了一点必要的信息.</p><p><font color="red">请仔细阅读$elf.h$的<code>Elf32_Ehdr</code>和<code>Elf32_Phdr</code>两个结构体.</font><br>在获取了<code>Elf_Ehdr</code>的信息之后:<br><code>eh.e_entry</code>可以作为我们$loader.c$作为程序开始执行的地址返回给<code>naive_uload</code>;<br><code>eh.e_phentsize</code>是每一个$program\ header$的大小;<br><code>eh.e_phnum</code>是$program\ header$的数目;<br>还可以通过<code>assert(*(uint32_t *)eh.e_ident == 0x464c457f);</code>对魔数进行识别.</p></div><br><div class="note info"><p>$tips$:<br>在<code>~/.bashrc</code>里面配置环境变量:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=riscv32-nemu</span><br><span class="line">export ISA=riscv32</span><br></pre></td></tr></table></figure><br>如果要用<code>native</code>,那么则需要显式指出,否则终端直接执行<code>make</code>或者<code>make run</code>就可以了.</p></div></p><h3 id="1-2-Elf-Phdr"><a href="#1-2-Elf-Phdr" class="headerlink" title="$(1.2)Elf_{-}Phdr$"></a>$(1.2)Elf_{-}Phdr$</h3><p>好了,现在考虑怎么向物理地址载入$segment$.<br>前面我们提到了<code>e_phnum</code>,根据该值, 定义<code>Elf_Phdr ph[eh.e_phnum];</code></p><p>对于$ph[i]$, 通过<code>ramdisk_read(&amp;ph[i], eh.e_phoff + i*(eh.e_phentsize), eh.e_phentsize);</code>读取第$i$个<code>segment</code>的信息.(<font color="red">注意这里我们依旧没有向物理地址载入$segment$,我们只是获取了该$segment$的信息</font>)<br>根据$ph[i].p_{-}type$是否等于<code>PT_LOAD</code>决定是否加载.<br>如果需要加载:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ramdisk_read((<span class="keyword">void</span> *)ph[i].p_vaddr, ph[i].p_offset, ph[i].p_filesz); <span class="comment">//真正向&quot;物理地址&quot;载入segment</span></span><br><span class="line"><span class="comment">// ph[i].p_offset 代表该segment在文件中的偏移</span></span><br><span class="line"><span class="comment">// ph[i].p_filesz 代表写入的大小</span></span><br></pre></td></tr></table></figure><br>加载$segment$之后，返回$en.e_{-}entry$就可以了。<br>最后不要忘了在<code>void init_proc()</code>里调用<code>naive_uload(NULL, NULL);</code><br><div class="note warning"><p>$dummy$里面有两个需要加载的$segment$,一个是$.text, .rodata$，即只读代码段; 另一个是$.data$等的，即可读写数据段，第二个段的$memsize &gt; filesize$是因为：$.bss$节中的未初始化的全局变量在目标文件不占据磁盘空间，但是在加载到内存的时候则需要给它们分配空间。</p></div></p><h2 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="(2)系统调用"></a>(2)系统调用</h2><div class="note info"><p>需要阅读的重要文件:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navy-apps/libs/libos/src/syscall.c</span><br><span class="line">abstract-machine/am/src/nemu/isa/$ISA/cte.c</span><br><span class="line">nanos-lite/src/irq.c</span><br><span class="line">nanos-lite/src/syscall.c</span><br></pre></td></tr></table></figure></p></div><p>$Pa3.1$对$yield$事件分发的时候，我们提到需要在<code>__am_irq_handle</code>里面根据<code>c-&gt;GPR1</code>判断，如果等于-1的话，那么event识别为$yield$.<br>当<code>c-&gt;GPR1 != -1</code>时，我们暂时将其识别为$syscall$.所以<code>__am_irq_handle</code>里面需要作出修改。</p><p><code>__am_irq_handle</code>接下来会跳转到$irq.c$里面的$do_{-}event$函数，case分支添加$EVENT_{-}SYSCALL$，然后调用$do_{-}syscall()$</p><h3 id="2-1-nanos-lite-src-syscall-c"><a href="#2-1-nanos-lite-src-syscall-c" class="headerlink" title="$(2.1)nanos-lite/src/syscall.c$"></a>$(2.1)nanos-lite/src/syscall.c$</h3><p>请自行添加<code>SYS_exit()</code>和<code>SYS_yield</code>函数，并通过设置<code>c-&gt;GPRx</code>作为返回值。</p><h3 id="2-2-strace"><a href="#2-2-strace" class="headerlink" title="$(2.2)strace$"></a>$(2.2)strace$</h3><p>在<code>nanos-lite/src/syscall.c</code>调用$Log$函数，根据你的需求使用。</p><h3 id="2-3-write"><a href="#2-3-write" class="headerlink" title="$(2.3)write$"></a>$(2.3)write$</h3><p>请仔细阅读<code>man 2 write</code>的内容，重点关注函数的参数以及返回值。</p><p><code>navy-apps/libs/libos/src/syscall.c</code>的<code>_write</code>添加：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> _syscall_(SYS_write, fd, (<span class="keyword">intptr_t</span>)buf, count);</span><br></pre></td></tr></table></figure><br><div class="note primary"><p>请在<code>nanos-lite/src/syscall.c</code>添加<code>SYS_write</code>函数，并且通过case分支调用该函数，调用该函数的参数为$a[1], a[2], a[3]$即<code>c-&gt;GPR2, c-&gt;GPR3, c-&gt;GPR4</code>.返回值存储在<code>c-&gt;GPRx</code>里面(<code>c-&gt;GPRx = SYS_{-}write(...)</code>)</p><p>code:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERROR 2</span></span><br><span class="line"><span class="keyword">if</span>(fd == STDOUT || fd == STDERROR) &#123;</span><br><span class="line">    <span class="comment">// Log(&quot;Stdin or Stdout&quot;); //trace for stdin or stdout</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = buf; i &lt; count; i++, p++) putch(*p);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></div></p><h3 id="2-4-sbrk"><a href="#2-4-sbrk" class="headerlink" title="$(2.4)sbrk$"></a>$(2.4)sbrk$</h3><p>待更新</p><h2 id="3-hello-的执行流程"><a href="#3-hello-的执行流程" class="headerlink" title="$(3)hello$的执行流程"></a>$(3)hello$的执行流程</h2><p><img src="/2021/11/06/PA3-2/3.png" alt><br>至于后面的<code>printf</code>也是类似的道理，只不过多考虑了<code>sbrk</code>。</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3.1</title>
      <link href="/2021/11/06/PA3-1/"/>
      <url>/2021/11/06/PA3-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSR-寄存器"><a href="#1-CSR-寄存器" class="headerlink" title="$(1)CSR$寄存器"></a>$(1)CSR$寄存器</h3><p><code>isa-def.h</code>的<code>CPU_STATE</code>结构体对应了状态机的一部分:通用寄存器$(general\ purpose\ register)$和$pc$. <font color="red">对状态进行扩充,实际上就是添加系统寄存器$SR$</font><br>在<code>riscv32_CPU_state</code>添加:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">rtlreg_t</span> _csr;</span><br><span class="line"> &#125; sysr[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><br>规定: $sysr[0…3]$依次存储$mepc, mstatus, mcause, mtvec$<br><span id="more"></span><br><div class="note info"><p>为了方便后续使用,可以直接在<code>isa-def.h</code>进行宏定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc cpu.sysr[0]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mstatus cpu.sysr[1]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause cpu.sysr[2]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br></pre></td></tr></table></figure></p></div></p><h3 id="2-cte-init"><a href="#2-cte-init" class="headerlink" title="$(2)cte_{-}init$"></a>$(2)cte_{-}init$</h3><p><img src="/2021/11/06/PA3-1/g.png" alt="图一" style="zoom:90%;"><br>上图是初始化$CTE$的过程.$cte.c$主要有以下两个任务:</p><ul><li><code>asm volatile(&quot;csrw mtvec, %0&quot; : : &quot;r&quot;(__am_asm_trap));</code>将异常入口地址写入$mtvec$</li><li>注册回调函数</li></ul><p>$csrw$指令需要我们自己实现,查看<code>nanos-lite-riscv32-nemu.txt</code>的$cte_{-}init$部分的汇编代码, <code>csrw    mtvec,a5</code>的汇编代码是<code>30579073(16进制)</code>,查阅手册得知,高12位$0x305$实际上是mtvec对应的编号. <font color="red">添加好译码匹配规则之后</font>, $pseudo.h$里面添加如下代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec_csr 0x305 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(csrrw, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> csr)</span></span>&#123;</span><br><span class="line"><span class="comment">// 根据高12位立即数 csr 判断是哪个系统寄存器, 然后写入信息</span></span><br><span class="line">    <span class="keyword">if</span>(csr == mtvec_csr) mtvec = *src1;</span><br><span class="line">    TODO();<span class="comment">//添加其他系统寄存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note info"><p>$Q1:$为什么<code>&quot;r&quot;(__am_asm_trap)</code>可以将异常处理入口写入$mtvec$?<br>实际上,<code>__am_asm_trap</code>是一个函数,也是一个指针,存放的就是函数的入口地址.<br>$Q2:$<code>__am_asm_trap</code>的地址在哪?<br>查看<code>nanos-lite-riscv32-nemu.txt</code>可以知道其地址是:$0x80000730$(这个数字未必是定值,具体看情况). 通过$csrw$指令,<code>cte.c</code>做的第一件事情就是将该值写入$mtvec$寄存器.</p></div><div class="note warning"><p>更多的细节?!<br>查看<code>cte_init</code>的汇编代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">800007b7         lui a5,0x80000</span><br><span class="line">73078793         addi  a5,a5,1840 # 80000730 &lt;_end+0xfffed730&gt;</span><br><span class="line">30579073         csrw  mtvec,a5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8000a7b7         lui a5,0x8000a</span><br><span class="line">02a7a223         sw  a0,36(a5) # 8000a024 &lt;_end+0xffff7024&gt;</span><br><span class="line"></span><br><span class="line">00100513         li  a0,1</span><br><span class="line">00008067         ret</span><br></pre></td></tr></table></figure><br>前三条指令的作用就是将异常入口地址(<code>__am_asm_trap</code>)写入寄存器$a_5$,然后将其写入mtvec；注意<code>cte.c</code>的函数参数是一个函数指针,存放在$a_0$里面,而$36(a_5)$实际上就是usr_handler的地址.<code>sw  a0,36(a5)</code>对应的就是<code>user_handler = handler;</code>, <code>8000a024 &lt;_end+0xffff7024&gt;(具体数值可能会有变动)</code>这个地址自然就是我们在cte.c初始化的全局变量的<code>static Context* (*user_handler)(Event, Context*) = NULL;</code>的地址!</p></div><h3 id="3-实现新指令"><a href="#3-实现新指令" class="headerlink" title="$(3)$实现新指令"></a>$(3)$实现新指令</h3><h4 id="3-1-ecall"><a href="#3-1-ecall" class="headerlink" title="$3.1\ ecall$"></a>$3.1\ ecall$</h4><p>$ecall$是自陷指令,通过与<code>isa_raise_intr</code>的协作,它主要完成以下工作:</p><pre><code>(1)将当前PC值保存到mepc寄存器(2)在mcause寄存器中设置异常号(3)从mtvec寄存器中取出异常入口地址(4)跳转到异常入口地址</code></pre><p>代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intr.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc cpu.sysr[0]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause cpu.sysr[2]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"><span class="function"><span class="keyword">word_t</span> <span class="title">isa_raise_intr</span><span class="params">(<span class="keyword">word_t</span> NO, <span class="keyword">vaddr_t</span> epc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO&#x27;&#x27;.</span></span><br><span class="line"><span class="comment">   * Then return the address of the interrupt/exception vector.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mepc = epc; <span class="comment">// 将当前PC值保存到mepc寄存器</span></span><br><span class="line">  mcause = NO; <span class="comment">//在mcause寄存器中设置异常号</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mtvec; <span class="comment">//从mtvec寄存器中取出异常入口地址, 并且返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pseudo.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(ecall, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> imm)</span></span>&#123;</span><br><span class="line">  <span class="keyword">word_t</span> Event_NO = <span class="number">11</span>; <span class="comment">// 11在手册里面可以查到</span></span><br><span class="line">  s-&gt;dnpc = isa_raise_intr(Event_NO, s-&gt;pc); <span class="comment">//跳转到异常入口地址(__am_asm_trap)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note primary"><p>通过以下流程图梳理一下,$ecall$的调用过程<br><img src="/2021/11/06/PA3-1/h1.png" alt></p><p>$Q$:<code>__am_asm_trap</code>在哪?它的作用是什么?<br>$A$: 在$trap.S$里面,将所有的通用寄存器和系统寄存器压栈,为<code>__am_irq_handle</code>准备好参数(后面会提到),从<code>__am_irq_handle</code>返回之后恢复上下文.</p><p>$Q$:yiled在调用ecall之前将-1加载到$a_7$。这是为什么呢？<br>答：$ecall$指令主要用户程序向运行环境(OS)发出请求，具体的请求类别需要传递参数，$a_7$就是这个参数存放的地方。</p><p><a href="https://www.youtube.com/watch?v=UPHEkz_rHTY">https://www.youtube.com/watch?v=UPHEkz_rHTY</a></p></div></p><h4 id="3-2-csrr"><a href="#3-2-csrr" class="headerlink" title="$3.2\ csrr$"></a>$3.2\ csrr$</h4><p>跳转到<code>__am_asm_trap</code>之后.查看反汇编代码, <code>__am_asm_trap</code>做的事情就是将32个通用寄存器保存($sw$指令), 同时将$mepc$等存储到寄存器里面($csrr$指令), 接着跳转到<code>__am_irq_handle</code>处理函数.<br><code>pseudo.h</code>里面添加:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc cpu.sysr[0]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mstatus cpu.sysr[1]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause cpu.sysr[2]._csr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec cpu.sysr[3]._csr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// csr寄存器在指令当中体现为编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mepc_csr 0x341</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mstatus_csr 0x300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mcause_csr 0x342</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtvec_csr 0x305</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(csrr, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> csr)</span></span>&#123;</span><br><span class="line"><span class="comment">// 将csr寄存器信息写入目的寄存器</span></span><br><span class="line">    <span class="keyword">if</span>(csr == mepc_csr)*dest = mepc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(csr == mstatus_csr)*dest = mstatus;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(csr == mcause_csr)*dest = mcause;</span><br><span class="line">    <span class="keyword">else</span> panic(<span class="string">&quot;No such System Register!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-mret"><a href="#3-3-mret" class="headerlink" title="$3.3\ mret$"></a>$3.3\ mret$</h4><p>好了,现在我们已经跳转到<code>__am_irq_handle</code>函数了.在实现$mret$之前,先对函数行为进行分析.</p><div class="note info"><p><code>__am_irq_handle</code>的函数参数来自哪里??<br>$A:$答案就在<code>__am_asm_trap</code>的汇编代码中.<br><code>__am_irq_handle</code>的参数是$Context$指针,一个$Context$结构体应该包括32个寄存器和3个csr寄存器(这里先不管剩下的), <font color="red">由寄存器$a_0$传入, $a_0$存储的就是$context$的首地址</font>, 前面已经讲了<code>__am_asm_trap</code>将32个寄存器等压栈,形成一个124字节的栈, 在跳转到<code>__am_irq_handle</code>之前,<code>mv  a0,sp</code>的作用就是将$sp$的内容写入$a_0$,使得$a_0$能够指向结构体的首地址. <font color="green">所以参数是由<code>__am_asm_trap</code>准备好的!</font></p></div><p>接下来,我们对<code>__am_irq_handle</code>的汇编代码的一部分进行分析:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">8000067c &lt;__am_irq_handle&gt;:</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line">8000a024 : 全局变量usr_handlerd的地址,存储了do_event的入口地址, 写入a5</span><br><span class="line">8000067c: 8000a7b7            lui a5,0x8000a </span><br><span class="line">80000680: 0247a783            lw  a5,36(a5) # 8000a024 &lt;_end+0xffff7024&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">80000684: 00050593            mv  a1,a0</span><br><span class="line">80000688: 04078e63            beqz  a5,800006e4 </span><br><span class="line">判断handler是否为空</span><br><span class="line">&lt;__am_irq_handle+0x68&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">8000068c: 08052703            lw  a4,128(a0)</span><br><span class="line">注意这里的128(a0)是mcause,请自己思考原因</span><br><span class="line">---------------------------------------</span><br><span class="line">80000690: fd010113            addi  sp,sp,-48</span><br><span class="line">80000694: 02112623            sw  ra,44(sp)</span><br><span class="line">80000698: 00012a23            sw  zero,20(sp)</span><br><span class="line">8000069c: 00012c23            sw  zero,24(sp)</span><br><span class="line">800006a0: 00012e23            sw  zero,28(sp)</span><br><span class="line">---------------------------------------</span><br><span class="line">将a4即(mcause) 与1(EVENT_YIELD)进行比较</span><br><span class="line">800006a4: 00100693            li  a3,1</span><br><span class="line">800006a8: 00d70463            beq a4,a3,800006b0 </span><br><span class="line">&lt;__am_irq_handle+0x34&gt;</span><br><span class="line">---------------------------------------</span><br><span class="line">800006ac: 00400713            li  a4,4</span><br><span class="line">---------------------------------------</span><br><span class="line">800006b0: 00e12023            sw  a4,0(sp)</span><br><span class="line">800006b4: 01412703            lw  a4,20(sp)</span><br><span class="line">800006b8: 00010513            mv  a0,sp</span><br><span class="line">800006bc: 00e12223            sw  a4,4(sp)</span><br><span class="line">800006c0: 01812703            lw  a4,24(sp)</span><br><span class="line">800006c4: 00e12423            sw  a4,8(sp)</span><br><span class="line">800006c8: 01c12703            lw  a4,28(sp)</span><br><span class="line">800006cc: 00e12623            sw  a4,12(sp)</span><br><span class="line">800006d0: 000780e7            jalr  a5</span><br><span class="line">跳转到a5, 也就是执行usr_handler, 前面的几个指令准备了函数调用的参数</span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><br>从<code>__am_irq_handle</code>正常返回到<code>__am_asm_trap</code>之后,<code>__am_asm_trap</code>做的就是恢复上下文,并且执行$mret$指令,执行”异常指令”的下一条指令.<br>因此,mret的指令也就不难实现了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">def_rtl</span><span class="params">(mret, <span class="keyword">rtlreg_t</span>* dest, <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> imm)</span></span>&#123;</span><br><span class="line">  s-&gt;dnpc = mepc + <span class="number">4</span>; <span class="comment">// 执行&quot;异常指令&quot;的下一条指令.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning"><p>上面给出的$mret$的实现<font color="red">在硬件上($nemu$)</font>将返回地址设置为$mepc+4$, 看上去并没有什么问题，在不开$difftest$的时候也能够正常运行，但根据讲义的内容，$mepc$是否加4应该由软件决定(目前的默认加4)，所以需要在$cte.c$的$do_{-}event$返回之前<code>c-&gt;mepc += 4</code>, 并且<code>mret</code>改为<code>s-&gt;dnpc = mepc;</code>.否则在开$difftest$的情况下会出现莫名的错误。</p></div><br><div class="note primary"><p>整理一下整个过程:<br><img src="/2021/11/06/PA3-1/h2.png" alt></p></div></p><h3 id="4-difftest"><a href="#4-difftest" class="headerlink" title="$(4) difftest$"></a>$(4) difftest$</h3><p>在$nemu$的<code>init.c</code>里面将$cpu.sysr[1]._{-}csr$ 的值赋为0x1800。</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab2-内联汇编</title>
      <link href="/2021/10/30/Lab2/"/>
      <url>/2021/10/30/Lab2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-asm-add"><a href="#1-asm-add" class="headerlink" title="$(1)asm_{-}add$"></a>$(1)asm_{-}add$</h3><p>“$add[q|l|w|b] \ A, \ B$”将$A+B$送至$A$.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">asm_add</span><span class="params">(<span class="keyword">int64_t</span> a, <span class="keyword">int64_t</span> b)</span> </span>&#123;</span><br><span class="line">__asm__(</span><br><span class="line"><span class="string">&quot;addq %[b], %[a]\n&quot;</span></span><br><span class="line">:[a] <span class="string">&quot;+r&quot;</span>(a)</span><br><span class="line">:[b] <span class="string">&quot;r&quot;</span>(b)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-asm-popcnt"><a href="#2-asm-popcnt" class="headerlink" title="$(2)asm_{-}popcnt$"></a>$(2)asm_{-}popcnt$</h3><p>$asm_{-}popcnt(x)$的作用是计算$x$的二进制中含 $1$的数目.<br>思路比较简单,$x$不断逻辑右移直到$x = 0$, 右移$shr[q|l|w|b]$指令每次右移指定位数, 比如在这里指定$shamt=1$, <font color="red">操作数的最低位将会移动到</font>$CF$, 根据$CF==1$, 我们可以决定计数器$cnt$是否加一.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">asm_popcnt</span><span class="params">(<span class="keyword">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;L1:&quot;</span></span><br><span class="line">    <span class="string">&quot;testq %[x], %[x] #判断x是否为零, 如果为零,跳转到end\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jz end\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;shrq $1, %[x] #右移1位,将最低位送到CF\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jnc not_to_cnt #如果CF为零, cnt不加1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;incl %[cnt] #cnt加1\n &quot;</span></span><br><span class="line">    <span class="string">&quot;not_to_cnt:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp L1  #跳转到L1继续进行判断\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:\n&quot;</span></span><br><span class="line">    : [x] <span class="string">&quot;+r&quot;</span>(x), [cnt] <span class="string">&quot;+r&quot;</span>(cnt)</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note info"><p>$test$指令将两个操作数相”与”,不改变原操作数,根据结果设置条件标志.比如要知道寄存器$\%eax==0$, 只需<code>testl %eax, %eax</code>, 然后再用<code>jz/jnz</code>跳转到指定的$label$<br>其它条件转移指令还有<code>jc/jnc, je/jne</code>等,可以查阅”计算机系统基础”的$Page111表3.6$</p></div><br>不少指令都会影响到$Flags$,如$add, sub, cmp,$移位指令.不同指令影响的标志位不完全一样.<br>将上面的代码的<code>testq %[x], %[x]</code>改为<code>cmpq $0, %[x]</code>具有一样的效果.也可以考虑$and$指令获取$x$的最低位.<br><div class="note default"><p>考虑用内联汇编实现$int64_{-}t \ max(int64_{-}t\ x, int64_{-}t\ y)$以及$\sum_{i=1}^{100}i$</p></div><br>$max$函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">max</span><span class="params">(<span class="keyword">int64_t</span> x, <span class="keyword">int64_t</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> gre = <span class="number">0</span>;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;cmpq %[y], %[x] # x - y并且获得标志位信息\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jge x_greater # x &gt;= y\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;movq %[y], %[gre] #y更大\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp end\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;x_greater:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %[x], %[gre]\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:\n&quot;</span></span><br><span class="line"></span><br><span class="line">    : [gre] <span class="string">&quot;=r&quot;</span>(gre)</span><br><span class="line">    : [x] <span class="string">&quot;r&quot;</span>(x), [y] <span class="string">&quot;r&quot;</span>(y)</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">return</span> gre; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>$\sum_{i=1}^{100}i$函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;movl $1, %%edx #作为变量 i \n&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;l1: \n&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl $100, %%edx #跟100比较, edx - 100获得标志位\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jle l2 # edx &lt;= 100\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp end #edx &gt;100 直接结束\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;l2:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;addl %%edx, %%eax # eax += i\n&quot;</span></span><br><span class="line">    <span class="string">&quot;incl %%edx #edx += 1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp l1 #继续下一轮的判断\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;end:&quot;</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span>(result)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-asm-memcpy"><a href="#3-asm-memcpy" class="headerlink" title="$(3)asm_{-}memcpy$"></a>$(3)asm_{-}memcpy$</h3><p>$asm_{-}memcpy$的作用是将源地址数据复制到目标地址.<br><code>void   *asm_memcpy(void *dest, const void *src, size_t n);</code></p><p>这里的$size_{-}t$指的是需要拷贝的字节数, 所以一个很自然的想法就是,用一个变量$cnt$(初始化为$n$), 每拷贝一个字节,$cnt-1$,当$cnt = 0$时,循环拷贝终止.<br><div class="note info"><p>设$byte_{-}1$的地址存放在$ESI$, $byte_{-}2$的地址存放在$EDI$<br>$movsb$的作用:将$byte_{-}2$换成$byte_{-}1$, 也即$movsb$的操作数省略可以不写,默认取$ESI(源变址寄存器), EDI(目标变址寄存器)$</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d1, d2;</span><br><span class="line">  <span class="keyword">int</span> cnt = n;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;LOOP:\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cmpl $0, %[cnt]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jz Final\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;movsb\n&quot;</span></span><br><span class="line">    <span class="string">&quot;dec %[cnt]\n&quot;</span></span><br><span class="line">    <span class="string">&quot;jmp LOOP\n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;Final:&quot;</span></span><br><span class="line">    :<span class="string">&quot;=&amp;D&quot;</span>(d1), <span class="string">&quot;=&amp;S&quot;</span>(d2), [cnt] <span class="string">&quot;+r&quot;</span>(cnt) </span><br><span class="line">    :</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用$REP$前缀简化上述过程<br><div class="note info"><p>$REP$将$rcx$寄存器数值作为计数器,比如初始化$rcx=100$, 那么$rep$后面跟的指令就会执行100次, 因此初始化$rcx=n$, 然后$rep \ movsb$就可以了.</p></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d1, d2, cnt = n;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;rep movsb\n&quot;</span></span><br><span class="line">    :<span class="string">&quot;=&amp;D&quot;</span>(d1), <span class="string">&quot;=&amp;S&quot;</span>(d2),<span class="string">&quot;+c&quot;</span>(cnt) </span><br><span class="line">    :</span><br><span class="line">    :<span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div class="note warning"><p>既然有$movsb$,那我们可以也考虑$movsq$,这样子拷贝数据不就更快了? 比方现在我们要拷贝5个$int(n=20)$,每次1个字节的话需要20次$movsb$, 如果每一次拷贝 8 个字节的话,那么只需要 2 次$movsq$和 1 次$movsb$就可以了.所以,$memcpy$还可以按以下的写法写.</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">asm_memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> d0, d1, d2; </span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;rep ; movsq # 每次拷贝8个字节, 总共执行 n / 8次\n\t&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">&quot;movq %4,%%rcx #剩下的不足8个字节, 换用movsb\n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;rep ; movsb # movsb需要执行(n &amp; 7)次\n\t&quot;</span></span><br><span class="line">       : </span><br><span class="line">      <span class="string">&quot;=&amp;c&quot;</span> (d0),                                                                                   </span><br><span class="line">      <span class="string">&quot;=&amp;D&quot;</span> (d1),</span><br><span class="line">      <span class="string">&quot;=&amp;S&quot;</span> (d2)</span><br><span class="line">      :<span class="string">&quot;0&quot;</span> (n &gt;&gt; <span class="number">3</span>), </span><br><span class="line">      <span class="string">&quot;g&quot;</span> (n &amp; <span class="number">7</span>), </span><br><span class="line">      <span class="string">&quot;1&quot;</span> (dest),</span><br><span class="line">      <span class="string">&quot;2&quot;</span> (src)</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">      );  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-asm-setjmp"><a href="#4-asm-setjmp" class="headerlink" title="$(4)asm_{-}setjmp$"></a>$(4)asm_{-}setjmp$</h3><p>$asm_{-}setjmp$的作用是保存”快照”, 需要保存的信息自然是跟当前的栈帧相关的信息:<br>$rsp(栈顶),rbp(栈底), rbx, r12, r13, r14, r15$, 后面四个寄存器作为被调用者保存寄存器也应当保存.(set_jmp是被调用者)<br>$asm_{-}jmp_{-}buf$是用来存放这些寄存器的结构,它的定义如下(定义方式不唯一):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _JLEN 7</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">uint64_t</span> _jb[_JLEN + <span class="number">1</span>];&#125;asm_jmp_buf[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><p>比如我们现在在$main$调用$asm_{-}setjmp$,在执行$call$指令之前,$main$的栈帧如下:<br><img src="/2021/10/30/Lab2/g1.png" alt="逻辑图" style="zoom:100%;"><br>执行$call$指令,首先将$asm_{-}setjmp$的返回地址压栈.然后跳转到$asm_{-}setjmp$.执行$asm_{-}setjmp$之前,栈如下:<br><img src="/2021/10/30/Lab2/g2.png" alt="逻辑图" style="zoom:100%;"></p><div class="note info"><p>现在考虑$asm_{-}setjmp$究竟干了什么?!简单来说:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">asm_setjmp</span><span class="params">(asm_jmp_buf env)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 注意env这个时候是一个指针</span></span><br><span class="line">  <span class="comment">// mov %rsp to env-&gt;_jb[0] 将rsp保存</span></span><br><span class="line">  <span class="comment">// mov M[%rsp] to env-&gt;_jb[1], 将返回地址保存</span></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// mov $0, %rax, 直接调用setjmp的返回值是 0 </span></span><br><span class="line">  <span class="comment">// ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><p>好了回归正题,我们进入$asm_{-}setjmp$后, 手里握着若干的需要保存的寄存器数据,关键就是获知上面的$env\rightarrow_{-}jb [ 0 ,1,2…]$的地址.<br>$x86-64$的过程调用约定:当函数的入口参数是整数类型或者指针类型并且小于等于6个的时候,无需用栈来传递参数,依次存放在$RDI,RSI\dots$中.这里的env传进来的只是一个指针,因此$env\rightarrow_{-}jb [ 0 ]$的地址就是$R[rdi]$,$env\rightarrow_{-}jb [ 1 ]$的地址存放在$R[rdi] + 8$中,后面类推.</p><p><img src="/2021/10/30/Lab2/g3.png" alt="图3" style="zoom:100%;"></p><p>代码部分实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">asm_setjmp</span><span class="params">(asm_jmp_buf env)</span></span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;movq %%rsp, (%%rdi) # 将rsp保存\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq (%%rsp), %%rdx # rdx临时存放返回地址\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rdx, 8(%%rdx) \n&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;TODO&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;ret\n&quot;</span></span><br><span class="line">    :</span><br><span class="line">    :</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">// 之所以需要临时寄存器,是因为并没有&quot;mov 内存, 内存&quot;的指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-asm-longjmp"><a href="#5-asm-longjmp" class="headerlink" title="$(5)asm_{-}longjmp$"></a>$(5)asm_{-}longjmp$</h3><p>$longjmp$和$setjmp$一般是搭配使用的.<br><div class="note success"><p>$asm_{-}longjmp$做的事情:恢复”快照”,设置val, 并将自己的返回地址设置为对应的$jmp_{-}buf$当中的返回地址.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">asm_longjmp</span><span class="params">(asm_jmp_buf env, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="comment">// mov env-&gt;_jb[0] , %rsp</span></span><br><span class="line">  <span class="comment">// mov env-&gt;_jb[1] , M[%rsp]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// set the val as return value</span></span><br><span class="line">  <span class="comment">// ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div></p><p><font color="red">直接调用$setjmp$的返回值是0</font>.而$longjmp$将自己的返回地址换成$setjmp$的返回地址之后,在$main$看来跟直接调用$setjmp$并无区别,唯一不同的就是返回值.<font color="red">返回值为整型的函数的返回值一般存放在$\%rax|\%eax$中, $main$的视角下,$setjmp$的返回值是$\%eax$</font><br>根据前面讲的内容,val存放在第二个参数寄存器$\%rsi$中,因此<code>movl %esi, %eax</code>就可以解决返回值问题了.</p><div class="note primary"><p>一个简单的理解方式:<br>$asm_{-}longjmp$实际上就是”窃取了”$asm_{-}setjmp$的返回地址, “伪装成”$asm_{-}setjmp$”堂而皇之”地回到调用$asm_{-}setjmp$的函数中,这个过程还通过修改$\%eax$改变了它的返回值.</p></div>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内联汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA2.3</title>
      <link href="/2021/10/26/PA2-3/"/>
      <url>/2021/10/26/PA2-3/</url>
      
        <content type="html"><![CDATA[<p>$PA2.3$主要是设备的实现.关系图如下:<br><img src="/2021/10/26/PA2-3/gra.png" alt="逻辑图"><br><span id="more"></span></p><p>AM抽象计算机直接跟我们在其上面运行的各种应用程序打交道,<strong>在am-tests里面的各种测试程序都算是运行在am上的应用程序.(很重要!!)</strong></p><p>应用程序如果想要访问设备,比如说测试集里的$rtc.c$想要获取当前的时间,那么需要跟am进行交互.具体就是通过$io_{-}read,io_{-}write$函数.<br>而AM跟nemu进行设备相关的交流,得通过$inl, outl$等函数对各种设备的地址进行读写<br>$nemu$模拟的硬件设备会将其对应的数据存在指定的内存地址里面,访问和更新设备,实际上就是对内存地址的访问,取出相应的数据和对内存地址的信息进行改写.</p><div class="note danger"><p>将设备的访问放在nemu原则上也是可行的,但是不同架构之间设备的访问是不兼容的.而在AM中,我们约定在不同的架构中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象, 因此我们只需要在<code>abstract-machine/am/src/platform/nemu/ioe/</code>目录下实现一份IOE, 来供NEMU平台的架构共享.<br>AM的出现使得不同架构访问设备更加方便,不用分别在不同架构里面分别实现设备的访问.</p></div> <h3 id="一-时钟的实现"><a href="#一-时钟的实现" class="headerlink" title="(一)时钟的实现"></a>(一)时钟的实现</h3><h4 id="1-riscv-h-和-nemu-h"><a href="#1-riscv-h-和-nemu-h" class="headerlink" title="(1)$riscv.h$和$nemu.h$"></a>(1)$riscv.h$和$nemu.h$</h4><p>$riscv.h$定义了$inb, inw, inl, outb\dots$等函数,<strong>这些函数特别关键,是AM与设备的桥梁.</strong><br><img src="/2021/10/26/PA2-3/image-20211003204455099.png" alt="关键的函数"><br>inb(addr)获取addr地址的数据, 该数据为一个字节.其他类似. outb(addr, data),向addr地址写入一个一字节的数据data.</p><p>$nemu.h$定义了各种设备的的相关物理地址,时钟的物理地址<code>#define RTC_ADDR        (DEVICE_BASE + 0x0000048)</code>,该64位数的地址存储了时间数据(以微秒为单位).</p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>在$timer.c$的<code>__am_timer_uptime</code> 做如下修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime-&gt;us = indl(RTC_ADDR);</span><br></pre></td></tr></table></figure><br>其中<code>indl</code>函数是我们在$riscv.h$<strong>自定义</strong>的访问64位数据的函数,原理与inl等函数完全一样.</p><h4 id="3-如何测试"><a href="#3-如何测试" class="headerlink" title="(3)如何测试?"></a>(3)如何测试?</h4><p><strong>在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=t run</code>.</strong><br>结果如下图:<br><img src="/2021/10/26/PA2-3/image-20211026204348486.png" alt><br><div class="note info"><p>在<code>am-kernals/tests/am-tests/src</code>的main.c定义了各种测试的首字母, 如<code>[&#39;t&#39;] = &quot;real-time clock test&quot;,</code>mainargs根据终端的字母缩写确定运行哪一个测试集. 可以尝试在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=H run</code>,看看会发生什么.</p></div> </p><h4 id="4-流程图"><a href="#4-流程图" class="headerlink" title="(4)流程图"></a>(4)流程图</h4><p><img src="/2021/10/26/PA2-3/gra1.png" alt><br>注:上图的回调函数就是:<code>nemu/src/device/timer.c</code>的<code>rtc_io_handler</code></p><h4 id="5-buggy"><a href="#5-buggy" class="headerlink" title="(5)$buggy?!$"></a>(5)$buggy?!$</h4><p>事实上,上面的代码是有BUG的,而且这个bug虽然在测试终端看不出来(或者说,不明显),但是跑分的时候就会出现非常大的问题(爆分!).因为64位的时间意味着需要调用两次回调函数,先访问高32位还是低32位会一定差别.<br>所以需要将上述代码的64位读取改为<strong>先访问高32位数然后再访问低32位</strong>. 高32位地址为<code>RTC_ADDR + 4</code>, 低32位为<code>RTC_ADDR</code>,两次调用$inl$函数再拼接就可以了.<br><code>(uint64_t)inl(RTC_ADDR + 4)&lt;&lt;32+inl(RTC_ADDR)</code></p><div class="note info"><p>为什么会有访问顺序不同造成的差别?<br>实际上,虽然我们调用两次回调函数,但两次调用只有一次是真正有效的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(nemu/src/device/timer.c)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_io_handler</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">int</span> len, <span class="keyword">bool</span> is_write)</span> </span>&#123;</span><br><span class="line">  assert(offset == <span class="number">0</span> || offset == <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> (!is_write &amp;&amp; offset == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> us = get_time();</span><br><span class="line">    rtc_port_base[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>)us;</span><br><span class="line">    rtc_port_base[<span class="number">1</span>] = us &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出,<strong>只有offset = 4才能将”当前系统启动时间”写入内存</strong>,换而言之,如果在<code>inl(RTC_ADDR + 4)</code>之前调用<code>inl(RTC_ADDR)</code>,那么访问到的低32位的时间是上一次”残留”的时间,并不是”当前时间”.</p></div> <h3 id="二-键盘的实现"><a href="#二-键盘的实现" class="headerlink" title="(二)键盘的实现"></a>(二)键盘的实现</h3><p>在我们使用AM(软件)输出键盘信息之前,$nemu$(硬件)模拟的$i8042$芯片已经根据我们在电脑的键盘输入情况将对应的键盘码写入nemu键盘对应的物理地址,所以我们<strong>直接调用前面讲的in函数就可以取出相应的信息了</strong>.至于模拟的芯片怎们写入数据的,可以查看keyboard.c文件.(讲义:每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以访问数据寄存器, 获得键盘码,<strong>只有一个字节(256足够对应整个键盘的所有键了)</strong>)</p><p>值得一提的是,芯片在写入按下(down)时加了一个<strong>掩码处理</strong>,比如1对应空格键盘,如果按下,那么写入信息为0x8001,如果松开,写入信息为0x0001,因此我们在AM(软件)读取地址信息后,还需进一步做<strong>还原处理</strong>,才能正确获知keydown的值.</p><h4 id="1-掩码处理"><a href="#1-掩码处理" class="headerlink" title="(1)掩码处理?!"></a>(1)掩码处理?!</h4><p>查看nemu下面的$keyboard.c$, 掩码处理最重要的一句:<br><code>uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);</code> </p><p>当你按下键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | KEYDOWN_MASK = keymap[ESCAPE] | 0x8000</code>;当你松开键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | 0 = keymap[ESCAPE]</code>.</p><div class="note info"><p><code>i8042_data_io_handler</code>函数的<code>i8042_data_port_base[0] = key_dequeue();</code>将键盘码写入键盘对应的内存!!!</p></div><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>$input.c$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) &#123;</span><br><span class="line">   kbd-&gt;keydown = <span class="number">0</span>;</span><br><span class="line">   kbd-&gt;keycode = inl(KBD_ADDR);<span class="comment">//读取键盘码,类似于时钟的数据获取</span></span><br><span class="line">   <span class="keyword">if</span> (kbd-&gt;keycode != <span class="number">0</span>)<span class="comment">//不为空(无输入)</span></span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">//判断第16位(二进制)是否为1, 如果是,说明做了掩码处理,需要还原,同时将keydown设置为true</span></span><br><span class="line">      <span class="keyword">if</span>(kbd-&gt;keycode &gt;&gt; <span class="number">15</span>)&#123;        </span><br><span class="line">        kbd-&gt;keydown = <span class="literal">true</span>;</span><br><span class="line">        kbd-&gt;keycode = (kbd-&gt;keycode &lt;&lt; <span class="number">17</span>) &gt;&gt; <span class="number">17</span>;<span class="comment">//掩码逆处理</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         kbd-&gt;keydown = <span class="literal">false</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果:<br><img src="/2021/10/26/PA2-3/1.png" alt></p><h3 id="三-vga的实现"><a href="#三-vga的实现" class="headerlink" title="(三)vga的实现"></a>(三)vga的实现</h3><p>$vga$的控制端有两个重要的寄存器(这两个寄存器的具体含义可以通过查看<code>nemu/src/device/vga.c</code>得知), <code>vgactl_port_base[0]</code>的高低16位分别存储屏幕的宽度和高度.<code>vgactl_port_base[1]</code>存储的是是否将屏幕刷新的值(true or false).<strong>(同步寄存器sync register)</strong></p><div class="note info"><p><code>init_vga</code>函数的 <code>vgactl_port_base[0] = (screen_width() &lt;&lt; 16) | screen_height();</code>将屏幕大小信息写入一个32位的存储空间</p></div><h4 id="1-在硬件层面"><a href="#1-在硬件层面" class="headerlink" title="(1)在硬件层面"></a>(1)在硬件层面</h4><p>此处硬件指的是$nemu$的$vga.c$, 里面的<code>void vga_update_screen()</code>提示的非常清楚:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when the sync register is non-zero,</span></span><br><span class="line"><span class="comment">//根据前面</span></span><br><span class="line"> <span class="keyword">if</span>(vgactl_port_base[<span class="number">1</span>] != <span class="number">0</span>)update_screen();</span><br><span class="line"><span class="comment">// then zero out the sync register</span></span><br><span class="line">  vgactl_port_base[<span class="number">1</span>] = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><br>通过阅读vga.c, 还可以知道$width = 400, height = 300$</p><div class="note success"><p>  查看 AM(软件层面) 下面的gpu.c, 可以发现__am_gpu_fbdraw里面有这么一句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);<span class="comment">//写入 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:向sync_addr写入1之后,vga_update_screen检查sync寄存器的值(不为 0 ),然后调用update_screen();</p></div><p>添加好讲义给定的测试代码之后,正确的运行结果如下:<br><img src="/2021/10/26/PA2-3/2.png" alt></p><h4 id="2-在软件层面"><a href="#2-在软件层面" class="headerlink" title="(2)在软件层面"></a>(2)在软件层面</h4><p>正确实现$AM_{-}GPU_{-}FBDRAW$的画面如下:<br><img src="/2021/10/26/PA2-3/3.png" alt></p><div class="note warning"><p>上面动画效果怎么来的?    </p></div><p>流程图如下:<br><img src="/2021/10/26/PA2-3/gra2.png" alt></p><p>代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) &#123;</span><br><span class="line">    <span class="comment">//*ctl接受了来自APP(应用程序)的缓冲信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width = inw(WID_ADDR), height = inw(HEIGHT_ADDR);<span class="comment">//获取屏幕宽度, 高度</span></span><br><span class="line">    <span class="keyword">int</span> col, row;</span><br><span class="line">    <span class="comment">//uint32_t *fb = (uint32_t *)(uintptr_t)FB_ADDR;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pixelss = ctl-&gt;pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> point_x = ctl-&gt;x, point_y = ctl-&gt;y, target_w = ctl-&gt;w, target_h = ctl-&gt;h;<span class="comment">//开始的x, y以及绘画区域的w, h</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = point_y; row &lt; (point_y + target_h) &amp;&amp; row &lt;= height; row++)</span><br><span class="line">      <span class="keyword">for</span> (col = point_x; col &lt; (point_x + target_w) &amp;&amp; col &lt;= width; col++) </span><br><span class="line">      outl(FB_ADDR + (col + row*width)*<span class="number">4</span> , pixelss[target_w*(row - point_y) + col - point_x] );</span><br><span class="line">      <span class="comment">// outl的作用不就是将信息写入指定物理地址</span></span><br><span class="line">      <span class="comment">//等价于fb[col + row*width] = pixelss[target_w*(row - point_y) + col - point_x];</span></span><br><span class="line">  <span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">    outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码实际上是讲义给出的测试的<strong>进阶版本</strong>,不信可以对比一下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">400</span>;  </span><br><span class="line"><span class="keyword">int</span> h = <span class="number">300</span>;  </span><br><span class="line"><span class="keyword">uint32_t</span> *fb = (<span class="keyword">uint32_t</span> *)(<span class="keyword">uintptr_t</span>)FB_ADDR;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;<span class="comment">//向地址写入像素信息(所以我们会看到第一幅图从左边到右边颜色的递变)</span></span><br><span class="line"> <span class="comment">//等价于for (i = 0; i &lt; w * h; i ++) outl(FB_ADDR + 4 * i, i); 想想outl的作用</span></span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><div class="note info"><p>还是不太理解?!<br> <code>_am_gpu_fbdraw()</code>属于软件层面的函数, 归$AM$管理,这个函数的作用就是将来自于$APP$客户程序的像素信息(该信息存储在缓冲区,并作为<code>_am_gpu_fbdraw()</code>的参数传入)写到物理地址里面,前面讲过,$AM$想要将数据写入物理地址需要借助$out[b|w|l]函数.$ </p></div><!-- <div><div class="fold_hider"><div class="close hider_title">点击显/隐内容</div></div><div class="fold"><p>something you want to fold, include code block.</p></div></div> -->]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六次OJ</title>
      <link href="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/"/>
      <url>/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/</url>
      
        <content type="html"><![CDATA[<h2 id="A-最大内切球"><a href="#A-最大内切球" class="headerlink" title="A. 最大内切球"></a>A. 最大内切球</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在三维空间中，线性方程$ax+by+cz\leq d$ 构成一个“半空间”。</p><p>现在给出 $n$ 个这样的线性方程，第 $i$ 个线性方程用$(a_i,b_i,c_i,d_i)$表示.</p><p>求在这 $n$ 个线性方程与限制$\{x\geq 0,y\geq 0, z\geq 0\}$构成的”半空间交“中，内切球的最大半径是多少。</p><p>若这个“半空间交”为空（即上述线性方程组无解），则输出4位小数0.0000。</p><p>如果这个球的半径可以为无穷大，则输出”Infinity”，否则输出一个4位小数，表示最大内切球的半径。<br><span id="more"></span></p><p><strong>输入格式</strong></p><p>第一行一个正整数 $T$，表示测试组数。</p><p>每组测试中，第一行输入一个正整数 $n$，表示线性方程的个数，接下来 $n$​ 行，每行4个整数$a,b,c,d$，表示线性方程$ax+by+cz\leq d$.</p><p>保证对每一组线性方程, $a,b,c$​ 不同时为0。</p><p><strong>输出格式</strong></p><p>共 $T$ 行，每行输出一个保留4位小数的答案，或者$Infinity$。</p><p><strong>样例</strong></p><p><strong>样例输入 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>样例输出 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.5000</span></span><br><span class="line"><span class="number">0.2113</span></span><br><span class="line"><span class="number">0.5901</span></span><br><span class="line"><span class="number">0.5000</span></span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>保证$1\leq T \leq 150, 1\leq n \leq 100, -100\leq a,b,c,d \leq 100, \sum n \leq 2500$。</p><p>保证对于所有答案不为”Infinity“的答案，答案都$\leq 10^9$。</p><p>良心的助教提供了单纯形的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设输入给定的 n 个方程形式为：</p><p>$\begin{cases} a[1, 1] x+ a[1, 2]y + a[1, 3]z\leq a[1, 0]\\a[2, 1] x+ a[2, 2]y + a[2, 3]z\leq a[2, 0] \\\dots \\ \end{cases}$​</p><p>根据给出的==单纯形模板的要求==：</p><p>我们需要将$a[i][j],\ 1\leq j\leq3$取为相反数，记作$b[i][j]$​，那么方程变为</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\ \end{cases}$​​</p><p>这样子就可以直接使用单纯形模板了。</p><p>假定现在的半径为 $radius$​​，设半空间内的某点$(x, y, z)$​​， 根据点到平面的距离公式，我们有：<br>${|ax + by + cz - d|\over\sqrt{a^2 + b^2+c^2} }\geq radius$​</p><p>由于给定条件下$ax + by + cz\leq d$​, 化简之后：</p><p>$-ax -by-cz + d - \sqrt{a^2 + b^2+c^2}\times radius\geq0, \ (1)$​​</p><p>想要知道这个半径所形成的球能否放到我们约束的“半空间”，只需要在原来n个方程的基础上加上 (1) 所形成的 n 个新的约束方程</p><p> ,当然还要注意题目的要求：$x, y, z\geq 0$,根据半径要求：</p><p>$x, y, z\geq radius$</p><p>因此所形成的$2\times n + 3$个限制方程如下：</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\b[n, 1]x +b[n, 2]y + b[n, 3]z+a[n, 0]\geq0\\前n个方程\\b[1,1]x+b[1,2]y+b[1, 3]z+a[1,0]-\sqrt{b_{1,1}^2+b_{1,2}^2+b_{1,3}^2}\times radius\geq0 \\\dots \\由于半径引入的n个方程\\x-radius\geq0\\y-radius\geq0\\z-radius\geq0\end{cases}$</p><p>然后调用单纯形算法就可以判定radius是否合理。==利用这个判定的性质，二分是适合这道题的解法。==</p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ld radius, <span class="keyword">int</span> temp_m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i + m][k] = a[i][k];<span class="comment">//新设立的 m 个方程的系数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新设立的 m 个方程的常数d - radius * sqrt(a^2 + b^2 + c^2)</span></span><br><span class="line">        a[i + m][<span class="number">0</span>] = a[i][<span class="number">0</span>] - <span class="built_in">sqrt</span>(a[i][<span class="number">1</span>]*a[i][<span class="number">1</span>] + a[i][<span class="number">2</span>]*a[i][<span class="number">2</span>] + a[i][<span class="number">3</span>]*a[i][<span class="number">3</span>])*radius;</span><br><span class="line">    &#125;</span><br><span class="line">    m += temp_m;<span class="comment">//增加了 temp_m + 3个方程 </span></span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">1</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">1</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">1</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        n = <span class="number">3</span>;<span class="comment">//只有三个变量x, y, z</span></span><br><span class="line">        <span class="comment">//输入m个原始约束，并将系数取相反数, b数组用来临时存储a的数据，因为后续单纯形算法可能会改变 a 的部分值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][<span class="number">1</span>]&gt;&gt;a[i][<span class="number">2</span>]&gt;&gt;a[i][<span class="number">3</span>]&gt;&gt;a[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i][k] = b[i][k]= -a[i][k];</span><br><span class="line">            b[i][<span class="number">0</span>] = a[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理进行判断：半空间是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;0.0000\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">        ld left = <span class="number">0</span>, right = inf;</span><br><span class="line">        <span class="keyword">int</span> temp_m = m;<span class="comment">//临时存储 m 的值,因为二分每一次check都会修改new_m = old_m*2 + 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; eps)&#123;</span><br><span class="line">            ld medi_radius = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(medi_radius, temp_m))left = medi_radius;</span><br><span class="line">            <span class="keyword">else</span> right = medi_radius;</span><br><span class="line"></span><br><span class="line">            m -= temp_m + <span class="number">3</span>;<span class="comment">//恢复 m 的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复数组a的值，因为单纯形算法可能影响原先数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">                a[i][k] = b[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; eps + <span class="number">1e9</span>)cout&lt;&lt;<span class="string">&quot;Infinity&quot;</span>&lt;&lt;endl;<span class="comment">//半空间不是有限空间（此时left = right = inf = 1e12）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.4Lf\n&quot;</span>,left); <span class="comment">//有限解,注意long double的输出方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-文理分科"><a href="#B-文理分科" class="headerlink" title="B. 文理分科"></a>B. 文理分科</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在高中时候，yjher所在的班级要进行文理分科。他的班级可以用一个 $n\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：</p><p>如果第 i 行第 j 列的同学选择了文科，则他将获得$art_{i,j}$的满意值，如果选择理科，将得到$science_{i,j}$ 的满意值。</p><p>如果第 i 行第 j 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same_art_{i,j}$的满意值。</p><p>如果第 i 行第 j 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加$same_science_{i,j}$的满意值。</p><p>yjher想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。</p><p><strong>输入格式</strong></p><p>输入第一行为两个正整数 n,m。</p><p>接下来 n 行 m 整数，第 i 行第 j 个整数表示$art_{i,j}$</p><p>接下来 n 行 m个整数，第 i 行第 j 个整数表示$science_{i,j}$</p><p>接下来 n 行 m整数，第 i 行第 j 个整数表示$same_{-}art_{i,j}$</p><p>接下来 n 行 m 个整数，第 i 行第 j 个整数表示$same_{-}science_{i,j}$</p><p><strong>输出格式</strong></p><p>输出为一个整数，表示最大的满意值之和。</p><p><strong>样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">13</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="symbol">18 </span><span class="number">17</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">13</span> <span class="number">15</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">3</span> <span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">18</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>$n,m\leq 100$,读入数据均$\geq 0,\leq 500$</p><p>1 表示选择文科，0 表示选择理科，样例方案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">152</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>解法：网络流</strong></p><p>现在先不考虑由于临近的同学选择相同的科目而带来的收益。<br>建立如下网络图：<img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211019203309059.png" alt></p><p>对这个网络调用最大流算法，根据<strong>最小割最大流定理</strong>，这样子求出来的==满意值总和实际上是最小值， 割掉的边实际上是不选的科目==。</p><p>所求满意值最大值为$\sum (art_{i,j}+science_{i, j}) - max_{-}flow$​</p><p><code>----------------------------------------------------------------------------------------------</code></p><p>现考虑由于临近同学选科情况带来的满意值：</p><p>新加入5号点和9号点作为1号的虚拟节点。5 与1,2,3,4的之间边的容量为 $inf$​​ .</p><p>1, 2, 3,4与9之间边的容量为 $inf$<br><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020093816755.png" alt><br>具体分析由于邻近选科情况的满意值：</p><p>假如1号同学==最后选择了文科==，那么根据前面的分析，这里<strong>割掉的边应该是$1\longrightarrow T$</strong>​​</p><ul><li><p>如果与之相邻的2, 3, 4 同学最后选择的也是文科，那么$2, 3,4 \longrightarrow T$​的边均被割断， $S\longrightarrow 5$​不可能被割断（采用反证法：$cut(L, R)， S\in L, T\in R, \ $​如果s -&gt; 5被割断了，那么$5\in R$​, 而$1, 2, 3,4 \in L$​, $cut(L, R) = inf$​, 意味着容量为 inf 的边被割断了，这显然不行)，所以$maxflow$​不包括$same_{-}art_{1, 1}$​​</p><p>最后用$\sum (art_{i,j}+science_{i, j} +same_{-}art_{i,j}  +same_{-}sci_{i, j}) - max_{-}flow$​​​​ 时==没有减去$S\longrightarrow 5$​​​​​的边权==，最大满意值也就将1, 2, 3 , 4选择文科时 ,1 号同学所带来的附加满意值计算在内了。 </p><p>按照这个分析，这个时候$9\longrightarrow T$是应该被割掉的边，因为此时 1 并未与邻近的2, 3, 4一起选择理科。那事实是否如此？</p><p>确实如此，记$cut(L, R)， S\in L, T\in R$​, 那么 9 号要么在L，要么在R。</p><p>假设$9\in R$​​​, 因为$1,2, 3,4 \in L$​, 此时$cut(L, R) = inf$​​​​，因为该cut割掉了2, 3, 4与 9 的容量为 inf 的边，这与容量为 inf 的边无法割断矛盾， 因此符合事实。 所以$9\in L$​, 所以$9\longrightarrow T$​被割断。</p></li><li><p>如果2， 3， 4未必都选文科，根据以上分析，$S\longrightarrow 5$​的边和$9\longrightarrow T$​​都会被割断。</p><p>证明：（反证），不妨设 4 号最终选择了理科，那么$4\longrightarrow T$没有被割断（==割掉的边实际上是不选的科目==），这时如果$S\longrightarrow 5$没有被割断，那么增广路径$S\longrightarrow 5\longrightarrow 4 \longrightarrow T$存在，与最大流终止条件矛盾，9号类似。</p></li></ul><p><code>---------------------------------------------------------------------------------</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_edge_num = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_point_num = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S = <span class="number">0</span>, T;</span><br><span class="line"><span class="keyword">int</span> tot_point_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123; X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> X*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星建图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, capacity;</span><br><span class="line">&#125;edges[Max_edge_num];</span><br><span class="line"><span class="keyword">int</span> total_edge_num = <span class="number">0</span>;<span class="comment">//总的点数</span></span><br><span class="line"><span class="keyword">int</span> head[Max_point_num];</span><br><span class="line"><span class="comment">//分析边数数目：原图的点最多有100*100个，与S和T形成20000条边，新点至多有20000个，每一个新点至多6条边，至多120000条边</span></span><br><span class="line"><span class="comment">//这样子至多有：140000*2（注意双向加边）条边，有约30000个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个二维的点赋唯一的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建图加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    edges[total_edge_num].to = end;</span><br><span class="line">    edges[total_edge_num].next = head[start];</span><br><span class="line">    edges[total_edge_num].capacity = capacity;</span><br><span class="line">    head[start] = total_edge_num;</span><br><span class="line">    ++total_edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ISAP模块</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">int</span> d[Max_point_num],  cur_edge[Max_point_num], numd[Max_point_num], pre[Max_point_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//三个数组初始化 </span></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">memset</span>(numd, <span class="number">0</span>, <span class="keyword">sizeof</span> numd);</span><br><span class="line"><span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot_point_num; i++)cur_edge[i] = head[i];<span class="comment">//初始化当前弧（当前边）数组 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numd[<span class="number">0</span>] = tot_point_num; </span><br><span class="line"><span class="keyword">int</span> max_flow = <span class="number">0</span>;<span class="comment">//存储最大流 </span></span><br><span class="line"><span class="keyword">int</span> u = S;</span><br><span class="line"><span class="keyword">while</span>(d[S] &lt; tot_point_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> neck, i; </span><br><span class="line"><span class="comment">//找到增广路径 </span></span><br><span class="line"><span class="keyword">if</span>(u == T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_flow = inf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据（*）寻找增广路径 </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(min_flow &gt; edges[cur_edge[i]].capacity)</span><br><span class="line">&#123;</span><br><span class="line">min_flow = edges[cur_edge[i]].capacity;</span><br><span class="line">neck = i;<span class="comment">//找到瓶颈节点  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改增广路径上各边的容量:正向边减min_flow，反向边加min_flow </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line">edges[cur_edge[i]].capacity -= min_flow;</span><br><span class="line">edges[cur_edge[i] ^ <span class="number">1</span>].capacity += min_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_flow += min_flow;</span><br><span class="line"><span class="comment">//cout&lt;&lt;max_flow&lt;&lt;endl;</span></span><br><span class="line">u = neck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从瓶颈点继续寻找增广路 </span></span><br><span class="line"><span class="keyword">for</span>(i = cur_edge[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span> &amp;&amp; d[u] == d[edges[i].to] + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到可行出点 </span></span><br><span class="line">cur_edge[u] = i;</span><br><span class="line">pre[edges[i].to] = u;</span><br><span class="line">u = edges[i].to;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">-1</span>)<span class="comment">//找不到下一个点了</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">numd[d[u]]--; </span><br><span class="line"><span class="keyword">if</span>(numd[d[u]] == <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//算法终止</span></span><br><span class="line"></span><br><span class="line">cur_edge[u] = head[u];<span class="comment">//从头再来</span></span><br><span class="line"><span class="keyword">int</span> h = tot_point_num - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">h = <span class="built_in">min</span>(h, d[edges[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">d[u] = h + <span class="number">1</span>;<span class="comment">//当d[u] = n时说明u点已经退出残留网络</span></span><br><span class="line">numd[d[u]]++;</span><br><span class="line"><span class="keyword">if</span>(u != S)u = pre[u];<span class="comment">//回溯到上一个顶点</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//找得到下一个出点就继续找，可省略这句 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_flow;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="keyword">sizeof</span> head);<span class="comment">//初始化为 -1</span></span><br><span class="line">    T = n*m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理点的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; j++)&#123;</span><br><span class="line">            id[i][j] = <span class="built_in">get_id</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入第一个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += art_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, id[i][j], art_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], S, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入第二个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            science_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += science_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], T, science_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(T, id[i][j] , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入后两个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> new_node_id = n * m + <span class="number">1</span>; <span class="comment">//新点的id从此数 + 1开始</span></span><br><span class="line">    <span class="keyword">int</span> same_art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += same_art_i_j;</span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, new_node_id, same_art_i_j);<span class="comment">//加一条从源点S到新点的边，权值为same_art_i_j</span></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, S, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//枚举4个方向合理的邻居并且加边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> same_science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_science_i_j = <span class="built_in">read</span>();</span><br><span class="line">            </span><br><span class="line">            sum += same_science_i_j;</span><br><span class="line"></span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, T, same_science_i_j);<span class="comment">//加一条从新点到汇点 T 的边</span></span><br><span class="line">            <span class="built_in">add_edge</span>(T, new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tot_point_num = new_node_id;</span><br><span class="line">    cout&lt;&lt;sum - <span class="built_in">ISAP</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Did-you-just-say-……-Acesrc"><a href="#C-Did-you-just-say-……-Acesrc" class="headerlink" title="C. Did you just say …… Acesrc?"></a>C. Did you just say …… Acesrc?</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc解决下面的问题:</p><p>一个梯图$(ladder\ graph)L(n)$一个由$2N$个顶点以及$3N−2$条边组成的平面图。它和如下$2\times N$的格点图是同构的。</p><p><img src="http://roundgod.com/resources/wcy-2.png" alt="http://roundgod.com/resources/wcy-2.png"></p><p>你希望删掉$L(n)$中一些边的集合(可能为空)，并保证剩下的图仍然是联通的。计算你有多少种合法的删除的方案。请输出答案对$10^9+7$取模后的结果。</p><p>如果你能做出这道题，Acesrc便会不再做人，成为唯一A皇。对了,你刚才说了Acesrc,……对吧?</p><p><strong>输入格式</strong></p><p>输入仅包含一行，一个正整数N。</p><p><strong>输出格式</strong></p><p>输出仅包含一行，合法的删除的方案数对$10^9+7$取模后的结果。</p><p><strong>样例</strong></p><p><strong>样例输入1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>样例输出1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>样例输入2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024</span><br></pre></td></tr></table></figure><p><strong>样例输出2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">399356307</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>对于$50\%$的数据，有$1\leq N\leq 10^7$。</p><p>对于$100\%%$的数据，有$1\leq N\leq 10^{18}$。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020154943537.png" alt><br>记$g[i]$表示一个$2\times i$​​​的梯图最右侧两个点（上图的 i 和i + i）==不连通，并且整个图只有两个连通分支==的方案数。</p><p>记$f[i]$为$2\times i$的梯图最右侧两个点是连通且整个图只有一个连通分支的方案数。</p><p>考虑状态转移如下：</p><p>$f[i] = 4f[i-1]+g[i-1]$​</p><p>解释：</p><ul><li>在$f[i-1]$的基础上，考虑最后一个格子三条边的情况：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020162606799.png" alt="image-20211020162606799"></p><p>这四种加边情况都可以保证最后整个图是连通的。</p><ul><li>在$g[i-1]$​的基础上，只能加上图的第一种情况。</li></ul><p>$g[i] = 2f[i-1]+g[i-1]$</p><p>解释：</p><ul><li>在$f[i-1]$​​的基础上，考虑最后一个格子三条边的情况（有两种情况,分别是加上边,加下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165138823.png" alt></p><ul><li>在$g[i-1]$的基础上，考虑最后一个格子三条边的情况（只有一种情况,加上边和下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165254450.png" alt></p><p>构造矩阵</p><p>$Relation_{-}Matrix = \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)$​​</p><p>$\because f[1] = 1, g[1] = 1$​,</p><p>$\therefore \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right)$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^2\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right) = \left(\begin{matrix}f[3]\\g[3]\end{matrix}\right)$</p><p>$\dots$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^{n-1} \left(\begin{matrix}f[1]\\g[1]\end{matrix}\right) =  \left(\begin{matrix}f[n]\\g[n]\end{matrix}\right)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    ll data[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span> data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_row_col</span><span class="params">(matrix &amp;m, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    m.col = col; m.row = row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="function">matrix <span class="title">matrix_multipy</span><span class="params">(matrix &amp;A, matrix &amp;B)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(ret, A.row, B.col);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A.row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B.col; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= A.col; k++)</span><br><span class="line">              ret.data[i][j] = (ret.data[i][j] + A.data[i][k]*B.data[k][j]%mod)%mod;</span><br><span class="line">              <span class="comment">//注意不要写 += ，否则结果可能超过mod，还得再取一次模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始矩阵(f[1], g[1])^T</span></span><br><span class="line">    matrix original_matrix;</span><br><span class="line">    original_matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(original_matrix, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    original_matrix.data[<span class="number">1</span>][<span class="number">1</span>] = original_matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递推矩阵(4, 1, 2, 1)</span></span><br><span class="line">    matrix Relation_Matrix;</span><br><span class="line">    Relation_Matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Relation_Matrix, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Relation_Matrix.data[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span>, Relation_Matrix.data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    Relation_Matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>, Relation_Matrix.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用Re_pow存储关系矩阵的 n - 1 次方</span></span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    matrix Re_pow;</span><br><span class="line">    Re_pow.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Re_pow, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Re_pow.data[<span class="number">1</span>][<span class="number">1</span>] = Re_pow.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//Re_pow初始化为单位矩阵</span></span><br><span class="line">    <span class="comment">// 矩阵快速幂加速矩阵乘法</span></span><br><span class="line">    <span class="keyword">while</span>( n )&#123;</span><br><span class="line">        <span class="keyword">if</span>( n &amp; <span class="number">1</span> )Re_pow = <span class="built_in">matrix_multipy</span>(Re_pow, Relation_Matrix);</span><br><span class="line">        Relation_Matrix = <span class="built_in">matrix_multipy</span>(Relation_Matrix, Relation_Matrix);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用递推矩阵的n - 1次方乘以Original_matrix</span></span><br><span class="line">    matrix ret = <span class="built_in">matrix_multipy</span>(Re_pow, original_matrix);</span><br><span class="line">    cout&lt;&lt;ret.data[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//即f[n]</span></span><br><span class="line">    <span class="comment">// ret.data[1][2]此时为g[n]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第6次OJ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
