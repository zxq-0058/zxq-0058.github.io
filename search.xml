<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PA2.3</title>
      <link href="/2021/10/26/PA2-3/"/>
      <url>/2021/10/26/PA2-3/</url>
      
        <content type="html"><![CDATA[<p>$PA2.3$主要是设备的实现.关系图如下:<br><img src="/2021/10/26/PA2-3/gra.png" alt="逻辑图"><br><span id="more"></span></p><p>AM抽象计算机直接跟我们在其上面运行的各种应用程序打交道,<strong>在am-tests里面的各种测试程序都算是运行在am上的应用程序.(很重要!!)</strong></p><p>应用程序如果想要访问设备,比如说测试集里的$rtc.c$想要获取当前的时间,那么需要跟am进行交互.具体就是通过$io_{-}read,io_{-}write$函数.<br>而AM跟nemu进行设备相关的交流,得通过$inl, outl$等函数对各种设备的地址进行读写<br>$nemu$模拟的硬件设备会将其对应的数据存在指定的内存地址里面,访问和更新设备,实际上就是对内存地址的访问,取出相应的数据和对内存地址的信息进行改写.</p><div class="note danger"><p>将设备的访问放在nemu原则上也是可行的,但是不同架构之间设备的访问是不兼容的.而在AM中,我们约定在不同的架构中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象, 因此我们只需要在<code>abstract-machine/am/src/platform/nemu/ioe/</code>目录下实现一份IOE, 来供NEMU平台的架构共享.<br>AM的出现使得不同架构访问设备更加方便,不用分别在不同架构里面分别实现设备的访问.</p></div> <h3 id="一-时钟的实现"><a href="#一-时钟的实现" class="headerlink" title="(一)时钟的实现"></a>(一)时钟的实现</h3><h4 id="1-riscv-h-和-nemu-h"><a href="#1-riscv-h-和-nemu-h" class="headerlink" title="(1)$riscv.h$和$nemu.h$"></a>(1)$riscv.h$和$nemu.h$</h4><p>$riscv.h$定义了$inb, inw, inl, outb\dots$等函数,<strong>这些函数特别关键,是AM与设备的桥梁.</strong><br><img src="/2021/10/26/PA2-3/image-20211003204455099.png" alt="关键的函数"><br>inb(addr)获取addr地址的数据, 该数据为一个字节.其他类似. outb(addr, data),向addr地址写入一个一字节的数据data.</p><p>$nemu.h$定义了各种设备的的相关物理地址,时钟的物理地址<code>#define RTC_ADDR        (DEVICE_BASE + 0x0000048)</code>,该64位数的地址存储了时间数据(以微秒为单位).</p><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>在$timer.c$的<code>__am_timer_uptime</code> 做如下修改:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime-&gt;us = indl(RTC_ADDR);</span><br></pre></td></tr></table></figure><br>其中<code>indl</code>函数是我们在$riscv.h$<strong>自定义</strong>的访问64位数据的函数,原理与inl等函数完全一样.</p><h4 id="3-如何测试"><a href="#3-如何测试" class="headerlink" title="(3)如何测试?"></a>(3)如何测试?</h4><p><strong>在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=t run</code>.</strong><br>结果如下图:<br><img src="/2021/10/26/PA2-3/image-20211026204348486.png" alt><br><div class="note info"><p>在<code>am-kernals/tests/am-tests/src</code>的main.c定义了各种测试的首字母, 如<code>[&#39;t&#39;] = &quot;real-time clock test&quot;,</code>mainargs根据终端的字母缩写确定运行哪一个测试集. 可以尝试在<code>am-kernals/tests/am-tests/</code>输入<code>make ARCH=riscv32-nemu mainargs=H run</code>,看看会发生什么.</p></div> </p><h4 id="4-流程图"><a href="#4-流程图" class="headerlink" title="(4)流程图"></a>(4)流程图</h4><p><img src="/2021/10/26/PA2-3/gra1.png" alt><br>注:上图的回调函数就是:<code>nemu/src/device/timer.c</code>的<code>rtc_io_handler</code></p><h4 id="5-buggy"><a href="#5-buggy" class="headerlink" title="(5)$buggy?!$"></a>(5)$buggy?!$</h4><p>事实上,上面的代码是有BUG的,而且这个bug虽然在测试终端看不出来(或者说,不明显),但是跑分的时候就会出现非常大的问题(爆分!).因为64位的时间意味着需要调用两次回调函数,先访问高32位还是低32位会一定差别.<br>所以需要将上述代码的64位读取改为<strong>先访问高32位数然后再访问低32位</strong>. 高32位地址为<code>RTC_ADDR + 4</code>, 低32位为<code>RTC_ADDR</code>,两次调用$inl$函数再拼接就可以了.<br><code>(uint64_t)inl(RTC_ADDR + 4)&lt;&lt;32+inl(RTC_ADDR)</code></p><div class="note info"><p>为什么会有访问顺序不同造成的差别?<br>实际上,虽然我们调用两次回调函数,但两次调用只有一次是真正有效的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(nemu/src/device/timer.c)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtc_io_handler</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">int</span> len, <span class="keyword">bool</span> is_write)</span> </span>&#123;</span><br><span class="line">  assert(offset == <span class="number">0</span> || offset == <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> (!is_write &amp;&amp; offset == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> us = get_time();</span><br><span class="line">    rtc_port_base[<span class="number">0</span>] = (<span class="keyword">uint32_t</span>)us;</span><br><span class="line">    rtc_port_base[<span class="number">1</span>] = us &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出,<strong>只有offset = 4才能将”当前系统启动时间”写入内存</strong>,换而言之,如果在<code>inl(RTC_ADDR + 4)</code>之前调用<code>inl(RTC_ADDR)</code>,那么访问到的低32位的时间是上一次”残留”的时间,并不是”当前时间”.</p></div> <h3 id="二-键盘的实现"><a href="#二-键盘的实现" class="headerlink" title="(二)键盘的实现"></a>(二)键盘的实现</h3><p>在我们使用AM(软件)输出键盘信息之前,$nemu$(硬件)模拟的$i8042$芯片已经根据我们在电脑的键盘输入情况将对应的键盘码写入nemu键盘对应的物理地址,所以我们<strong>直接调用前面讲的in函数就可以取出相应的信息了</strong>.至于模拟的芯片怎们写入数据的,可以查看keyboard.c文件.(讲义:每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以访问数据寄存器, 获得键盘码,<strong>只有一个字节(256足够对应整个键盘的所有键了)</strong>)</p><p>值得一提的是,芯片在写入按下(down)时加了一个<strong>掩码处理</strong>,比如1对应空格键盘,如果按下,那么写入信息为0x8001,如果松开,写入信息为0x0001,因此我们在AM(软件)读取地址信息后,还需进一步做<strong>还原处理</strong>,才能正确获知keydown的值.</p><h4 id="1-掩码处理"><a href="#1-掩码处理" class="headerlink" title="(1)掩码处理?!"></a>(1)掩码处理?!</h4><p>查看nemu下面的$keyboard.c$, 掩码处理最重要的一句:<br><code>uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);</code> </p><p>当你按下键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | KEYDOWN_MASK = keymap[ESCAPE] | 0x8000</code>;当你松开键盘的某一个key,比如空格,那么<code>am_scancode = keymap[ESCAPE] | 0 = keymap[ESCAPE]</code>.</p><div class="note info"><p><code>i8042_data_io_handler</code>函数的<code>i8042_data_port_base[0] = key_dequeue();</code>将键盘码写入键盘对应的内存!!!</p></div><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="(2)代码实现"></a>(2)代码实现</h4><p>$input.c$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __am_input_keybrd(AM_INPUT_KEYBRD_T *kbd) &#123;</span><br><span class="line">   kbd-&gt;keydown = <span class="number">0</span>;</span><br><span class="line">   kbd-&gt;keycode = inl(KBD_ADDR);<span class="comment">//读取键盘码,类似于时钟的数据获取</span></span><br><span class="line">   <span class="keyword">if</span> (kbd-&gt;keycode != <span class="number">0</span>)<span class="comment">//不为空(无输入)</span></span><br><span class="line">   &#123;</span><br><span class="line">   <span class="comment">//判断第16位(二进制)是否为1, 如果是,说明做了掩码处理,需要还原,同时将keydown设置为true</span></span><br><span class="line">      <span class="keyword">if</span>(kbd-&gt;keycode &gt;&gt; <span class="number">15</span>)&#123;        </span><br><span class="line">        kbd-&gt;keydown = <span class="literal">true</span>;</span><br><span class="line">        kbd-&gt;keycode = (kbd-&gt;keycode &lt;&lt; <span class="number">17</span>) &gt;&gt; <span class="number">17</span>;<span class="comment">//掩码逆处理</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         kbd-&gt;keydown = <span class="literal">false</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果:<br><img src="/2021/10/26/PA2-3/1.png" alt></p><h3 id="三-vga的实现"><a href="#三-vga的实现" class="headerlink" title="(三)vga的实现"></a>(三)vga的实现</h3><p>$vga$的控制端有两个重要的寄存器(这两个寄存器的具体含义可以通过查看<code>nemu/src/device/vga.c</code>得知), <code>vgactl_port_base[0]</code>的高低16位分别存储屏幕的宽度和高度.<code>vgactl_port_base[1]</code>存储的是是否将屏幕刷新的值(true or false).<strong>(同步寄存器sync register)</strong></p><div class="note info"><p><code>init_vga</code>函数的 <code>vgactl_port_base[0] = (screen_width() &lt;&lt; 16) | screen_height();</code>将屏幕大小信息写入一个32位的存储空间</p></div><h4 id="1-在硬件层面"><a href="#1-在硬件层面" class="headerlink" title="(1)在硬件层面"></a>(1)在硬件层面</h4><p>此处硬件指的是$nemu$的$vga.c$, 里面的<code>void vga_update_screen()</code>提示的非常清楚:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when the sync register is non-zero,</span></span><br><span class="line"><span class="comment">//根据前面</span></span><br><span class="line"> <span class="keyword">if</span>(vgactl_port_base[<span class="number">1</span>] != <span class="number">0</span>)update_screen();</span><br><span class="line"><span class="comment">// then zero out the sync register</span></span><br><span class="line">  vgactl_port_base[<span class="number">1</span>] = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><br>通过阅读vga.c, 还可以知道$width = 400, height = 300$</p><div class="note success"><p>  查看 AM(软件层面) 下面的gpu.c, 可以发现__am_gpu_fbdraw里面有这么一句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);<span class="comment">//写入 1  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:向sync_addr写入1之后,vga_update_screen检查sync寄存器的值(不为 0 ),然后调用update_screen();</p></div><p>添加好讲义给定的测试代码之后,正确的运行结果如下:<br><img src="/2021/10/26/PA2-3/2.png" alt></p><h4 id="2-在软件层面"><a href="#2-在软件层面" class="headerlink" title="(2)在软件层面"></a>(2)在软件层面</h4><p>正确实现$AM_{-}GPU_{-}FBDRAW$的画面如下:<br><img src="/2021/10/26/PA2-3/3.png" alt></p><div class="note warning"><p>上面动画效果怎么来的?    </p></div><p>流程图如下:<br><img src="/2021/10/26/PA2-3/gra2.png" alt></p><p>代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) &#123;</span><br><span class="line">    <span class="comment">//*ctl接受了来自APP(应用程序)的缓冲信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width = inw(WID_ADDR), height = inw(HEIGHT_ADDR);<span class="comment">//获取屏幕宽度, 高度</span></span><br><span class="line">    <span class="keyword">int</span> col, row;</span><br><span class="line">    <span class="comment">//uint32_t *fb = (uint32_t *)(uintptr_t)FB_ADDR;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pixelss = ctl-&gt;pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> point_x = ctl-&gt;x, point_y = ctl-&gt;y, target_w = ctl-&gt;w, target_h = ctl-&gt;h;<span class="comment">//开始的x, y以及绘画区域的w, h</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row = point_y; row &lt; (point_y + target_h) &amp;&amp; row &lt;= height; row++)</span><br><span class="line">      <span class="keyword">for</span> (col = point_x; col &lt; (point_x + target_w) &amp;&amp; col &lt;= width; col++) </span><br><span class="line">      outl(FB_ADDR + (col + row*width)*<span class="number">4</span> , pixelss[target_w*(row - point_y) + col - point_x] );</span><br><span class="line">      <span class="comment">// outl的作用不就是将信息写入指定物理地址</span></span><br><span class="line">      <span class="comment">//等价于fb[col + row*width] = pixelss[target_w*(row - point_y) + col - point_x];</span></span><br><span class="line">  <span class="keyword">if</span> (ctl-&gt;sync) &#123;</span><br><span class="line">    outl(SYNC_ADDR, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码实际上是讲义给出的测试的<strong>进阶版本</strong>,不信可以对比一下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">400</span>;  </span><br><span class="line"><span class="keyword">int</span> h = <span class="number">300</span>;  </span><br><span class="line"><span class="keyword">uint32_t</span> *fb = (<span class="keyword">uint32_t</span> *)(<span class="keyword">uintptr_t</span>)FB_ADDR;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w * h; i ++) fb[i] = i;<span class="comment">//向地址写入像素信息(所以我们会看到第一幅图从左边到右边颜色的递变)</span></span><br><span class="line"> <span class="comment">//等价于for (i = 0; i &lt; w * h; i ++) outl(FB_ADDR + 4 * i, i); 想想outl的作用</span></span><br><span class="line">outl(SYNC_ADDR, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><div class="note info"><p>还是不太理解?!<br> <code>_am_gpu_fbdraw()</code>属于软件层面的函数, 归$AM$管理,这个函数的作用就是将来自于$APP$客户程序的像素信息(该信息存储在缓冲区,并作为<code>_am_gpu_fbdraw()</code>的参数传入)写到物理地址里面,前面讲过,$AM$想要将数据写入物理地址需要借助$out[b|w|l]函数.$ </p></div>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六次OJ</title>
      <link href="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/"/>
      <url>/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/</url>
      
        <content type="html"><![CDATA[<h2 id="A-最大内切球"><a href="#A-最大内切球" class="headerlink" title="A. 最大内切球"></a>A. 最大内切球</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在三维空间中，线性方程$ax+by+cz\leq d$ 构成一个“半空间”。</p><p>现在给出 $n$ 个这样的线性方程，第 $i$ 个线性方程用$(a_i,b_i,c_i,d_i)$表示.</p><p>求在这 $n$ 个线性方程与限制$\{x\geq 0,y\geq 0, z\geq 0\}$构成的”半空间交“中，内切球的最大半径是多少。</p><p>若这个“半空间交”为空（即上述线性方程组无解），则输出4位小数0.0000。</p><p>如果这个球的半径可以为无穷大，则输出”Infinity”，否则输出一个4位小数，表示最大内切球的半径。<br><span id="more"></span></p><p><strong>输入格式</strong></p><p>第一行一个正整数 $T$，表示测试组数。</p><p>每组测试中，第一行输入一个正整数 $n$，表示线性方程的个数，接下来 $n$​ 行，每行4个整数$a,b,c,d$，表示线性方程$ax+by+cz\leq d$.</p><p>保证对每一组线性方程, $a,b,c$​ 不同时为0。</p><p><strong>输出格式</strong></p><p>共 $T$ 行，每行输出一个保留4位小数的答案，或者$Infinity$。</p><p><strong>样例</strong></p><p><strong>样例输入 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>样例输出 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.5000</span></span><br><span class="line"><span class="number">0.2113</span></span><br><span class="line"><span class="number">0.5901</span></span><br><span class="line"><span class="number">0.5000</span></span><br><span class="line">Infinity</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>保证$1\leq T \leq 150, 1\leq n \leq 100, -100\leq a,b,c,d \leq 100, \sum n \leq 2500$。</p><p>保证对于所有答案不为”Infinity“的答案，答案都$\leq 10^9$。</p><p>良心的助教提供了单纯形的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设输入给定的 n 个方程形式为：</p><p>$\begin{cases} a[1, 1] x+ a[1, 2]y + a[1, 3]z\leq a[1, 0]\\a[2, 1] x+ a[2, 2]y + a[2, 3]z\leq a[2, 0] \\\dots \\ \end{cases}$​</p><p>根据给出的==单纯形模板的要求==：</p><p>我们需要将$a[i][j],\ 1\leq j\leq3$取为相反数，记作$b[i][j]$​，那么方程变为</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\ \end{cases}$​​</p><p>这样子就可以直接使用单纯形模板了。</p><p>假定现在的半径为 $radius$​​，设半空间内的某点$(x, y, z)$​​， 根据点到平面的距离公式，我们有：<br>${|ax + by + cz - d|\over\sqrt{a^2 + b^2+c^2} }\geq radius$​</p><p>由于给定条件下$ax + by + cz\leq d$​, 化简之后：</p><p>$-ax -by-cz + d - \sqrt{a^2 + b^2+c^2}\times radius\geq0, \ (1)$​​</p><p>想要知道这个半径所形成的球能否放到我们约束的“半空间”，只需要在原来n个方程的基础上加上 (1) 所形成的 n 个新的约束方程</p><p> ,当然还要注意题目的要求：$x, y, z\geq 0$,根据半径要求：</p><p>$x, y, z\geq radius$</p><p>因此所形成的$2\times n + 3$个限制方程如下：</p><p>$\begin{cases} b[1, 1] x+ b[1, 2] y+ b[1, 3]z + a[1, 0]\geq 0\\b[2, 1] x+ b[2, 2]y + b[2, 3]z+ a[2, 0]\geq 0 \\\dots \\b[n, 1]x +b[n, 2]y + b[n, 3]z+a[n, 0]\geq0\\前n个方程\\b[1,1]x+b[1,2]y+b[1, 3]z+a[1,0]-\sqrt{b_{1,1}^2+b_{1,2}^2+b_{1,3}^2}\times radius\geq0 \\\dots \\由于半径引入的n个方程\\x-radius\geq0\\y-radius\geq0\\z-radius\geq0\end{cases}$</p><p>然后调用单纯形算法就可以判定radius是否合理。==利用这个判定的性质，二分是适合这道题的解法。==</p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m个约束，n个变量</span></span><br><span class="line"><span class="comment">// 第i个约束，sum(a[i][j]*x[j])+a[i][0]&gt;=0</span></span><br><span class="line"><span class="comment">// solve函数返回约束是否有解</span></span><br><span class="line"><span class="comment">// 若有解，则使得目标函数 sum(a[0][j]*x[j]) 最大化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for (int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,n) FOR(i,1,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP_0N(i,n) FOR(i,0,n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line">ld a[<span class="number">1010</span>][<span class="number">10</span>], b[<span class="number">1010</span>][<span class="number">10</span>];</span><br><span class="line">ld x[<span class="number">1050</span>]; </span><br><span class="line"><span class="keyword">int</span> n,m,id[N],tp[N],nn;</span><br><span class="line"><span class="keyword">const</span> ld eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">const</span> ld inf=<span class="number">1e12</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[r+n],id[c]);</span><br><span class="line">    ld t=-a[r][c];</span><br><span class="line">    a[r][c]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,n) a[r][i]/=t;</span><br><span class="line">    <span class="built_in">REP_0N</span>(i,m)</span><br><span class="line">    <span class="keyword">if</span> (a[i][c]&amp;&amp;r!=i) &#123;</span><br><span class="line">        t=a[i][c];</span><br><span class="line">        a[i][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">REP_0N</span>(j,n) a[i][j]+=t*a[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ld t;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) id[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=-eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][<span class="number">0</span>]&lt;w) w=a[i=k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[i][k]&gt;eps) &#123;j=k; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>; ld w=eps;</span><br><span class="line">        <span class="built_in">REP</span>(k,n) <span class="keyword">if</span> (a[<span class="number">0</span>][k]&gt;w) w=a[<span class="number">0</span>][j=k];</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        w=inf;</span><br><span class="line">        <span class="built_in">REP</span>(k,m) <span class="keyword">if</span> (a[k][j]&lt;-eps&amp;&amp;(t=-a[k][<span class="number">0</span>]/a[k][j])&lt;w) w=t,i=k;</span><br><span class="line">        <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FOR</span>(i,n+<span class="number">1</span>,n+m) tp[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">REP</span>(i,n) x[i]=tp[i]?a[tp[i]][<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ld radius, <span class="keyword">int</span> temp_m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i + m][k] = a[i][k];<span class="comment">//新设立的 m 个方程的系数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新设立的 m 个方程的常数d - radius * sqrt(a^2 + b^2 + c^2)</span></span><br><span class="line">        a[i + m][<span class="number">0</span>] = a[i][<span class="number">0</span>] - <span class="built_in">sqrt</span>(a[i][<span class="number">1</span>]*a[i][<span class="number">1</span>] + a[i][<span class="number">2</span>]*a[i][<span class="number">2</span>] + a[i][<span class="number">3</span>]*a[i][<span class="number">3</span>])*radius;</span><br><span class="line">    &#125;</span><br><span class="line">    m += temp_m;<span class="comment">//增加了 temp_m + 3个方程 </span></span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">1</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">1</span>, a[m][<span class="number">3</span>] = <span class="number">0</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    a[++m][<span class="number">1</span>] = <span class="number">0</span>, a[m][<span class="number">2</span>] = <span class="number">0</span>, a[m][<span class="number">3</span>] = <span class="number">1</span>, a[m][<span class="number">0</span>] = -radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        n = <span class="number">3</span>;<span class="comment">//只有三个变量x, y, z</span></span><br><span class="line">        <span class="comment">//输入m个原始约束，并将系数取相反数, b数组用来临时存储a的数据，因为后续单纯形算法可能会改变 a 的部分值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][<span class="number">1</span>]&gt;&gt;a[i][<span class="number">2</span>]&gt;&gt;a[i][<span class="number">3</span>]&gt;&gt;a[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">3</span>; k++)a[i][k] = b[i][k]= -a[i][k];</span><br><span class="line">            b[i][<span class="number">0</span>] = a[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理进行判断：半空间是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;0.0000\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">        ld left = <span class="number">0</span>, right = inf;</span><br><span class="line">        <span class="keyword">int</span> temp_m = m;<span class="comment">//临时存储 m 的值,因为二分每一次check都会修改new_m = old_m*2 + 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; eps)&#123;</span><br><span class="line">            ld medi_radius = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(medi_radius, temp_m))left = medi_radius;</span><br><span class="line">            <span class="keyword">else</span> right = medi_radius;</span><br><span class="line"></span><br><span class="line">            m -= temp_m + <span class="number">3</span>;<span class="comment">//恢复 m 的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复数组a的值，因为单纯形算法可能影响原先数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">                a[i][k] = b[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; eps + <span class="number">1e9</span>)cout&lt;&lt;<span class="string">&quot;Infinity&quot;</span>&lt;&lt;endl;<span class="comment">//半空间不是有限空间（此时left = right = inf = 1e12）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.4Lf\n&quot;</span>,left); <span class="comment">//有限解,注意long double的输出方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-文理分科"><a href="#B-文理分科" class="headerlink" title="B. 文理分科"></a>B. 文理分科</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><strong>题目描述</strong></p><p>在高中时候，yjher所在的班级要进行文理分科。他的班级可以用一个 $n\times m$ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：</p><p>如果第 i 行第 j 列的同学选择了文科，则他将获得$art_{i,j}$的满意值，如果选择理科，将得到$science_{i,j}$ 的满意值。</p><p>如果第 i 行第 j 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $same_art_{i,j}$的满意值。</p><p>如果第 i 行第 j 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加$same_science_{i,j}$的满意值。</p><p>yjher想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。</p><p><strong>输入格式</strong></p><p>输入第一行为两个正整数 n,m。</p><p>接下来 n 行 m 整数，第 i 行第 j 个整数表示$art_{i,j}$</p><p>接下来 n 行 m个整数，第 i 行第 j 个整数表示$science_{i,j}$</p><p>接下来 n 行 m整数，第 i 行第 j 个整数表示$same_{-}art_{i,j}$</p><p>接下来 n 行 m 个整数，第 i 行第 j 个整数表示$same_{-}science_{i,j}$</p><p><strong>输出格式</strong></p><p>输出为一个整数，表示最大的满意值之和。</p><p><strong>样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">13</span> <span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="symbol">18 </span><span class="number">17</span> <span class="number">0</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">13</span> <span class="number">15</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">3</span> <span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">18</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>$n,m\leq 100$,读入数据均$\geq 0,\leq 500$</p><p>1 表示选择文科，0 表示选择理科，样例方案如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">152</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>解法：网络流</strong></p><p>现在先不考虑由于临近的同学选择相同的科目而带来的收益。<br>建立如下网络图：<img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211019203309059.png" alt></p><p>对这个网络调用最大流算法，根据<strong>最小割最大流定理</strong>，这样子求出来的==满意值总和实际上是最小值， 割掉的边实际上是不选的科目==。</p><p>所求满意值最大值为$\sum (art_{i,j}+science_{i, j}) - max_{-}flow$​</p><p><code>----------------------------------------------------------------------------------------------</code></p><p>现考虑由于临近同学选科情况带来的满意值：</p><p>新加入5号点和9号点作为1号的虚拟节点。5 与1,2,3,4的之间边的容量为 $inf$​​ .</p><p>1, 2, 3,4与9之间边的容量为 $inf$<br><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020093816755.png" alt><br>具体分析由于邻近选科情况的满意值：</p><p>假如1号同学==最后选择了文科==，那么根据前面的分析，这里<strong>割掉的边应该是$1\longrightarrow T$</strong>​​</p><ul><li><p>如果与之相邻的2, 3, 4 同学最后选择的也是文科，那么$2, 3,4 \longrightarrow T$​的边均被割断， $S\longrightarrow 5$​不可能被割断（采用反证法：$cut(L, R)， S\in L, T\in R, \ $​如果s -&gt; 5被割断了，那么$5\in R$​, 而$1, 2, 3,4 \in L$​, $cut(L, R) = inf$​, 意味着容量为 inf 的边被割断了，这显然不行)，所以$maxflow$​不包括$same_{-}art_{1, 1}$​​</p><p>最后用$\sum (art_{i,j}+science_{i, j} +same_{-}art_{i,j}  +same_{-}sci_{i, j}) - max_{-}flow$​​​​ 时==没有减去$S\longrightarrow 5$​​​​​的边权==，最大满意值也就将1, 2, 3 , 4选择文科时 ,1 号同学所带来的附加满意值计算在内了。 </p><p>按照这个分析，这个时候$9\longrightarrow T$是应该被割掉的边，因为此时 1 并未与邻近的2, 3, 4一起选择理科。那事实是否如此？</p><p>确实如此，记$cut(L, R)， S\in L, T\in R$​, 那么 9 号要么在L，要么在R。</p><p>假设$9\in R$​​​, 因为$1,2, 3,4 \in L$​, 此时$cut(L, R) = inf$​​​​，因为该cut割掉了2, 3, 4与 9 的容量为 inf 的边，这与容量为 inf 的边无法割断矛盾， 因此符合事实。 所以$9\in L$​, 所以$9\longrightarrow T$​被割断。</p></li><li><p>如果2， 3， 4未必都选文科，根据以上分析，$S\longrightarrow 5$​的边和$9\longrightarrow T$​​都会被割断。</p><p>证明：（反证），不妨设 4 号最终选择了理科，那么$4\longrightarrow T$没有被割断（==割掉的边实际上是不选的科目==），这时如果$S\longrightarrow 5$没有被割断，那么增广路径$S\longrightarrow 5\longrightarrow 4 \longrightarrow T$存在，与最大流终止条件矛盾，9号类似。</p></li></ul><p><code>---------------------------------------------------------------------------------</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_edge_num = <span class="number">400000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max_point_num = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S = <span class="number">0</span>, T;</span><br><span class="line"><span class="keyword">int</span> tot_point_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> ch=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123; X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> X*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星建图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, capacity;</span><br><span class="line">&#125;edges[Max_edge_num];</span><br><span class="line"><span class="keyword">int</span> total_edge_num = <span class="number">0</span>;<span class="comment">//总的点数</span></span><br><span class="line"><span class="keyword">int</span> head[Max_point_num];</span><br><span class="line"><span class="comment">//分析边数数目：原图的点最多有100*100个，与S和T形成20000条边，新点至多有20000个，每一个新点至多6条边，至多120000条边</span></span><br><span class="line"><span class="comment">//这样子至多有：140000*2（注意双向加边）条边，有约30000个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给每一个二维的点赋唯一的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建图加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    edges[total_edge_num].to = end;</span><br><span class="line">    edges[total_edge_num].next = head[start];</span><br><span class="line">    edges[total_edge_num].capacity = capacity;</span><br><span class="line">    head[start] = total_edge_num;</span><br><span class="line">    ++total_edge_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ISAP模块</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">int</span> d[Max_point_num],  cur_edge[Max_point_num], numd[Max_point_num], pre[Max_point_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//三个数组初始化 </span></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">memset</span>(numd, <span class="number">0</span>, <span class="keyword">sizeof</span> numd);</span><br><span class="line"><span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot_point_num; i++)cur_edge[i] = head[i];<span class="comment">//初始化当前弧（当前边）数组 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numd[<span class="number">0</span>] = tot_point_num; </span><br><span class="line"><span class="keyword">int</span> max_flow = <span class="number">0</span>;<span class="comment">//存储最大流 </span></span><br><span class="line"><span class="keyword">int</span> u = S;</span><br><span class="line"><span class="keyword">while</span>(d[S] &lt; tot_point_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> neck, i; </span><br><span class="line"><span class="comment">//找到增广路径 </span></span><br><span class="line"><span class="keyword">if</span>(u == T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> min_flow = inf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据（*）寻找增广路径 </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(min_flow &gt; edges[cur_edge[i]].capacity)</span><br><span class="line">&#123;</span><br><span class="line">min_flow = edges[cur_edge[i]].capacity;</span><br><span class="line">neck = i;<span class="comment">//找到瓶颈节点  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改增广路径上各边的容量:正向边减min_flow，反向边加min_flow </span></span><br><span class="line"><span class="keyword">for</span>(i = S; i != T; i = edges[cur_edge[i]].to)</span><br><span class="line">&#123;</span><br><span class="line">edges[cur_edge[i]].capacity -= min_flow;</span><br><span class="line">edges[cur_edge[i] ^ <span class="number">1</span>].capacity += min_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_flow += min_flow;</span><br><span class="line"><span class="comment">//cout&lt;&lt;max_flow&lt;&lt;endl;</span></span><br><span class="line">u = neck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从瓶颈点继续寻找增广路 </span></span><br><span class="line"><span class="keyword">for</span>(i = cur_edge[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span> &amp;&amp; d[u] == d[edges[i].to] + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到可行出点 </span></span><br><span class="line">cur_edge[u] = i;</span><br><span class="line">pre[edges[i].to] = u;</span><br><span class="line">u = edges[i].to;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">-1</span>)<span class="comment">//找不到下一个点了</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">numd[d[u]]--; </span><br><span class="line"><span class="keyword">if</span>(numd[d[u]] == <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//算法终止</span></span><br><span class="line"></span><br><span class="line">cur_edge[u] = head[u];<span class="comment">//从头再来</span></span><br><span class="line"><span class="keyword">int</span> h = tot_point_num - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edges[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edges[i].capacity &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">h = <span class="built_in">min</span>(h, d[edges[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">d[u] = h + <span class="number">1</span>;<span class="comment">//当d[u] = n时说明u点已经退出残留网络</span></span><br><span class="line">numd[d[u]]++;</span><br><span class="line"><span class="keyword">if</span>(u != S)u = pre[u];<span class="comment">//回溯到上一个顶点</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//找得到下一个出点就继续找，可省略这句 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_flow;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="keyword">sizeof</span> head);<span class="comment">//初始化为 -1</span></span><br><span class="line">    T = n*m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理点的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m; j++)&#123;</span><br><span class="line">            id[i][j] = <span class="built_in">get_id</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入第一个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += art_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, id[i][j], art_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], S, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入第二个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            science_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += science_i_j;</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], T, science_i_j);</span><br><span class="line">            <span class="built_in">add_edge</span>(T, id[i][j] , <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入后两个矩阵</span></span><br><span class="line">    <span class="keyword">int</span> new_node_id = n * m + <span class="number">1</span>; <span class="comment">//新点的id从此数 + 1开始</span></span><br><span class="line">    <span class="keyword">int</span> same_art_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_art_i_j = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            sum += same_art_i_j;</span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(S, new_node_id, same_art_i_j);<span class="comment">//加一条从源点S到新点的边，权值为same_art_i_j</span></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, S, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//枚举4个方向合理的邻居并且加边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> same_science_i_j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            same_science_i_j = <span class="built_in">read</span>();</span><br><span class="line">            </span><br><span class="line">            sum += same_science_i_j;</span><br><span class="line"></span><br><span class="line">            new_node_id++;</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, T, same_science_i_j);<span class="comment">//加一条从新点到汇点 T 的边</span></span><br><span class="line">            <span class="built_in">add_edge</span>(T, new_node_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add_edge</span>(id[i][j], new_node_id, inf);</span><br><span class="line">            <span class="built_in">add_edge</span>(new_node_id, id[i][j], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++)&#123;</span><br><span class="line">                <span class="keyword">int</span> neighbor_x = i + dx[dir], neighbor_y = j + dy[dir];</span><br><span class="line">                <span class="keyword">if</span>(neighbor_x &lt;= <span class="number">0</span> || neighbor_x &gt; n || neighbor_y &lt;= <span class="number">0</span> || neighbor_y &gt; m)<span class="keyword">continue</span>;<span class="comment">//不合法邻居</span></span><br><span class="line">                <span class="built_in">add_edge</span>(id[neighbor_x][neighbor_y], new_node_id, inf);</span><br><span class="line">                <span class="built_in">add_edge</span>(new_node_id, id[neighbor_x][neighbor_y], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tot_point_num = new_node_id;</span><br><span class="line">    cout&lt;&lt;sum - <span class="built_in">ISAP</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Did-you-just-say-……-Acesrc"><a href="#C-Did-you-just-say-……-Acesrc" class="headerlink" title="C. Did you just say …… Acesrc?"></a>C. Did you just say …… Acesrc?</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc解决下面的问题:</p><p>一个梯图$(ladder\ graph)L(n)$一个由$2N$个顶点以及$3N−2$条边组成的平面图。它和如下$2\times N$的格点图是同构的。</p><p><img src="http://roundgod.com/resources/wcy-2.png" alt="http://roundgod.com/resources/wcy-2.png"></p><p>你希望删掉$L(n)$中一些边的集合(可能为空)，并保证剩下的图仍然是联通的。计算你有多少种合法的删除的方案。请输出答案对$10^9+7$取模后的结果。</p><p>如果你能做出这道题，Acesrc便会不再做人，成为唯一A皇。对了,你刚才说了Acesrc,……对吧?</p><p><strong>输入格式</strong></p><p>输入仅包含一行，一个正整数N。</p><p><strong>输出格式</strong></p><p>输出仅包含一行，合法的删除的方案数对$10^9+7$取模后的结果。</p><p><strong>样例</strong></p><p><strong>样例输入1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>样例输出1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>样例输入2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024</span><br></pre></td></tr></table></figure><p><strong>样例输出2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">399356307</span><br></pre></td></tr></table></figure><p><strong>数据范围与提示</strong></p><p>对于$50\%$的数据，有$1\leq N\leq 10^7$。</p><p>对于$100\%%$的数据，有$1\leq N\leq 10^{18}$。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020154943537.png" alt><br>记$g[i]$表示一个$2\times i$​​​的梯图最右侧两个点（上图的 i 和i + i）==不连通，并且整个图只有两个连通分支==的方案数。</p><p>记$f[i]$为$2\times i$的梯图最右侧两个点是连通且整个图只有一个连通分支的方案数。</p><p>考虑状态转移如下：</p><p>$f[i] = 4f[i-1]+g[i-1]$​</p><p>解释：</p><ul><li>在$f[i-1]$的基础上，考虑最后一个格子三条边的情况：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020162606799.png" alt="image-20211020162606799"></p><p>这四种加边情况都可以保证最后整个图是连通的。</p><ul><li>在$g[i-1]$​的基础上，只能加上图的第一种情况。</li></ul><p>$g[i] = 2f[i-1]+g[i-1]$</p><p>解释：</p><ul><li>在$f[i-1]$​​的基础上，考虑最后一个格子三条边的情况（有两种情况,分别是加上边,加下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165138823.png" alt></p><ul><li>在$g[i-1]$的基础上，考虑最后一个格子三条边的情况（只有一种情况,加上边和下边）：</li></ul><p><img src="/2021/10/24/%E7%AC%AC%E5%85%AD%E6%AC%A1OJ/image-20211020165254450.png" alt></p><p>构造矩阵</p><p>$Relation_{-}Matrix = \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)$​​</p><p>$\because f[1] = 1, g[1] = 1$​,</p><p>$\therefore \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right)$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^2\left(\begin{matrix}f[1]\\g[1]\end{matrix}\right)=\left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)\left(\begin{matrix}f[2]\\g[2]\end{matrix}\right) = \left(\begin{matrix}f[3]\\g[3]\end{matrix}\right)$</p><p>$\dots$</p><p>$ \left(\begin{matrix}4&amp;1\\2&amp;1\end{matrix}\right)^{n-1} \left(\begin{matrix}f[1]\\g[1]\end{matrix}\right) =  \left(\begin{matrix}f[n]\\g[n]\end{matrix}\right)$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    ll data[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="keyword">sizeof</span> data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_row_col</span><span class="params">(matrix &amp;m, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    m.col = col; m.row = row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="function">matrix <span class="title">matrix_multipy</span><span class="params">(matrix &amp;A, matrix &amp;B)</span></span>&#123;</span><br><span class="line">    matrix ret;</span><br><span class="line">    ret.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(ret, A.row, B.col);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= A.row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= B.col; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= A.col; k++)</span><br><span class="line">              ret.data[i][j] = (ret.data[i][j] + A.data[i][k]*B.data[k][j]%mod)%mod;</span><br><span class="line">              <span class="comment">//注意不要写 += ，否则结果可能超过mod，还得再取一次模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始矩阵(f[1], g[1])^T</span></span><br><span class="line">    matrix original_matrix;</span><br><span class="line">    original_matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(original_matrix, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    original_matrix.data[<span class="number">1</span>][<span class="number">1</span>] = original_matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递推矩阵(4, 1, 2, 1)</span></span><br><span class="line">    matrix Relation_Matrix;</span><br><span class="line">    Relation_Matrix.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Relation_Matrix, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Relation_Matrix.data[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span>, Relation_Matrix.data[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    Relation_Matrix.data[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>, Relation_Matrix.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用Re_pow存储关系矩阵的 n - 1 次方</span></span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    matrix Re_pow;</span><br><span class="line">    Re_pow.<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">set_row_col</span>(Re_pow, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Re_pow.data[<span class="number">1</span>][<span class="number">1</span>] = Re_pow.data[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//Re_pow初始化为单位矩阵</span></span><br><span class="line">    <span class="comment">// 矩阵快速幂加速矩阵乘法</span></span><br><span class="line">    <span class="keyword">while</span>( n )&#123;</span><br><span class="line">        <span class="keyword">if</span>( n &amp; <span class="number">1</span> )Re_pow = <span class="built_in">matrix_multipy</span>(Re_pow, Relation_Matrix);</span><br><span class="line">        Relation_Matrix = <span class="built_in">matrix_multipy</span>(Relation_Matrix, Relation_Matrix);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用递推矩阵的n - 1次方乘以Original_matrix</span></span><br><span class="line">    matrix ret = <span class="built_in">matrix_multipy</span>(Re_pow, original_matrix);</span><br><span class="line">    cout&lt;&lt;ret.data[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//即f[n]</span></span><br><span class="line">    <span class="comment">// ret.data[1][2]此时为g[n]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第6次OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1599I</title>
      <link href="/2021/10/24/1599I/"/>
      <url>/2021/10/24/1599I/</url>
      
        <content type="html"><![CDATA[<p>预处理:将给定的 N 个点按照 x 从小到大进行排序,设在同一直线上点的编号为$1,2\dots N-1$, 不在直线的点编号为 N </p><div class="note info"><p>若起点恰好是 N ,最优解是$min(dis(1, N-1) + dis(1,N), dis(1, N-1) +dis(N-1, N) )$</p></div> <p><img src="/2021/10/24/1599I/grap.png" alt="这是代替图片的文字，随便写"><br><span id="more"></span><br>证明:假若 N 先经过 i ,$(i\not=N-1, i\not=1)$, 那么此时:</p><p>$total_{-}dis=(\ dis(N, i)+dis(i, N-1) \ )+ dis(N-1, i)+dis(i, 1)$<br>$&gt;dis(N-1, N)+dis(N-1, i)+<br>+dis(i, 1) = dis(N-1, N)+dis(N-1, 1)$</p><div class="note info"><p>若起点不是 N , 固定 $K \leq i&lt; N-1$,<br>$min(dis(k, 1) + dis(1,N), dis(N, i) +dis(k, i) + dis(i, N-1) $<br>,$dis(k, 1) + dis(1, i) + dis(i, N)+dis(N, i+1) + dis(i+1, N))$是候选答案;<br>固定$ 1&lt; j \leq K$, $min(dis(k, N-1) + dis(N-1,N), dis(N, j) +dis(k, j) + dis(j, 1)$<br>$ dis(k, N-1) + dis(N-1, i) + dis(i, N)+dis(N, i-1) + dis(i-1, 1))$是候选答案.</p></div> ]]></content>
      
      
      <categories>
          
          <category> codeforce </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2021/10/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2021/10/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>对于一般的矩阵乘法:$rank(AB)\leq min\{rank (A), rank(B)\}$<br>设$A=(a_{i, j})_{s\times n}$, 那么$rank(AA’)=rank(AA’) = rank(A) = rank(A’)$ : 矩阵与其转秩矩阵的乘积的秩等于原矩阵的秩.<br><span id="more"></span><br>对于$n$阶方阵而言, $|AB| = |A||B|$</p><p>($Binet-Cauchy$公式)设A是$s\times n$的矩阵,B是$n\times s$的矩阵.</p><ul><li>s &gt; n,那么$|AB|=0$($\because AB_{s\times s};rank(AB)\leq rank(A)\leq n &lt; s, \therefore AB是不满秩的$);</li><li>$s\leq n$,那么$|AB|$等于A的所有s阶子式与B的相应的$s$阶子式的乘积的和.<br>即$|AB|=\sum_{1\leq v_1 &lt; v_2 &lt;\dots &lt; v_s\leq n}A\left( \begin{matrix}1, &amp;2, &amp;\dots,&amp;s\\v_1, &amp;v_2, &amp;\dots, &amp;v_s\end{matrix}\right)B\left( \begin{matrix}v_1, &amp;v_2, &amp;\dots, &amp;v_s\\1, &amp;2, &amp;\dots,&amp;s\end{matrix}\right)$</li></ul><h2 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h2><p>对于数域 K 上的矩阵A,若存在 K 上的矩阵 B ,使得$AB=BA=I$, 那么A为可逆矩阵(非奇异矩阵),显然,A是方阵.B 记作 $A^{-1}$</p><p>伴随矩阵:把 n 阶矩阵的第一行元素的代数余子式作为第一行的元素,第二行的元素的代数余子式作为第二行…这样子所形成的$n\times n$矩阵为 A 的伴随矩阵,记为$A*$<br>通过伴随矩阵我们有可逆矩阵的一种写法:<br>$A^{-1}=\frac{A* }{|A|}$,可逆矩阵的充要条件是$|A|=0$</p><p>如果A,B都是 n 阶矩阵,并且AB=I,那么A,B均是可逆矩阵,并且A,B互为可逆矩阵.</p><p>可逆矩阵通过一系列行初等变换之后可以简化为单位矩阵.即$P_s\dots P_2P_1A=I$.因此$A^{-1}=P_s\dots P_2P_1$<br>$A=P_1^{-1}P_2^{-1}\dots P_s^{-1}$.任何一个可逆矩阵都可以写成一系列初等矩阵的乘积.</p><p>性质:</p><ul><li>$(AB)^{-1}=B^{-1}A^{-1}$ 可以推广到一般情况.</li><li>$(A’)^{-1} = (A^{-1})’$</li><li>用一个初等矩阵左乘(右)矩阵A,不改变 A 的秩.更一般的说法:用一个可逆矩阵左乘(右)矩阵A,不改变 A 的秩. 若记可逆矩阵 Q ,那么$rank(QA)=rank(A)$</li></ul><p>除了伴随矩阵的写法,初等变换法也是求可逆矩阵的方法:<br>$\left(\begin{matrix} A|I\end{matrix}\right)\Longrightarrow \left(\begin{matrix} I|A^{-1}\end{matrix}\right)$</p><h2 id="矩阵的分块"><a href="#矩阵的分块" class="headerlink" title="矩阵的分块"></a>矩阵的分块</h2><p>分块矩阵的转秩:<br>如$\left(\begin{matrix} A_1&amp;A_3\\A_2&amp;A_4\end{matrix}\right)’ = \left(\begin{matrix} A_1’ &amp;A_2’\\A_3’ &amp;A_4’\end{matrix}\right)$<br><div class="note default"><p>分块对角矩阵:主对角线上的所有子矩阵都是<strong>方阵</strong>,其余子矩阵全为0的分块矩阵称为分块对角矩阵.简单写作$diag\{A_1, A_2,\dots A_s\}$.<br>类似可以定义分块上(下)三角矩阵.</p></div></p><p>分块矩阵的三种初等行变换:</p><ul><li>左乘 矩阵P加到另一行块:<br>如$\left(\begin{matrix} A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right) = \left(\begin{matrix}A_{11}&amp;A_{12}\\A_{21}+PA_{11}&amp;A_{22}+PA_{12}\end{matrix}\right)$</li><li>两个行块互换位置:<br>如$\left(\begin{matrix} A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right) = \left(\begin{matrix}A_{21}&amp;A_{22}\\A_{11}&amp;A_{12}\end{matrix}\right)$</li><li>用一个可逆矩阵乘以某一行块:<br>如$\left(\begin{matrix} A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right) = \left(\begin{matrix}A_{11}&amp;A_{12}\\PA_{21}&amp;PA_{22}\end{matrix}\right)$实际上相当于对这一局部区域进行若干次初等行变换.</li></ul><div class="note danger"><p>类似定义初等列变换,不过上面的1,3类型变为<strong>右乘</strong>,如右乘 矩阵P加到另一列块:$\left(\begin{matrix} A_{11}&amp;A_{12}\\A_{21}&amp;A_{22}\end{matrix}\right) = \left(\begin{matrix}A_{11}&amp;A_{12}+A_{11}P\\A_{21}&amp;A_{22}+A_{21}P\end{matrix}\right)$</p></div><p>定义:将一个分块单位矩阵经过一次分块矩阵的初等行变换得到的矩阵称为分块初等矩阵.如<br>$\left(\begin{matrix} I &amp;0\\0&amp;I\end{matrix}\right) = \left(\begin{matrix}I&amp;0\\P&amp;I\end{matrix}\right)$<br>对一个分块矩阵 A 做第一种初等行变换,就当于用一个相应的分块初等矩阵<strong>左乘</strong>A.</p><p>例1:<br>设A, B分别是$s\times n, n\times s$矩阵,则<br>$\left|\begin{matrix} I_{n}&amp;B\\A&amp;I_s\end{matrix}\right| = |I_s-AB|$<br>证明:<br>$\left(\begin{matrix}I_n&amp;B\\A&amp;I_{s}\end{matrix}\right) = \left(\begin{matrix}I_n&amp;0\\ -A&amp;I_s\end{matrix}\right)\left(\begin{matrix}I_n&amp;B\\0&amp;I_s-AB\end{matrix}\right)$<br>所以$\left|\begin{matrix}I_n&amp;B\\A&amp;I_{s}\end{matrix}\right| = \left|\begin{matrix}I_n&amp;0\\ -A&amp;I_s\end{matrix}\right|\left|\begin{matrix}I_n&amp;B\\0&amp;I_s-AB\end{matrix}\right|=|I_s-AB|$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
