# Pa1

我完成了Pa1的全部内容。

### 1.必做题

###### （1）尝试理解计算机如何计算？

站在计算机的角度，计算机只能够识别01序列，不管是汇编指令还是高级语言计算机都无法识别。所以计算机计算1+2+3...+100,必须要有01构成的指令指导当前要做什么，以及下一条指令的内容。根据讲义

```
// PC: instruction    | // label: statement
0: mov  r1, 0         |  pc0: r1 = 0;
1: mov  r2, 0         |  pc1: r2 = 0;
2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;
3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;
4: blt  r2, 100, 2    |  pc4: if (r2 < 100) goto pc2;   // branch if less than
5: jmp 5              |  pc5: goto pc5;
```

可以知道要计算该结果，需要5种指令，包含不同的操作码，还需包含寄存器的编号、操作数等组合，同时需要存储对应的计算结果。

综述，由相应的01机器指令告诉计算机要做什么事情，是加、跳转还是其他类型，并将执行结果存储。

###### （2）状态图

$(0,x,x)\rightarrow (1,0,x)\rightarrow(2,0,0)\rightarrow(3,0,1)\rightarrow(4,1,1)\rightarrow(2,1,1)\rightarrow(3,1,2)\rightarrow(4,3,2)$

$...\rightarrow(2,4851,98)\rightarrow(3,4851,99)\rightarrow(4,4950,99)\rightarrow(2,4950,99)\rightarrow(3,4950, 100)\rightarrow(4,5050,100)\rightarrow(5,5050,100)$

###### （3）基础设施

GDB的时间：500×90%×30s×20 = 270000s

SDB的时间：500×90%×10s×20 = 90000s

###### （4）手册

- seletor：i386手册96页

  ![image-20210907200729539](/home/zxq/.config/Typora/typora-user-images/image-20210907200729539.png)

- EFLAGS寄存器中的CF位是什么意思?

阅读范围：INTEL 80386 PROGRAMMER'S REFERENCE MANUAL  **P34以及Appendix C  P419**：

![image-20210907173429353](/home/zxq/.config/Typora/typora-user-images/image-20210907173429353.png)

该图CF是Carry Flags.![image-20210907174117115](/home/zxq/.config/Typora/typora-user-images/image-20210907174117115.png)

据此CF是借位标志。

- ModR/M字节是什么?            

  是i386的一种寻址方式，它又包含多种寻址模式。i386手册的241页。原文部分：

![image-20210907181405404](/home/zxq/.config/Typora/typora-user-images/image-20210907181405404.png)

- mov指令的具体格式是怎么样的?

i386手册P345页，部分截图：

![image-20210907181139756](/home/zxq/.config/Typora/typora-user-images/image-20210907181139756.png)

格式在该页进行说明：目的$\leftarrow$源操作数

- mips32有哪几种指令格式?

有三种指令格式： R、J、I . 参考mips32 第一卷 P36

![image-20210907182551966](/home/zxq/.config/Typora/typora-user-images/image-20210907182551966.png)

- CP0寄存器是什么?

mips32 第三卷 P7 概述了CP0寄存器的基本功能：在ISA和PRA之间交互，系统协助处理器。

在该卷的第六章对该系列的寄存器进行介绍：从0号到14号，有随机寄存器、status寄存器等。

- 若除法指令的除数为0, 结果会怎样?

会发出Exception信号Division By Zero。参考第一卷53页。

![image-20210907200240252](/home/zxq/.config/Typora/typora-user-images/image-20210907200240252.png)

- riscv32有哪几种指令格式?

R、I、U、J、S、L。参考手册：RISC-V Reader(David Patterson .etc)的目录前。

- LUI指令的行为是什么?

加载立即数到高 位（lui）将 20 位常量加载到寄存器的高 20 位。参考手册:RISC-V Reader P 27。

- mstatus寄存器的结构是怎么样的?

![image-20210907201810591](/home/zxq/.config/Typora/typora-user-images/image-20210907201810591.png)

参考手册：RISC-V Reader(David Patterson .etc)的 P 101。



###### （5）shell命令

`nemu/`目录下的所有.c和.h和文件总共代码行数：

`find . -name "*.[c|h]" |  xargs cat |wc -l`

![image-20210907203445782](/home/zxq/.config/Typora/typora-user-images/image-20210907203445782.png)

去除空格（添加grep筛选除去空格，^$是空行的意思）：

![image-20210907203703121](/home/zxq/.config/Typora/typora-user-images/image-20210907203703121.png)

切换到pa0分支并执行：

![image-20210907203941644](/home/zxq/.config/Typora/typora-user-images/image-20210907203941644.png)

二者做差为423。

在build.mk添加计数指令如下：

![image-20210907205334250](/home/zxq/.config/Typora/typora-user-images/image-20210907205334250.png)



###### （6）-Wall`和`-Werror`有什么作用? 为什么要使用`-Wall`和`-Werror

-Wall生成所有警告信息。 -Werror将警告设置为错误处理。目的：生成调试信息，方便调试。

### 2.实验心得和想法

整个实验过程我将Pa1的讲义反复阅读多次，感觉讲义讲得非常清楚，每次阅读也总能发现新的东西，从而理解代码中的某一部分新的细节。我从8月20号左右开始做Pa1（当时做的是20的仓库）,从一开始看讲义以及代码一头雾水，到后来忽略makefile的细节只管实现监控器的功能，到听了jyy老师的录播慢慢知道nemu的基本构建逻辑，对代码的makefile等部分有了更细的理解。（理解果真是一个螺旋上升的过程）

自己在实验过程的一些愚蠢的"BUG"（太多了）：

1.表达式处理返回值类型习惯性写成int，实际应该是word_t。

2.生成多个随机表达式之间忘记加终止符，导致不同表达式生成互相干扰，生成错误表达式，排查了很久的表达式生成算法没发现问题，最后发现是生成式子主循环有问题。

...

感谢夏天钰同学，在过滤除0表达式给出建议。



### 3.选做编程题

41）负数功能已经实现。



### 5.选做思考题

（1）计算机可以没有寄存器吗？

从理论的角度讲是可以没有寄存器的，只不过这样子数据的传输速度会明显变慢很多。

（2）从哪里开始阅读code？ 一个程序从哪里开始执行呢?

nemu的nemu-main.c

（3） kconfig生成的宏与条件编译：

gcc编译器会在预处理的时候将code的当中的宏定义展开为定义的内容。这一点可以在nemu目录下的build.mk加上如下注释内容就可以在bulid相应目录下生成 .i文件，这样子代码中的宏定义就便全部展开成定义内容，方便后续的编译等：

![image-20210907151150087](/home/zxq/.config/Typora/typora-user-images/image-20210907151150087.png)

（4）为什么全部都是函数?

将init_monitor的功能拆解为子功能并封装实现，只向init_monitor()提供API，逻辑清楚，同时这些API的灵活性更强，必要时可以向除了init_monitor()的函数提供接口。

（5）这些参数是从哪里来的呢?

查阅monitor的parse分析函数，发现在nemu目录下make run的时候里面的参数（如log、batch）并不是从我们的命令行输入的，![image-20210907154051115](/home/zxq/.config/Typora/typora-user-images/image-20210907154051115.png)

--log一句实际上是默认向main()、init_monitor(当然也包括parse_args)传递了参数。

那么我们可以自己在命令行终端输入log、batch、port等定义在parse_args的选项吗？

答案是肯定的（如下）：

![image-20210907154611669](/home/zxq/.config/Typora/typora-user-images/image-20210907154611669.png)

/home/zxq/ics2021/nemu/build/riscv32-nemu-interpreter是一个二进制文件，终端输入参数被放入main(argc, argv[])分析，main又进一步调用init_monitor，内部的parse_args可以将输入的参数进行语法分析并执行相应命令。

**综上，parse_args、init_monitor参数可以从我们的终端输入，也可以make以默认参数（--log...）输入。**

（6） 究竟要执行多久?

-1作为无符号数字是inf,表示指令数目很大，足够执行一般的程序。

（7） 谁来指示程序的结束?

并非当程序执行到`main()`函数返回处的时候, 程序就退出了。如在mian里面调用另一个函数，并在该函数内部调用exit(0)或者assert(0)。

（8）为什么printf()的输出要换行?

不换行的话，打印结果之间可能会互相“干扰”，比如打印两个数字，不换行的话会看到一个数字，无法得知两次打印结果分别是多少。

（9）如果生成的表达式有除0行为, 你编写的表达式生成器的行为又会怎么样呢?以及过滤除0行为的表达式

**编译器会给出警告：div-by-zero。**

如何过滤表达式：

![image-20210907164155433](/home/zxq/.config/Typora/typora-user-images/image-20210907164155433.png)

-Werror可以将警告信息作为错误信息，使得ret！=0,跳过此次循环，从而过滤该表达式。

（10）框架代码中定义`wp_pool`等变量的时候使用了关键字`static`, `static`在此处的含义是什么? 为什么要在此处使用它?

static 静态变量只能在本编程单元内使用，其他文件无法使用。这样子的话就确保wp_pool的安全性，不会被其他文件使用导致一些不好的结果。
